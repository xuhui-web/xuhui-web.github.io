{"title":"03搭建登录架构","uid":"d2e69685384ff9d5134e8cda74cb22b8","slug":"vue3.2后台管理系统/03搭建登录架构","date":"2022-08-22T13:02:44.000Z","updated":"2022-08-23T02:29:35.271Z","comments":true,"path":"api/articles/vue3.2后台管理系统/03搭建登录架构.json","keywords":null,"cover":"/img/photo-1591693117893-7cbfc0a7ac69.jpg","content":"<h1 id=\"03搭建登录架构\"><a href=\"#03搭建登录架构\" class=\"headerlink\" title=\"03搭建登录架构\"></a>03搭建登录架构</h1><h2 id=\"01：前言\"><a href=\"#01：前言\" class=\"headerlink\" title=\"01：前言\"></a>01：前言</h2><p>在上一章中，我们处理了基本的编码规范，那么接下来我们就可以实现对应的项目开发了。</p>\n<p>那么在之后的项目开发中，我们将会使用最新的 <code>vue3 script setup</code> 语法。</p>\n<p>所以说在本章节中我们需要做两件事情：</p>\n<ol>\n<li><p><code>vue3</code> 最新特性及最新语法</p>\n<ol start=\"2\">\n<li>登录功能开发</li>\n</ol>\n</li>\n</ol>\n<p>不过大家放心，我们不会把大量的时间花费到 <strong>枯燥的语法学习之中</strong>，而是会在实际的项目开发中和大家一起逐渐深入学习  <code>script setup</code> 语法，毕竟 <strong>学以致用</strong> 才是我们遵循的唯一目标。</p>\n<p>那么明确好了我们接下来要做的事情之后，咱们就开始新的篇章吧！</p>\n<h2 id=\"02：vue3-项目结构解析\"><a href=\"#02：vue3-项目结构解析\" class=\"headerlink\" title=\"02：vue3 项目结构解析\"></a>02：vue3 项目结构解析</h2><p>想要进行项目的开发，那么首先我们需要先去了解一下 <code>vue3</code> 项目的初始结构</p>\n<p>在这里我们把它和 <code>vue2</code> 的项目进行对比来去说明</p>\n<ol>\n<li><code>main.js</code><ol>\n<li>通过 <strong>按需导入</strong>的 <code>createApp</code> 方法来来构建 <code>vue</code> 实例</li>\n<li>通过 <code>vue实例.use</code> 方法来挂载插件（<code>router</code>、<code>vuex</code>）</li>\n<li>没有了 <code>Vue</code> 构造方法，无法再挂载原型</li>\n</ol>\n</li>\n<li><code>App.vue</code><ol>\n<li>组件内部结构无变化，依然是<ol>\n<li><code>tempalte</code></li>\n<li><code>script</code></li>\n<li><code>style</code></li>\n</ol>\n</li>\n<li><code>&lt;template&gt;</code> 标签中支持多个根标签</li>\n</ol>\n</li>\n<li><code>store/index.js</code><ol>\n<li>通过 <strong>按需导入</strong>的 <code>createStore</code> 方法来来构建 <code>store</code> 实例</li>\n<li>无需再通过 <code>Vue.use(Vuex)</code> 的形式进行挂载</li>\n</ol>\n</li>\n<li><code>router/index.js</code><ol>\n<li>通过 <strong>按需导入</strong>的 <code>createRouter</code> 方法来构建 <code>router</code> 实例</li>\n<li>通过 <strong>按需导入</strong>的 <code>createWebHashHistory</code> 方法来创建 <strong><code>hash</code> 模式对象</strong>，进行路由模式指定</li>\n<li>无需再通过 <code>Vue.use(VueRouter)</code> 的形式进行挂载</li>\n<li><code>routes</code> 路由表的定义无差别</li>\n</ol>\n</li>\n</ol>\n<p>综上所述，在 <code>vue3</code> 的初始化项目中，与 <code>vue2</code> 对比的最大差异其实就是两点：</p>\n<ol>\n<li><code>vue3</code> 使用 <strong>按需导入的形式</strong> 进行初始化操作</li>\n<li><code>&lt;template&gt;</code> 标签中支持多个根标签</li>\n</ol>\n<p>那么这一小节我们主要了解了 <code>vue3</code> 项目的初始结构，通过了解我们也可以发现现在的项目中，存在很多的 <strong>无用代码</strong>，那么下一小节我们就需要 <strong>删除掉这些无用的默认代码</strong>，也就是进行  <strong>初始化项目</strong> 操作。</p>\n<h2 id=\"03：初始化项目结构\"><a href=\"#03：初始化项目结构\" class=\"headerlink\" title=\"03：初始化项目结构\"></a>03：初始化项目结构</h2><p><code>@vue/cli</code> 在帮助我们创建项目的同时，也生成了很多无用的代码，那么这一小节我们需要去除掉这些无用的代码。</p>\n<p>去除的方式如下所示：</p>\n<ol>\n<li><p><code>App.vue</code> 初始化代码如下：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;router-view &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot;&gt;&lt;&#x2F;style&gt;</code></pre>\n</li>\n<li><p>删除 <code>views</code> 文件夹下的所有 <code>.vue</code> 文件</p>\n</li>\n<li><p>删除 <code>components</code> 文件夹下的所有 <code>.vue</code> 文件</p>\n</li>\n<li><p><code>router/index.js</code> 中初始化代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createRouter, createWebHashHistory &#125; from &#39;vue-router&#39;\n\nconst routes &#x3D; []\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHashHistory(),\n  routes\n&#125;)\n\nexport default router\n</code></pre>\n</li>\n<li><p>浏览器中重新访问你的应用，得到如下页面即可：<img src=\"/\"></p>\n<img src=\"03搭建登录架构/image-20210907193641796.png\" alt=\"image-20210907193641796\" style=\"zoom:67%;\" /></li>\n</ol>\n<h2 id=\"04：vue3-新特性介绍\"><a href=\"#04：vue3-新特性介绍\" class=\"headerlink\" title=\"04：vue3 新特性介绍\"></a>04：vue3 新特性介绍</h2><p>在开始本小节的内容之前，我必须要先声明一点：</p>\n<p><strong>我们不会在课程中专门开辟出一段内容讲解 <code>vue3</code> 的知识。而是会在项目开发的过程中，通过实际场景逐步解锁对应的知识点，以达到学以致用的目的！</strong></p>\n<p>所以说本小节的 <strong><code>vue3</code> 新特性介绍</strong> ，我们只会概述性的来介绍一下 <code>vue3</code> 中新增的主要内容。</p>\n<p>那么明确好了我们的目标之后，<code>vue3</code> 中到底新增了哪些比较核心的东西呢？：</p>\n<ol>\n<li><code>composition API</code></li>\n<li>使用了 <code>Proxy</code> 代替 <code>Object.defineProperty()</code> 实现响应式</li>\n<li>全新的全家桶</li>\n<li>全新的 <code>TS</code> 支持</li>\n<li><code>vite</code></li>\n</ol>\n<h3 id=\"Composition-API：组合式-API\"><a href=\"#Composition-API：组合式-API\" class=\"headerlink\" title=\"Composition API：组合式 API\"></a>Composition API：组合式 API</h3><p>想要了解 <strong>组合式 API</strong>，那么首先我们需要先了解 <code>options API</code>，也就是 <code>vue2</code> 中的开发形式。</p>\n<p><code>vue2</code> 中的开发形式被称为 <code>options API</code>，<code>options API</code> 存在</p>\n<ul>\n<li>方便</li>\n<li>易学</li>\n<li>清晰</li>\n</ul>\n<p>等一些特点，但是也存在着一些问题。</p>\n<p>而其中最主要的一个问题就是：<strong>当你的组件变得越来越复杂时，组件的可读性会变得越来越差。</strong></p>\n<p>不知道大家有没有遇到过一种情况，那就是：<strong>你在完成一个组件代码时，总是需要不停的上下滚动滚轮，来查看 <code>data</code> 、<code>methods</code>、<code>computed</code> 之间的配合使用，就像下面一样</strong></p>\n<p>![](.&#x2F;03搭建登录架构&#x2F;options api.gif)</p>\n<p>这个截图中的代码大家不需要深究。</p>\n<p>在这个动图中我们定义的两个数据 <code>optionsData</code> 和 <code>selectOption</code>，然后我们在多个方法中都使用到了它们，但是大家可以发现，我们在使用或查看的过程中，得一直不停的翻动页面！</p>\n<p>因为我们的整体组件代码结构是这样的：</p>\n<img src=\"03搭建登录架构/image-20210907203504116.png\" alt=\"image-20210907203504116\" style=\"zoom:67%;\" />\n\n<p><strong>定义数据与使用数据被分割在组件的各个位置，导致我们需要不断地翻滚页面来查看具体的业务逻辑！</strong></p>\n<p>并且这种现象随着组件越来越复杂，这种情况会变得越来越严重！</p>\n<p>而这个就是 <code>options API</code> 所存在的问题：<strong>当你的组件变得越来越复杂时，组件的可读性会变得越来越差。</strong></p>\n<p>而 <code>Composition API</code> 所期望解决的就是这么一个问题</p>\n<img src=\"/post/vue3.2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/03%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84/1570466251996_04-logical-concerns.jpg\" class=\"\" title=\"img\">\n\n<p><strong>把定义数据与使用数据的逻辑放在一起进行处理，以达到更加易读，更加方便扩展的目的！</strong></p>\n<p>那么具体怎么去做的，我们会在后面的课程中通过最新的 <code>RFC -&gt; script setup</code> 语法为大家进行解读。 </p>\n<h3 id=\"使用了-Proxy-代替-Object-defineProperty-实现响应式\"><a href=\"#使用了-Proxy-代替-Object-defineProperty-实现响应式\" class=\"headerlink\" title=\"使用了 Proxy 代替 Object.defineProperty() 实现响应式\"></a>使用了 <code>Proxy</code> 代替 <code>Object.defineProperty()</code> 实现响应式</h3><p>在 <a href=\"https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">vue 2 的文档中</a> 有这么一段话：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化。</p></blockquote>\n<p>这里所谓的 <strong><code>JavaScript</code> 的限制</strong>，所指的就是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty()</a> 的限制。</p>\n<p>因为 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty()</a> 是通过：<strong>为对象属性指定描述符</strong> 的方式来监听 **对象中某个属性的 <code>get</code> 和 <code>set</code>**。</p>\n<p>所以在以下两种情况下，新的属性是 <strong>非响应式的</strong>：</p>\n<ol>\n<li><p><a href=\"https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1\">对于对象</a>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var vm &#x3D; new Vue(&#123;\n  data:&#123;\n    a:1\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; &#96;vm.a&#96; 是响应式的\n\nvm.b &#x3D; 2\n&#x2F;&#x2F; &#96;vm.b&#96; 是非响应式的</code></pre>\n\n\n</li>\n<li><p><a href=\"https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84\">对于数组</a>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var vm &#x3D; new Vue(&#123;\n  data: &#123;\n    items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n  &#125;\n&#125;)\nvm.items[1] &#x3D; &#39;x&#39; &#x2F;&#x2F; 不是响应性的\nvm.items.length &#x3D; 2 &#x2F;&#x2F; 不是响应性的</code></pre></li>\n</ol>\n<p>这也是为什么会存在 <a href=\"https://cn.vuejs.org/v2/api/#Vue-set\">Vue.set</a> 这个 <code>API</code> 的原因。</p>\n<p>但是，这样的一种情况其实一直都是不合理的，因为这只是无意义的增加了复杂度而已，但是一直以来因为  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty()</a> 这个 <code>API</code> 本身的限制，所以一直无法处理。</p>\n<p>直到 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a> 被广泛支持，这种情况才发生了变化。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a> 用于：<strong>为对象创建一个代理，从而实现基本操作的拦截。</strong> 那么这样就从根本上解决了 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty()</a> 所面临的那么两个问题。这也是为什么 <code>vue3</code> 中不再有 <code>Vue.set</code> 方法的原因。</p>\n<p>关于 <code>proxy</code> 的详细介绍，大家可以查看这一篇博客 <a href=\"https://www.imooc.com/article/320582\">Vue 3 深入响应式原理 - 聊一聊响应式构建的那些经历</a>，在视频中，我们就不过多赘述了</p>\n<h3 id=\"全新的全家桶\"><a href=\"#全新的全家桶\" class=\"headerlink\" title=\"全新的全家桶\"></a>全新的全家桶</h3><p><code>vue</code> 被称为是 <strong>渐进式框架</strong>，就是因为，对于 <code>vue</code> 而言，它不仅仅只有 <code>vue.js</code> 这一个核心库，还有其他的比如 <a href=\"https://next.router.vuejs.org/zh/\">vue-router</a>，<a href=\"https://next.vuex.vuejs.org/zh/index.html\">vuex</a> 等一些周边库。这些周边库和 <code>vue.js</code> 一起共同组成了 <code>vue</code> 。</p>\n<p>所以说当 <code>vue3</code> 发布之后，<code>vue-router</code>、<code>vuex</code> 等全家桶也迎来了一波更新。在前面的 <strong>vue3 项目结构解析</strong> 这一小节，大家应该也能看到对应的代码变化。</p>\n<p>那么关于全家桶的更新内容，我们会在后面的课程中进行详细的讲解，所以就不在这里进行赘述了。</p>\n<h3 id=\"全新的-TS-支持\"><a href=\"#全新的-TS-支持\" class=\"headerlink\" title=\"全新的 TS 支持\"></a>全新的 <code>TS</code> 支持</h3><p><code>vue 3</code> 使用 <code>TypeScript</code> 进行了重构，其目的是 <strong>为了防止随着应用的增长，而产生的许多潜在的运行时静态类型的错误</strong> 。同时这也意味着以后在 <code>vue</code> 中使用 <code>TypeScript</code> 不再需要其他的任何工具。</p>\n<p>但是有一点我需要提醒大家，虽然 <code>vue</code> 对 <code>TypeScript</code> 进行全面支持，这并不代表我们应该在任何情况下都<strong>无条件</strong>的使用 <code>TypeScript</code>（后面我们简称 <code>TypeScript</code> 为 <code>TS</code>）。</p>\n<p><code>TS</code> 的优势主要在于 <strong>静态类型检查和环境声明</strong>，但同时它也会为你的项目增加复杂度。如果你的项目需要使用到以上两点，那么我推荐你使用 <code>TS</code> 。否则只是增加了无谓的复杂度而已。</p>\n<p><strong>决定我们应该使用哪种技术的唯一条件，就是我们的目标。</strong> 我们需要做的是在可以 <strong>完成目标</strong> 的基础上，寻找最简单的实现方案。</p>\n<p>所以，基于以上原因，我们项目中并<strong>没有</strong>使用 <code>TS</code> 进行项目的开发。如果在后续的过程中，发现大家有这方面的需要，那么我会考虑专门针对 <code>TS</code> 的特性来开发一个对应的项目。</p>\n<h3 id=\"vite\"><a href=\"#vite\" class=\"headerlink\" title=\"vite\"></a>vite</h3><p>最后就是一个新的打包工具 <a href=\"https://cn.vitejs.dev/\">vite</a>，<a href=\"https://cn.vitejs.dev/\">vite</a> 严格来说不能算是 <code>vue3</code> 的内容，只不过它跟随 <code>vue3</code> 进行了发布所以我们这里就把它算到了新特性里面。</p>\n<p><a href=\"https://cn.vitejs.dev/\">vite</a> 的作用其实和 <a href=\"https://webpack.docschina.org/\">webpack</a> 是一样的，都是一个 <strong>前端构建工具</strong>。它区别于 <code>webpack</code> 的地方在于它完全使用了 <code>ES Module</code> 的特性，可以无需预先打包，而是采用实时编译的方式。这样让它具备了远高于 <code>webpack</code> 的启动速度和热更新速度。</p>\n<p>但是 <strong>成也萧何，败也萧何</strong> 因为 <code>vite</code> 完全依赖 <code>ES Module</code> 就导致了 它无法直接对 <code>commonJS</code> 的模块化方式进行支持，必须得采用 <a href=\"https://cn.vitejs.dev/guide/dep-pre-bundling.html\">依赖预构建</a> 的形式。</p>\n<p>目前 <code>vite</code> 还不够稳定到足够支持商用，所以如果大家只是想要尝鲜，那么没有问题。如果大家希望创建一个商用的大型项目，那么个人还是推荐更加成熟的 <code>webpack</code> 方案。</p>\n<p>而我们当前的项目旨在构建一个 <strong>后台前端解决方案系统</strong>，所以我们这里依然选择了 <code>webpack</code> ，而不是 <code>vite</code>。</p>\n<h2 id=\"05：全新的提案语法：script-setup\"><a href=\"#05：全新的提案语法：script-setup\" class=\"headerlink\" title=\"05：全新的提案语法：script setup\"></a>05：全新的提案语法：script setup</h2><p>如果大家使用过 早期的 <code>composition API</code> ，那么应该会对 <code>setup 函数</code> 感触颇深，它的语法是反人类的。</p>\n<p>所以在  <code>vue3</code> 正式发布 40天 之后， 也就是 <code>2020年10月28日</code> （<code>vue3</code> 正式发布日期为 <code>2020年9月18日</code>）提出了新的 <a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0040-script-setup.md\">script  setup</a> 提案，该提案的目的只有一个：<strong>那就是让大家可以更爽的使用 <code>composition API</code> 语法</strong>！</p>\n<p>该提案在 <code>2021年8月9日</code> 正式定稿，并伴随着最新的 <code>vue3</code> 版本进行了发布，这也是为什么前面我们需要升级到最新的 <code>vue</code> 版本的原因。</p>\n<p>下面两张截图为对比 <code>原setup函数</code>  与   <code>script setup</code>：</p>\n<ol>\n<li><code>原 setup</code>函数<img src=\"03搭建登录架构/image-20210908103648564.png\" style=\"zoom:67%;\" /></li>\n<li><code>script setup</code><img src=\"03搭建登录架构/image-20210908104702818.png\" alt=\"image-20210908104702818\" style=\"zoom:67%;\" /></li>\n</ol>\n<p>从截图中可以看出 <code>script setup</code> 语法更加符合我们开发者书写 <code>JS</code> 代码的习惯，它让我们书写 <code>vue</code> 就像再写普通的 <code>js</code> 一样。</p>\n<p>所以以后的 <code>composition API</code> 将是 <code>script setup</code> 语法的时代，<code>原setup函数</code> 将会逐渐退出历史舞台。</p>\n<p>而我们的项目也将会全部使用最新的 <code>script setup</code> 语法，让大家紧抓时代脉搏！</p>\n<h2 id=\"06：导入-element-plus\"><a href=\"#06：导入-element-plus\" class=\"headerlink\" title=\"06：导入 element-plus\"></a>06：导入 element-plus</h2><p>在开发我们的项目之前，我们需要先去导入 <code>element-ui</code> 的 <code>vue3</code> 支持版本，也就是 <a href=\"http://element-plus.org/#/zh-CN\">element-plus</a></p>\n<p><code>element-plus</code> 提供了快捷导入的方式，即：<a href=\"https://github.com/element-plus/vue-cli-plugin-element-plus\">vue-cli-plugin-element-plus</a>，大家可以通过以下方式来快捷导入 <code>element-plus</code> （注意：此种方式会自动修改 <code>App.vue</code> 文件）：</p>\n<ol>\n<li><p>在通过 <code>vue-cli</code> 创建的项目中，执行 </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vue add element-plus</code></pre>\n</li>\n<li><p>选择全局导入</p>\n<img src=\"/post/vue3.2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/03%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84/image-20210908111515578.png\" class=\"\" title=\"image-20210908111515578\">\n</li>\n<li><p>暂不生成覆盖变量的 <code>scss</code> 文件</p>\n<img src=\"/post/vue3.2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/03%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84/image-20210908111550714.png\" class=\"\" title=\"image-20210908111550714\">\n</li>\n<li><p>选择简体中文即可</p>\n<img src=\"/post/vue3.2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/03%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84/image-20210908111636178.png\" class=\"\" title=\"image-20210908111636178\">\n</li>\n<li><p>出现该提示表示安装完成</p>\n<img src=\"03搭建登录架构/image-20210908111752361.png\" alt=\"image-20210908111752361\" />\n</li>\n<li><p>此时运行项目，则会得到如下错误</p>\n<img src=\"/post/vue3.2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/03%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84/image-20210908111836008.png\" class=\"\" title=\"image-20210908111836008\">\n</li>\n<li><p>出现该错误的原因是因为 <a href=\"https://github.com/element-plus/vue-cli-plugin-element-plus\">vue-cli-plugin-element-plus</a> 默认修改了 <code>APP.vue</code> 文件，导入了 <code>HelloWorld</code></p>\n</li>\n<li><p>所以我们需要到 <code>APP.vue</code> 中，初始化如下代码：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;router-view &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;&lt;&#x2F;style&gt;\n</code></pre></li>\n</ol>\n<p>那么至此，<code>element-plus</code> 导入成功，下一小节我们就正式开始项目的开发工作吧！</p>\n<h2 id=\"07：构建登录页面-UI-结构\"><a href=\"#07：构建登录页面-UI-结构\" class=\"headerlink\" title=\"07：构建登录页面 UI 结构\"></a>07：构建登录页面 UI 结构</h2><ol>\n<li><p>在 <code>views</code> 中 <code>login</code> 文件夹，创建 <code>index.vue</code> 文件</p>\n<img src=\"/post/vue3.2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/03%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84/image-20210908112617459.png\" class=\"\" title=\"image-20210908112617459\">\n</li>\n<li><p>在 <code>router/index.js</code> 中增加以下路由配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 公开路由表\n *&#x2F;\nconst publicRoutes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;login&#39;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;login&#x2F;index&#39;)\n  &#125;\n]\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHashHistory(),\n  routes: publicRoutes\n&#125;)</code></pre>\n</li>\n<li><p>在 <code>login/index.vue</code> 中，生成基本页面结构</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;</code></pre>\n</li>\n<li><p>创建登录页面基本结构</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    &lt;el-form class&#x3D;&quot;login-form&quot; &gt;\n      &lt;div class&#x3D;&quot;title-container&quot;&gt;\n        &lt;h3 class&#x3D;&quot;title&quot;&gt;用户登录&lt;&#x2F;h3&gt;\n      &lt;&#x2F;div&gt;\n\n      &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;\n        &lt;span class&#x3D;&quot;svg-container&quot;&gt;\n          &lt;el-icon&gt;\n            &lt;avatar &#x2F;&gt;\n          &lt;&#x2F;el-icon&gt;\n        &lt;&#x2F;span&gt;\n        &lt;el-input\n          placeholder&#x3D;&quot;username&quot;\n          name&#x3D;&quot;username&quot;\n          type&#x3D;&quot;text&quot;\n        &#x2F;&gt;\n      &lt;&#x2F;el-form-item&gt;\n\n      &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;\n        &lt;span class&#x3D;&quot;svg-container&quot;&gt;\n          &lt;el-icon&gt;\n            &lt;avatar &#x2F;&gt;\n          &lt;&#x2F;el-icon&gt;\n        &lt;&#x2F;span&gt;\n        &lt;el-input\n          placeholder&#x3D;&quot;password&quot;\n          name&#x3D;&quot;password&quot;\n        &#x2F;&gt;\n        &lt;span class&#x3D;&quot;show-pwd&quot;&gt;\n          &lt;el-icon&gt;\n            &lt;avatar &#x2F;&gt;\n          &lt;&#x2F;el-icon&gt;\n        &lt;&#x2F;span&gt;\n      &lt;&#x2F;el-form-item&gt;\n\n      &lt;el-button type&#x3D;&quot;primary&quot; style&#x3D;&quot;width: 100%; margin-bottom: 30px&quot;\n        &gt;登录&lt;&#x2F;el-button\n      &gt;\n    &lt;&#x2F;el-form&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\n&#x2F;&#x2F; 导入组件之后无需注册可直接使用\nimport &#123; Avatar &#125; from &#39;@element-plus&#x2F;icons&#39;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;</code></pre></li>\n</ol>\n<h2 id=\"08：美化登录页面样式\"><a href=\"#08：美化登录页面样式\" class=\"headerlink\" title=\"08：美化登录页面样式\"></a>08：美化登录页面样式</h2><ol>\n<li><p>创建全局的 <code>style</code> </p>\n<ol>\n<li><p>在 <code>src</code> 下创建 <code>styles/index.scss</code> 文件，并写入以下内容：</p>\n<pre class=\"line-numbers language-scss\" data-language=\"scss\"><code class=\"language-scss\">html,\nbody &#123;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB,\n    Microsoft YaHei, Arial, sans-serif;\n&#125;\n\n#app &#123;\n  height: 100%;\n&#125;\n\n*,\n*:before,\n*:after &#123;\n  box-sizing: inherit;\n  margin: 0;\n  padding: 0;\n&#125;\n\na:focus,\na:active &#123;\n  outline: none;\n&#125;\n\na,\na:focus,\na:hover &#123;\n  cursor: pointer;\n  color: inherit;\n  text-decoration: none;\n&#125;\n\ndiv:focus &#123;\n  outline: none;\n&#125;\n\n.clearfix &#123;\n  &amp;:after &#123;\n    visibility: hidden;\n    display: block;\n    font-size: 0;\n    content: &#39; &#39;;\n    clear: both;\n    height: 0;\n  &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>在 <code>main.js</code> 中导入全局样式</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">...\n&#x2F;&#x2F; 导入全局样式\nimport &#39;.&#x2F;styles&#x2F;index.scss&#39;\n...</code></pre>\n\n\n</li>\n<li><p>在 <code>views/login/index.vue</code> 中写入以下样式</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n$bg: #2d3a4b;\n$dark_gray: #889aa4;\n$light_gray: #eee;\n$cursor: #fff;\n\n.login-container &#123;\n  min-height: 100%;\n  width: 100%;\n  background-color: $bg;\n  overflow: hidden;\n\n  .login-form &#123;\n    position: relative;\n    width: 520px;\n    max-width: 100%;\n    padding: 160px 35px 0;\n    margin: 0 auto;\n    overflow: hidden;\n\n    ::v-deep .el-form-item &#123;\n      border: 1px solid rgba(255, 255, 255, 0.1);\n      background: rgba(0, 0, 0, 0.1);\n      border-radius: 5px;\n      color: #454545;\n    &#125;\n\n    ::v-deep .el-input &#123;\n      display: inline-block;\n      height: 47px;\n      width: 85%;\n\n      input &#123;\n        background: transparent;\n        border: 0px;\n        -webkit-appearance: none;\n        border-radius: 0px;\n        padding: 12px 5px 12px 15px;\n        color: $light_gray;\n        height: 47px;\n        caret-color: $cursor;\n      &#125;\n    &#125;\n  &#125;\n\n\n  .svg-container &#123;\n    padding: 6px 5px 6px 15px;\n    color: $dark_gray;\n    vertical-align: middle;\n    display: inline-block;\n  &#125;\n\n  .title-container &#123;\n    position: relative;\n\n    .title &#123;\n      font-size: 26px;\n      color: $light_gray;\n      margin: 0px auto 40px auto;\n      text-align: center;\n      font-weight: bold;\n    &#125;\n  &#125;\n\n  .show-pwd &#123;\n    position: absolute;\n    right: 10px;\n    top: 7px;\n    font-size: 16px;\n    color: $dark_gray;\n    cursor: pointer;\n    user-select: none;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"09：Icon-图标处理方案：SvgIcon\"><a href=\"#09：Icon-图标处理方案：SvgIcon\" class=\"headerlink\" title=\"09：Icon 图标处理方案：SvgIcon\"></a>09：Icon 图标处理方案：SvgIcon</h2><p>在上一小节中我们完成了登陆页面的基本样式 。但是现在在登录页面中，还存在着最后一个样式问题，那就是 <code>icon</code> 图标。</p>\n<p>在我们的项目中所使用的 <code>icon</code> 图标，一共分为两类：</p>\n<ol>\n<li><code>element-plus</code> 的图标</li>\n<li>自定义的 <code>svg</code> 图标</li>\n</ol>\n<p>这也是通常情况下企业级项目开发时，所遇到的一种常见情况。</p>\n<p>对于 <code>element-plus</code> 的图标我们可以直接通过 <code>el-icon</code> 来进行显示，但是自定义图标的话，我们暂时还缺少显示的方式，所以说我们需要一个自定义的组件，来显示我们自定义的 <code>svg</code> 图标。</p>\n<p>那么这种自定义组件处理 <strong>自定义 <code>svg</code> 图标的形式</strong>，就是我们在面临这种问题时的通用解决方案。</p>\n<p>那么对于这个组件的话，它就需要拥有两种能力：</p>\n<ol>\n<li>显示外部 <code>svg</code> 图标</li>\n<li>显示项目内的 <code>svg</code> 图标</li>\n</ol>\n<p>基于以上概念，我们可以创建出以下对应代码：</p>\n<p>创建 <code>components/SvgIcon/index.vue</code>：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div\n    v-if&#x3D;&quot;isExternal&quot;\n    :style&#x3D;&quot;styleExternalIcon&quot;\n    class&#x3D;&quot;svg-external-icon svg-icon&quot;\n    :class&#x3D;&quot;className&quot;\n  &#x2F;&gt;\n  &lt;svg v-else class&#x3D;&quot;svg-icon&quot; :class&#x3D;&quot;className&quot; aria-hidden&#x3D;&quot;true&quot;&gt;\n    &lt;use :xlink:href&#x3D;&quot;iconName&quot; &#x2F;&gt;\n  &lt;&#x2F;svg&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; isExternal as external &#125; from &#39;@&#x2F;utils&#x2F;validate&#39;\nimport &#123; defineProps, computed &#125; from &#39;vue&#39;\nconst props &#x3D; defineProps(&#123;\n  &#x2F;&#x2F; icon 图标\n  icon: &#123;\n    type: String,\n    required: true\n  &#125;,\n  &#x2F;&#x2F; 图标类名\n  className: &#123;\n    type: String,\n    default: &#39;&#39;\n  &#125;\n&#125;)\n\n&#x2F;**\n * 判断是否为外部图标\n *&#x2F;\nconst isExternal &#x3D; computed(() &#x3D;&gt; external(props.icon))\n&#x2F;**\n * 外部图标样式\n *&#x2F;\nconst styleExternalIcon &#x3D; computed(() &#x3D;&gt; (&#123;\n  mask: &#96;url($&#123;props.icon&#125;) no-repeat 50% 50%&#96;,\n  &#39;-webkit-mask&#39;: &#96;url($&#123;props.icon&#125;) no-repeat 50% 50%&#96;\n&#125;))\n&#x2F;**\n * 项目内图标\n *&#x2F;\nconst iconName &#x3D; computed(() &#x3D;&gt; &#96;#icon-$&#123;props.icon&#125;&#96;)\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n.svg-icon &#123;\n  width: 1em;\n  height: 1em;\n  vertical-align: -0.15em;\n  fill: currentColor;\n  overflow: hidden;\n&#125;\n\n.svg-external-icon &#123;\n  background-color: currentColor;\n  mask-size: cover !important;\n  display: inline-block;\n&#125;\n&lt;&#x2F;style&gt;\n</code></pre>\n\n<p>创建 <code>utils/validate.js</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\n&#x2F;**\n * 判断是否为外部资源\n *&#x2F;\nexport function isExternal(path) &#123;\n  return &#x2F;^(https?:|mailto:|tel:)&#x2F;.test(path)\n&#125;\n</code></pre>\n\n<p>在 <code>views/login/index.vue</code> 中使用 <strong>外部 <code>svg</code> （<code>https://res.lgdsunday.club/user.svg</code>）：</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;span class&#x3D;&quot;svg-container&quot;&gt;\n\t&lt;svg-icon icon&#x3D;&quot;https:&#x2F;&#x2F;res.lgdsunday.club&#x2F;user.svg&quot;&gt;&lt;&#x2F;svg-icon&gt;\n&lt;&#x2F;span&gt;</code></pre>\n\n<p>外部图标可正常展示。</p>\n<p>那么在本小节中，我们创建了 <code>SvgIcon</code> 组件，用来处理了 <strong>外部图标</strong> 的展示，但是对于内部图标而言，我们此时依然无法进行展示。所以在下一小节中，我们就需要看一下，如何处理内部的 <code>svg</code> 图标。</p>\n<h2 id=\"10：处理内部-svg-图标显示\"><a href=\"#10：处理内部-svg-图标显示\" class=\"headerlink\" title=\"10：处理内部 svg 图标显示\"></a>10：处理内部 svg 图标显示</h2><p>在上一章中，我们创建了 <code>SvgIcon</code> 组件用于显示 <strong>非 Element-ui</strong> 的图标。但是目前我们只处理了 <strong>外部 <code>svg</code> 的图标展示</strong>，内部的图标还无法展示。</p>\n<p>所以这一小节，我们就需要处理 <strong>内部的 <code>svg</code> 图标展示。</strong></p>\n<ol>\n<li><p>首先导入所有的 <code>svg</code> 图标（大家可以从 源代码 -&gt; <code>src -&gt; icons -&gt; svg</code> 处，获取所有 <code>svg</code> 图标），导入到 <code>src -&gt; icons -&gt; svg</code> 处</p>\n</li>\n<li><p>在 <code>icons</code> 下创建 <code>index.js</code> 文件，该文件中需要完成两件事情：</p>\n<ol>\n<li>导入所有的 <code>svg</code> 图标</li>\n<li>完成 <code>SvgIcon</code> 的全局注册</li>\n</ol>\n</li>\n<li><p>得出以下代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import SvgIcon from &#39;@&#x2F;components&#x2F;SvgIcon&#39;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;webpack.docschina.org&#x2F;guides&#x2F;dependency-management&#x2F;#requirecontext\n&#x2F;&#x2F; 通过 require.context() 函数来创建自己的 context\nconst svgRequire &#x3D; require.context(&#39;.&#x2F;svg&#39;, false, &#x2F;\\.svg$&#x2F;)\n&#x2F;&#x2F; 此时返回一个 require 的函数，可以接受一个 request 的参数，用于 require 的导入。\n&#x2F;&#x2F; 该函数提供了三个属性，可以通过 require.keys() 获取到所有的 svg 图标\n&#x2F;&#x2F; 遍历图标，把图标作为 request 传入到 require 导入函数中，完成本地 svg 图标的导入\nsvgRequire.keys().forEach(svgIcon &#x3D;&gt; svgRequire(svgIcon))\n\nexport default app &#x3D;&gt; &#123;\n  app.component(&#39;svg-icon&#39;, SvgIcon)\n&#125;\n</code></pre>\n</li>\n<li><p>在 <code>main.js</code> 中引入该文件</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">...\n&#x2F;&#x2F; 导入 svgIcon\nimport installIcons from &#39;@&#x2F;icons&#39;\n...\ninstallIcons(app)\n...\n</code></pre>\n</li>\n<li><p>删除 <code>views/login</code> 下 局部导入 <code>SvgIcon</code> 的代码</p>\n</li>\n<li><p>在 <code>login/index.vue</code> 中使用 <code>SvgIcon</code> 引入本地 <code>svg</code></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&#x2F;&#x2F; 用户名   \n   &lt;svg-icon icon&#x3D;&quot;user&quot; &#x2F;&gt;\n   &#x2F;&#x2F; 密码\n   &lt;svg-icon icon&#x3D;&quot;password&quot; &#x2F;&gt;\n   &#x2F;&#x2F; 眼睛\n&lt;svg-icon icon&#x3D;&quot;eye&quot; &#x2F;&gt;</code></pre>\n</li>\n<li><p>此时 <strong>处理内容 <code>svg</code> 图标的代码</strong> 已经完成</p>\n</li>\n</ol>\n<p>打开浏览器，我们发现 <strong>图标依然无法展示！</strong> 这又是因为什么原因呢？</p>\n<p>来看下一节 《使用 svg-sprite-loader 处理 svg 图标》</p>\n<h2 id=\"11：使用-svg-sprite-loader-处理-svg-图标\"><a href=\"#11：使用-svg-sprite-loader-处理-svg-图标\" class=\"headerlink\" title=\"11：使用 svg-sprite-loader 处理 svg 图标\"></a>11：使用 svg-sprite-loader 处理 svg 图标</h2><p><a href=\"https://www.npmjs.com/package/svg-sprite-loader\">svg-sprite-loader</a> 是 <code>webpack</code> 中专门用来处理 <code>svg</code> 图标的一个 <code>loader</code> ，在上一节中我们的图标之所有没有展示，就是因为我们缺少该 <code>loader</code>。</p>\n<p>那么想要使用该 <code>loader</code> 我们需要做两件事情：</p>\n<ol>\n<li><p>下载该 <code>laoder</code>，执行：<code>npm i --save-dev svg-sprite-loader@6.0.9</code></p>\n</li>\n<li><p>创建 <code>vue.config.js</code> 文件，新增如下配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&#39;path&#39;)\nfunction resolve(dir) &#123;\n  return path.join(__dirname, dir)\n&#125;\n&#x2F;&#x2F; https:&#x2F;&#x2F;cli.vuejs.org&#x2F;zh&#x2F;guide&#x2F;webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F\nmodule.exports &#x3D; &#123;\n  chainWebpack(config) &#123;\n    &#x2F;&#x2F; 设置 svg-sprite-loader\n    config.module\n      .rule(&#39;svg&#39;)\n      .exclude.add(resolve(&#39;src&#x2F;icons&#39;))\n      .end()\n    config.module\n      .rule(&#39;icons&#39;)\n      .test(&#x2F;\\.svg$&#x2F;)\n      .include.add(resolve(&#39;src&#x2F;icons&#39;))\n      .end()\n      .use(&#39;svg-sprite-loader&#39;)\n      .loader(&#39;svg-sprite-loader&#39;)\n      .options(&#123;\n        symbolId: &#39;icon-[name]&#39;\n      &#125;)\n      .end()\n  &#125;\n&#125;\n</code></pre></li>\n</ol>\n<p>处理完以上配置之后，重新启动项目，图标即可显示！</p>\n<h2 id=\"12：Vue3-2-响应式优化对应用层的改变\"><a href=\"#12：Vue3-2-响应式优化对应用层的改变\" class=\"headerlink\" title=\"12：Vue3.2 响应式优化对应用层的改变\"></a>12：Vue3.2 响应式优化对应用层的改变</h2><p>在处理好了 <code>SvgIcon</code> 图标之后，接下来我们就需要处理登陆页面的逻辑问题了。不过在处理这个逻辑之前，我们需要先来明确一点 <code>vue3</code> 新的更新内容。</p>\n<p>如果大家之前有过了解 <code>Vue3</code> 代码的话，那么会知道 <code>Vue3</code> 中声明响应式数据的方式有两种：</p>\n<ol>\n<li><a href=\"https://v3.cn.vuejs.org/api/refs-api.html#ref\">ref</a></li>\n<li><a href=\"https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive\">reactive</a></li>\n</ol>\n<p>对于这两种使用方式而言，它们在应用层上并没有明确的界限，也就是说我们可能很难仅通过官网的介绍来判断我应该在什么情况下使用什么。</p>\n<p>但是这种情况在现在已经不存在了。</p>\n<p>2020年10月29日，社区大佬 <a href=\"https://github.com/basvanmeurs\">basvanmeurs</a> 提出了一个新的 <a href=\"https://github.com/vuejs/vue-next/pull/2345\">PR</a>，大概的意思是说：他重构了响应式的部分内容，大大增加了性能。</p>\n<p>详细的介绍如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>Big runtime performance improvement for ref, computed, watch and watchEffect (30%-80% depending on the amount of dependencies)</li>\n<li>Memory usage decreased by about 30% when creating ref, computed, watch and watchEffect</li>\n<li>Creation time performance improvement, most notably for watchers and watchEffects</li>\n</ul>\n<hr>\n<p>ref、calculated、watch 和 watchEffect 的运行时性能大幅提升（30%-80% 取决于依赖项的数量）<br>创建 ref、calculated、watch 和 watchEffect 时内存使用量减少了约 30%<br>创建时间性能改进，最显著的是 watchers 和 watchEffects</p></blockquote>\n<p>这是一个非常强大的变化，同时又因为这个变化过于庞大，所以一直等待到 <code>2021年8月5日</code> 伴随着  <a href=\"https://blog.vuejs.org/posts/vue-3.2.html\">vue 3.2发布</a>，尤大才合并对应的代码，并在这次变化中对该性能改进进行了如下的介绍：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li><a href=\"https://github.com/vuejs/vue-next/pull/3995\">More efficient ref implementation (~260% faster read &#x2F; ~50% faster write)</a></li>\n<li><a href=\"https://github.com/vuejs/vue-next/pull/4017\">~40% faster dependency tracking</a></li>\n<li><a href=\"https://github.com/vuejs/vue-next/pull/4001\">~17% less memory usage</a></li>\n</ul>\n<hr>\n<p>更高效的 ref 实现（约 260% 的读取速度&#x2F;约 50% 的写入速度）<br>依赖项跟踪速度提高约 40%<br>内存使用量减少约 17%</p></blockquote>\n<p>毫无疑问，这绝对是一个伟大的变化。</p>\n<p>那么针对于这个变化，在应用层中最大的体现就是 <code>ref</code> 这个 <code>API</code> ，性能得到了大幅度的提升。</p>\n<p>所以说，拥抱新的变化吧！</p>\n<p>在之后能使用 <code>ref</code> 的地方就使用 <code>ref</code> 吧。毕竟现在它的性能得到了大幅的提升！</p>\n<p>那么在咱们之后的代码中，我们同样也会全部使用 <code>ref</code> 来作为响应式数据构建的方式，无论是 <strong>基本数据类型</strong> 或者是 <strong>复杂数据类型</strong>， 毕竟这样做本身并没有什么问题，对不对？</p>\n<h2 id=\"13：完善登录表单校验\"><a href=\"#13：完善登录表单校验\" class=\"headerlink\" title=\"13：完善登录表单校验\"></a>13：完善登录表单校验</h2><p>表单校验是表单使用的一个通用能力，在 <code>element-plus</code> 中想要为表单进行表单校验那么我们需要关注以下三点：</p>\n<ol>\n<li>为 <code>el-form</code> 绑定 <code>model</code> 属性</li>\n<li>为 <code>el-form</code> 绑定 <code>rules</code> 属性</li>\n<li>为 <code>el-form-item</code> 绑定 <code>prop</code> 属性</li>\n</ol>\n<p>保证以上三点即可为 <code>el-from</code> 添加表单校验功能。</p>\n<p>因为这一块是比较简单的功能，只要有过 <code>element-ui</code> 使用经验的人，应该对这里都不陌生，所以这里就不对这块内容进行过多赘述了。对这里不是很了解的人可以参考下 <a href=\"https://element-plus.org/#/zh-CN/component/form\">element-plus 中 from 表单部分</a></p>\n<p>以下为对应的代码实现：</p>\n<p><strong>views&#x2F;login</strong></p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    &lt;el-form class&#x3D;&quot;login-form&quot; :model&#x3D;&quot;loginForm&quot; :rules&#x3D;&quot;loginRules&quot;&gt;\n      ...\n      &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;\n        ...\n        &lt;el-input\n         ...\n          v-model&#x3D;&quot;loginForm.username&quot;\n        &#x2F;&gt;\n      &lt;&#x2F;el-form-item&gt;\n\n      &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;\n        ...\n        &lt;el-input\n          ...\n          v-model&#x3D;&quot;loginForm.password&quot;\n        &#x2F;&gt;\n        ...\n      &lt;&#x2F;el-form-item&gt;\n\t\t...\n    &lt;&#x2F;el-form&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nimport &#123; validatePassword &#125; from &#39;.&#x2F;rules&#39;\n\n&#x2F;&#x2F; 数据源\nconst loginForm &#x3D; ref(&#123;\n  username: &#39;super-admin&#39;,\n  password: &#39;123456&#39;\n&#125;)\n&#x2F;&#x2F; 验证规则\nconst loginRules &#x3D; ref(&#123;\n  username: [\n    &#123;\n      required: true,\n      trigger: &#39;blur&#39;,\n      message: &#39;用户名为必填项&#39;\n    &#125;\n  ],\n  password: [\n    &#123;\n      required: true,\n      trigger: &#39;blur&#39;,\n      validator: validatePassword()\n    &#125;\n  ]\n&#125;)\n&lt;&#x2F;script&gt;\n</code></pre>\n\n<p><strong>views&#x2F;login&#x2F;rules.js</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">export const validatePassword &#x3D; () &#x3D;&gt; &#123;\n  return (rule, value, callback) &#x3D;&gt; &#123;\n    if (value.length &lt; 6) &#123;\n      callback(new Error(&#39;密码不能少于6位&#39;))\n    &#125; else &#123;\n      callback()\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"14：密码框状态通用处理\"><a href=\"#14：密码框状态通用处理\" class=\"headerlink\" title=\"14：密码框状态通用处理\"></a>14：密码框状态通用处理</h2><p>对于密码框存在两种状态：</p>\n<ol>\n<li>密文状态</li>\n<li>明文状态</li>\n</ol>\n<p>点击 <strong>眼睛</strong> 可以进行切换。</p>\n<p>该功能实现为通用的处理方案，只需要动态修改 <code>input</code> 的 <code>type</code> 类型即可，其中：</p>\n<ol>\n<li><code>password</code> 为密文显示</li>\n<li><code>text</code> 为明文显示</li>\n</ol>\n<p>根据以上理论，即可得出以下代码：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    &lt;el-form class&#x3D;&quot;login-form&quot; :model&#x3D;&quot;loginForm&quot; :rules&#x3D;&quot;loginRules&quot;&gt;\n      ...\n        &lt;el-input\n          ...\n          :type&#x3D;&quot;passwordType&quot;\n        &#x2F;&gt;\n        &lt;span class&#x3D;&quot;show-pwd&quot;&gt;\n          &lt;svg-icon\n            :icon&#x3D;&quot;passwordType &#x3D;&#x3D;&#x3D; &#39;password&#39; ? &#39;eye&#39; : &#39;eye-open&#39;&quot;\n            @click&#x3D;&quot;onChangePwdType&quot;\n          &#x2F;&gt;\n        &lt;&#x2F;span&gt;\n      ...\n    &lt;&#x2F;el-form&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\n...\n\n&#x2F;&#x2F; 处理密码框文本显示状态\nconst passwordType &#x3D; ref(&#39;password&#39;)\nconst onChangePwdType &#x3D; () &#x3D;&gt; &#123;\n  if (passwordType.value &#x3D;&#x3D;&#x3D; &#39;password&#39;) &#123;\n    passwordType.value &#x3D; &#39;text&#39;\n  &#125; else &#123;\n    passwordType.value &#x3D; &#39;password&#39;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n</code></pre>\n\n<h2 id=\"15：通用后台登录方案解析\"><a href=\"#15：通用后台登录方案解析\" class=\"headerlink\" title=\"15：通用后台登录方案解析\"></a>15：通用后台登录方案解析</h2><p>处理完了表单的基本操作之后，接下来就是登录操作的实现了。</p>\n<p>对于登录操作在后台项目中是一个通用的解决方案，具体可以分为以下几点：</p>\n<ol>\n<li>封装 <code>axios</code> 模块</li>\n<li>封装 接口请求 模块</li>\n<li>封装登录请求动作</li>\n<li>保存服务端返回的 <code>token</code></li>\n<li>登录鉴权</li>\n</ol>\n<p>这些内容就共同的组成了一套 <strong>后台登录解决方案</strong> 。那么在后面的章节中，我们就分别来去处理这些内容。</p>\n<h2 id=\"16：配置环境变量封装-axios-模块\"><a href=\"#16：配置环境变量封装-axios-模块\" class=\"headerlink\" title=\"16：配置环境变量封装 axios 模块\"></a>16：配置环境变量封装 axios 模块</h2><p>首先我们先去完成第一步：封装 <code>axios</code> 模块。</p>\n<p>在当前这个场景下，我们希望封装出来的 <code>axios</code> 模块，至少需要具备一种能力，那就是：<strong>根据当前模式的不同，设定不同的 <code>BaseUrl</code></strong> ，因为通常情况下企业级项目在 <strong>开发状态</strong> 和 <strong>生产状态</strong> 下它的 <code>baseUrl</code> 是不同的。</p>\n<p>对于 <code>@vue/cli</code> 来说，它具备三种不同的模式：</p>\n<ol>\n<li><code>development</code></li>\n<li><code>test</code></li>\n<li><code>production</code></li>\n</ol>\n<p>具体可以点击 <a href=\"https://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F\">这里</a> 进行参考。</p>\n<p>根据我们前面所提到的 <strong>开发状态和生产状态</strong> 那么此时我们的 <code>axios</code> 必须要满足：<strong>在 开发 || 生产 状态下，可以设定不同 <code>BaseUrl</code> 的能力</strong></p>\n<p>那么想要解决这个问题，就必须要使用到 <code>@vue/cli</code> 所提供的 <a href=\"https://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F\">环境变量</a> 来去进行实现。</p>\n<p>我们可以在项目中创建两个文件：</p>\n<ol>\n<li><code>.env.development</code></li>\n<li><code>.env.production</code></li>\n</ol>\n<p>它们分别对应 <strong>开发状态</strong> 和 <strong>生产状态</strong>。</p>\n<p>我们可以在上面两个文件中分别写入以下代码：</p>\n<p>**<code>.env.development</code>**：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 标志\nENV &#x3D; &#39;development&#39;\n\n# base api\nVUE_APP_BASE_API &#x3D; &#39;&#x2F;api&#39;</code></pre>\n\n<p><strong><code>.env.production</code>：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 标志\nENV &#x3D; &#39;production&#39;\n\n# base api\nVUE_APP_BASE_API &#x3D; &#39;&#x2F;prod-api&#39;</code></pre>\n\n<p>有了这两个文件之后，我们就可以创建对应的 <code>axios</code> 模块</p>\n<p>创建 <code>utils/request.js</code> ，写入如下代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import axios from &#39;axios&#39;\n\nconst service &#x3D; axios.create(&#123;\n  baseURL: process.env.VUE_APP_BASE_API,\n  timeout: 5000\n&#125;)\n\nexport default service</code></pre>\n\n<h2 id=\"17：封装请求动作\"><a href=\"#17：封装请求动作\" class=\"headerlink\" title=\"17：封装请求动作\"></a>17：封装请求动作</h2><p>有了 <code>axios</code> 模块之后，接下来我们就可以</p>\n<ol>\n<li>封装接口请求模块</li>\n<li>封装登录请求动作</li>\n</ol>\n<p><strong>封装接口请求模块：</strong></p>\n<p>创建 <code>api</code> 文件夹，创建 <code>sys.js</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import request from &#39;@&#x2F;utils&#x2F;request&#39;\n\n&#x2F;**\n * 登录\n *&#x2F;\nexport const login &#x3D; data &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;sys&#x2F;login&#39;,\n    method: &#39;POST&#39;,\n    data\n  &#125;)\n&#125;</code></pre>\n\n<p><strong>封装登录请求动作：</strong></p>\n<p>该动作我们期望把它封装到 <code>vuex</code> 的 <code>action</code> 中</p>\n<p>在 <code>store</code> 下创建 <code>modules</code> 文件夹，创建 <code>user.js</code> 模块，用于处理所有和 <strong>用户相关</strong> 的内容（此处需要使用第三方包 <code>md5</code> ）：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; login &#125; from &#39;@&#x2F;api&#x2F;sys&#39;\nimport md5 from &#39;md5&#39;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;&#125;),\n  mutations: &#123;&#125;,\n  actions: &#123;\n    login(context, userInfo) &#123;\n      const &#123; username, password &#125; &#x3D; userInfo\n      return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        login(&#123;\n          username,\n          password: md5(password)\n        &#125;)\n          .then(data &#x3D;&gt; &#123;\n            resolve()\n          &#125;)\n          .catch(err &#x3D;&gt; &#123;\n            reject(err)\n          &#125;)\n      &#125;)\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p>在 <code>store/index</code> 中完成注册：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createStore &#125; from &#39;vuex&#39;\nimport user from &#39;.&#x2F;modules&#x2F;user.js&#39;\nexport default createStore(&#123;\n  modules: &#123;\n    user\n  &#125;\n&#125;)</code></pre>\n\n\n\n<h2 id=\"18：登录触发动作\"><a href=\"#18：登录触发动作\" class=\"headerlink\" title=\"18：登录触发动作\"></a>18：登录触发动作</h2><p>在 <code>login</code> 中，触发定义的 <code>action</code></p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n\t&lt;el-button\n        type&#x3D;&quot;primary&quot;\n        style&#x3D;&quot;width: 100%; margin-bottom: 30px&quot;\n        :loading&#x3D;&quot;loading&quot;\n        @click&#x3D;&quot;handleLogin&quot;\n        &gt;登录&lt;&#x2F;el-button\n      &gt;\n&lt;&#x2F;template&gt;\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nimport &#123; validatePassword &#125; from &#39;.&#x2F;rules&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\n...\n\n&#x2F;&#x2F; 登录动作处理\nconst loading &#x3D; ref(false)\nconst loginFromRef &#x3D; ref(null)\nconst store &#x3D; useStore()\nconst handleLogin &#x3D; () &#x3D;&gt; &#123;\n  loginFromRef.value.validate(valid &#x3D;&gt; &#123;\n    if (!valid) return\n\n    loading.value &#x3D; true\n    store\n      .dispatch(&#39;user&#x2F;login&#39;, loginForm.value)\n      .then(() &#x3D;&gt; &#123;\n        loading.value &#x3D; false\n        &#x2F;&#x2F; TODO: 登录后操作\n      &#125;)\n      .catch(err &#x3D;&gt; &#123;\n        console.log(err)\n        loading.value &#x3D; false\n      &#125;)\n  &#125;)\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>触发之后会得到以下错误：</p>\n<img src=\"/post/vue3.2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/03%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84/image-20210910172203852.png\" class=\"\" title=\"image-20210910172203852\">\n\n<p>该错误表示，我们当前请求的接口不存在。</p>\n<p>出现这个问题的原因，是因为我们在前面配置环境变量时指定了 <strong>开发环境下</strong>，请求的 <code>BaseUrl</code> 为 <code>/api</code> ，所以我们真实发出的请求为：<code>/api/sys/login</code> 。</p>\n<p>这样的一个请求会被自动键入到当前前端所在的服务中，所以我们最终就得到了 <code>http://192.168.18.42:8081/api/sys/login</code> 这样的一个请求路径。</p>\n<p>而想要处理这个问题，那么可以通过指定 <a href=\"https://webpack.docschina.org/configuration/dev-server/\">webpack DevServer 代理</a> 的形式，代理当前的 <code>url</code> 请求。</p>\n<p>而指定这个代理非常简单，是一种近乎固定的配置方案。</p>\n<p>在 <code>vue.config.js</code> 中，加入以下代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  devServer: &#123;\n    &#x2F;&#x2F; 配置反向代理\n    proxy: &#123;\n      &#x2F;&#x2F; 当地址中有&#x2F;api的时候会触发代理机制\n      &#39;&#x2F;api&#39;: &#123;\n        &#x2F;&#x2F; 要代理的服务器地址  这里不用写 api\n        target: &#39;https:&#x2F;&#x2F;api.imooc-admin.lgdsunday.club&#x2F;&#39;,\n        changeOrigin: true &#x2F;&#x2F; 是否跨域\n      &#125;\n    &#125;\n  &#125;,\n  ...\n&#125;\n</code></pre>\n\n<p>重新启动服务，再次进行请求，即可得到返回数据</p>\n<img src=\"03搭建登录架构/image-20210910172808352.png\" alt=\"image-20210910172808352\" style=\"zoom:50%;\" />\n\n<img src=\"03搭建登录架构/image-20210910172827207.png\" alt=\"image-20210910172827207\" style=\"zoom:50%;\" />\n\n<h2 id=\"19：本地缓存处理方案\"><a href=\"#19：本地缓存处理方案\" class=\"headerlink\" title=\"19：本地缓存处理方案\"></a>19：本地缓存处理方案</h2><p>通常情况下，在获取到 <code>token</code> 之后，我们会把 <code>token</code> 进行缓存，而缓存的方式将会分为两种：</p>\n<ol>\n<li>本地缓存：<code>LocalStorage</code> </li>\n<li>全局状态管理：<code>Vuex</code></li>\n</ol>\n<p>保存在 <code>LocalStorage</code> 是为了方便实现 <strong>自动登录功能</strong></p>\n<p>保存在 <code>vuex</code> 中是为了后面在其他位置进行使用</p>\n<p>那么下面我们就分别来实现对应的缓存方案：</p>\n<p><strong>LocalStorage：</strong></p>\n<ol>\n<li><p>创建 <code>utils/storage.js</code> 文件，封装三个对应方法：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 存储数据\n *&#x2F;\nexport const setItem &#x3D; (key, value) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 将数组、对象类型的数据转化为 JSON 字符串进行存储\n  if (typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n    value &#x3D; JSON.stringify(value)\n  &#125;\n  window.localStorage.setItem(key, value)\n&#125;\n\n&#x2F;**\n * 获取数据\n *&#x2F;\nexport const getItem &#x3D; key &#x3D;&gt; &#123;\n  const data &#x3D; window.localStorage.getItem(key)\n  try &#123;\n    return JSON.parse(data)\n  &#125; catch (err) &#123;\n    return data\n  &#125;\n&#125;\n\n&#x2F;**\n * 删除数据\n *&#x2F;\nexport const removeItem &#x3D; key &#x3D;&gt; &#123;\n  window.localStorage.removeItem(key)\n&#125;\n\n&#x2F;**\n * 删除所有数据\n *&#x2F;\nexport const removeAllItem &#x3D; key &#x3D;&gt; &#123;\n  window.localStorage.clear()\n&#125;</code></pre>\n</li>\n<li><p>在 <code>vuex</code> 的 <code>user</code> 模块下，处理 <code>token</code> 的保存</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; login &#125; from &#39;@&#x2F;api&#x2F;sys&#39;\nimport md5 from &#39;md5&#39;\nimport &#123; setItem, getItem &#125; from &#39;@&#x2F;utils&#x2F;storage&#39;\nimport &#123; TOKEN &#125; from &#39;@&#x2F;constant&#39;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;\n    token: getItem(TOKEN) || &#39;&#39;\n  &#125;),\n  mutations: &#123;\n    setToken(state, token) &#123;\n      state.token &#x3D; token\n      setItem(TOKEN, token)\n    &#125;\n  &#125;,\n  actions: &#123;\n    login(context, userInfo) &#123;\n      ...\n          .then(data &#x3D;&gt; &#123;\n            this.commit(&#39;user&#x2F;setToken&#39;, data.data.data.token)\n            resolve()\n          &#125;)\n          ...\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>处理保存的过程中，需要创建 <code>constant</code> 常量目录 <code>constant/index.js</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">export const TOKEN &#x3D; &#39;token&#39;</code></pre></li>\n</ol>\n<p>此时，当点击登陆时，即可把 <code>token</code> 保存至 <code>vuex</code> 与  <code>localStorage</code> 中</p>\n<h2 id=\"20：响应数据的统一处理\"><a href=\"#20：响应数据的统一处理\" class=\"headerlink\" title=\"20：响应数据的统一处理\"></a>20：响应数据的统一处理</h2><p>在上一小节中，我们保存了服务端返回的 <code>token</code> 。但是有一个地方比较难受，那就是在 <code>vuex 的 user 模块</code> 中，我们获取数据端的 <code>token</code> 数据，通过 <code>data.data.data.token</code> 的形式进行获取。</p>\n<p>一路的 <code>data.</code> 确实让人比较难受，如果有过 <code>axios</code> 拦截器处理经验的人应该知道，对于这种问题，我们可以通过 <a href=\"http://axios-js.com/zh-cn/docs/index.html#%E6%8B%A6%E6%88%AA%E5%99%A8\">axios 响应拦截器</a> 进行处理。</p>\n<p>在 <code>utils/request.js</code> 中实现以下代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import axios from &#39;axios&#39;\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\n\n...\n&#x2F;&#x2F; 响应拦截器\nservice.interceptors.response.use(\n  response &#x3D;&gt; &#123;\n    const &#123; success, message, data &#125; &#x3D; response.data\n    &#x2F;&#x2F;   要根据success的成功与否决定下面的操作\n    if (success) &#123;\n      return data\n    &#125; else &#123;\n      &#x2F;&#x2F; 业务错误\n      ElMessage.error(message) &#x2F;&#x2F; 提示错误消息\n      return Promise.reject(new Error(message))\n    &#125;\n  &#125;,\n  error &#x3D;&gt; &#123;\n    &#x2F;&#x2F; TODO: 将来处理 token 超时问题\n    ElMessage.error(error.message) &#x2F;&#x2F; 提示错误信息\n    return Promise.reject(error)\n  &#125;\n)\n\nexport default service\n</code></pre>\n\n<p>此时，对于 <code>vuex 中的 user 模块</code> 就可以进行以下修改了：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">this.commit(&#39;user&#x2F;setToken&#39;, data.token)</code></pre>\n\n<h2 id=\"21：登录后操作\"><a href=\"#21：登录后操作\" class=\"headerlink\" title=\"21：登录后操作\"></a>21：登录后操作</h2><p>那么截止到此时，我们距离登录操作还差最后一个功能就是 <strong>登录鉴权</strong> 。</p>\n<p>只不过在进行 <strong>登录鉴权</strong> 之前我们得先去创建一个登录后的页面，也就是我们所说的登录后操作。</p>\n<ol>\n<li><p>创建 <code>layout/index.vue</code> ，写入以下代码：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;Layout 页面&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;\n</code></pre>\n</li>\n<li><p>在 <code>router/index</code> 中，指定对应路由表：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const publicRoutes &#x3D; [\n ...\n  &#123;\n    path: &#39;&#x2F;&#39;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;layout&#x2F;index&#39;)\n  &#125;\n]</code></pre>\n</li>\n<li><p>在登录成功后，完成跳转</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 登录后操作\nrouter.push(&#39;&#x2F;&#39;)</code></pre></li>\n</ol>\n<h2 id=\"22：登录鉴权解决方案\"><a href=\"#22：登录鉴权解决方案\" class=\"headerlink\" title=\"22：登录鉴权解决方案\"></a>22：登录鉴权解决方案</h2><p>在处理了登陆后操作之后，接下来我们就来看一下最后的一个功能，也就是 <strong>登录鉴权</strong></p>\n<p>首先我们先去对 <strong>登录鉴权</strong> 进行一个定义，什么是  <strong>登录鉴权</strong> 呢？</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当用户未登陆时，不允许进入除 <code>login</code> 之外的其他页面。</p>\n<p>用户登录后，<code>token</code> 未过期之前，不允许进入 <code>login</code> 页面</p></blockquote>\n<p>而想要实现这个功能，那么最好的方式就是通过 <a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB\">路由守卫</a> 来进行实现。</p>\n<p>那么明确好了 <strong>登录鉴权</strong> 的概念之后，接下来就可以去实现一下</p>\n<p>在 <code>main.js</code> 平级，创建 <code>permission</code> 文件</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import router from &#39;.&#x2F;router&#39;\nimport store from &#39;.&#x2F;store&#39;\n\n&#x2F;&#x2F; 白名单\nconst whiteList &#x3D; [&#39;&#x2F;login&#39;]\n&#x2F;**\n * 路由前置守卫\n *&#x2F;\nrouter.beforeEach(async (to, from, next) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 存在 token ，进入主页\n  &#x2F;&#x2F; if (store.state.user.token) &#123;\n  &#x2F;&#x2F; 快捷访问\n  if (store.getters.token) &#123;\n    if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n      next(&#39;&#x2F;&#39;)\n    &#125; else &#123;\n      next()\n    &#125;\n  &#125; else &#123;\n    &#x2F;&#x2F; 没有token的情况下，可以进入白名单\n    if (whiteList.indexOf(to.path) &gt; -1) &#123;\n      next()\n    &#125; else &#123;\n      next(&#39;&#x2F;login&#39;)\n    &#125;\n  &#125;\n&#125;)\n</code></pre>\n\n<p>在此处我们使用到了 <code>vuex 中的 getters</code> ，此时的 <code>getters</code> 被当作 <strong>快捷访问</strong> 的形式进行访问</p>\n<p>所以我们需要声明对应的模块，创建 <code>store/getters</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const getters &#x3D; &#123;\n  token: state &#x3D;&gt; state.user.token\n&#125;\nexport default getters\n</code></pre>\n\n<p>在 <code>store/index</code> 中进行导入：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import getters from &#39;.&#x2F;getters&#39;\nexport default createStore(&#123;\n  getters,\n  ...\n&#125;)\n</code></pre>\n\n<h2 id=\"23：总结\"><a href=\"#23：总结\" class=\"headerlink\" title=\"23：总结\"></a>23：总结</h2><p>那么到这里我们整个的第三章就算是全部讲解完成了。</p>\n<p>整个第三章讲解了两个大部分：</p>\n<ol>\n<li><code>vue3</code> 的一些基本概念<ol>\n<li><code>vue3</code> 的新特性</li>\n<li>全新的 <code>script setup</code> 语法</li>\n<li>最新的 <code>ref</code> 优化</li>\n</ol>\n</li>\n<li>登录方案相关的业务代码<ol>\n<li><code>element-plus</code> 相关<ol>\n<li><code>el-form</code> 表单</li>\n<li>密码框状态处理</li>\n</ol>\n</li>\n<li>后台登录解决方案<ol>\n<li>封装 <code>axios</code> 模块</li>\n<li>封装 接口请求 模块</li>\n<li>封装登录请求动作</li>\n<li>保存服务端返回的 <code>token</code></li>\n<li>登录鉴权</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>那么从下一章开始，我们就会进入到项目内部业务的处理过程。在项目内部的业务处理中，我们又会遇到什么样的业务需求，以及提出什么样的对应解决方案呢？</p>\n<p>敬请期待吧！</p>\n","text":"03搭建登录架构01：前言在上一章中，我们处理了基本的编码规范，那么接下来我们就可以实现对应的项目开发了。 那么在之后的项目开发中，我们将会使用最新的 vue3 script setup 语法。 所以说在本章节中我们需要做两件事情： vue3 最新特性及最新语法 登录功能开发 不...","link":"","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"vue3.2后台管理系统","slug":"vue3-2后台管理系统","count":12,"path":"api/categories/vue3-2后台管理系统.json"}],"tags":[{"name":"后台","slug":"后台","count":12,"path":"api/tags/后台.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#03%E6%90%AD%E5%BB%BA%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">03搭建登录架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#01%EF%BC%9A%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">01：前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#02%EF%BC%9Avue3-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">02：vue3 项目结构解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#03%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">03：初始化项目结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#04%EF%BC%9Avue3-%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">04：vue3 新特性介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Composition-API%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F-API\"><span class=\"toc-text\">Composition API：组合式 API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E4%BA%86-Proxy-%E4%BB%A3%E6%9B%BF-Object-defineProperty-%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F\"><span class=\"toc-text\">使用了 Proxy 代替 Object.defineProperty() 实现响应式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E6%96%B0%E7%9A%84%E5%85%A8%E5%AE%B6%E6%A1%B6\"><span class=\"toc-text\">全新的全家桶</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E6%96%B0%E7%9A%84-TS-%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">全新的 TS 支持</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vite\"><span class=\"toc-text\">vite</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#05%EF%BC%9A%E5%85%A8%E6%96%B0%E7%9A%84%E6%8F%90%E6%A1%88%E8%AF%AD%E6%B3%95%EF%BC%9Ascript-setup\"><span class=\"toc-text\">05：全新的提案语法：script setup</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#06%EF%BC%9A%E5%AF%BC%E5%85%A5-element-plus\"><span class=\"toc-text\">06：导入 element-plus</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#07%EF%BC%9A%E6%9E%84%E5%BB%BA%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2-UI-%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">07：构建登录页面 UI 结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#08%EF%BC%9A%E7%BE%8E%E5%8C%96%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F\"><span class=\"toc-text\">08：美化登录页面样式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#09%EF%BC%9AIcon-%E5%9B%BE%E6%A0%87%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%9ASvgIcon\"><span class=\"toc-text\">09：Icon 图标处理方案：SvgIcon</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10%EF%BC%9A%E5%A4%84%E7%90%86%E5%86%85%E9%83%A8-svg-%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA\"><span class=\"toc-text\">10：处理内部 svg 图标显示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11%EF%BC%9A%E4%BD%BF%E7%94%A8-svg-sprite-loader-%E5%A4%84%E7%90%86-svg-%E5%9B%BE%E6%A0%87\"><span class=\"toc-text\">11：使用 svg-sprite-loader 处理 svg 图标</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12%EF%BC%9AVue3-2-%E5%93%8D%E5%BA%94%E5%BC%8F%E4%BC%98%E5%8C%96%E5%AF%B9%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E6%94%B9%E5%8F%98\"><span class=\"toc-text\">12：Vue3.2 响应式优化对应用层的改变</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13%EF%BC%9A%E5%AE%8C%E5%96%84%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C\"><span class=\"toc-text\">13：完善登录表单校验</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14%EF%BC%9A%E5%AF%86%E7%A0%81%E6%A1%86%E7%8A%B6%E6%80%81%E9%80%9A%E7%94%A8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">14：密码框状态通用处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15%EF%BC%9A%E9%80%9A%E7%94%A8%E5%90%8E%E5%8F%B0%E7%99%BB%E5%BD%95%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">15：通用后台登录方案解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16%EF%BC%9A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%B0%81%E8%A3%85-axios-%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">16：配置环境变量封装 axios 模块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17%EF%BC%9A%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82%E5%8A%A8%E4%BD%9C\"><span class=\"toc-text\">17：封装请求动作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18%EF%BC%9A%E7%99%BB%E5%BD%95%E8%A7%A6%E5%8F%91%E5%8A%A8%E4%BD%9C\"><span class=\"toc-text\">18：登录触发动作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19%EF%BC%9A%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">19：本地缓存处理方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20%EF%BC%9A%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86\"><span class=\"toc-text\">20：响应数据的统一处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21%EF%BC%9A%E7%99%BB%E5%BD%95%E5%90%8E%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">21：登录后操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#22%EF%BC%9A%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">22：登录鉴权解决方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#23%EF%BC%9A%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">23：总结</span></a></li></ol></li></ol>","author":{"name":"西非","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个跑路的设计师","socials":{"github":"https://github.com/xuhui-web","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/a18482157085","juejin":"https://juejin.cn/user/1535369026995422","customs":{}}},"mapped":true,"prev_post":{"title":"04搭建Layout架构","uid":"ded06061bffb24de88f886e4a5616cce","slug":"vue3.2后台管理系统/04搭建Layout架构","date":"2022-08-22T14:02:44.000Z","updated":"2022-08-23T02:17:03.252Z","comments":true,"path":"api/articles/vue3.2后台管理系统/04搭建Layout架构.json","keywords":null,"cover":"/img/photo-1545659681-6b0aba989615.jpg","text":"第四章：搭建Layout架构4-01：前言在上一章中我们处理完成登录之后，从这一章开始，我们就需要处理项目的 Layout 架构了。那么什么叫做 Layout 架构呢？ 我们来看这张图： 在这张图中，我们把页面分为了三个部分，分别是： 左侧的 Menu 菜单 顶部的 NavBar...","link":"","photos":[],"count_time":{"symbolsCount":"55k","symbolsTime":"50 mins."},"categories":[{"name":"vue3.2后台管理系统","slug":"vue3-2后台管理系统","count":12,"path":"api/categories/vue3-2后台管理系统.json"}],"tags":[{"name":"后台","slug":"后台","count":12,"path":"api/tags/后台.json"}],"author":{"name":"西非","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个跑路的设计师","socials":{"github":"https://github.com/xuhui-web","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/a18482157085","juejin":"https://juejin.cn/user/1535369026995422","customs":{}}}},"next_post":{"title":"02ESLint + Git Hooks","uid":"5b3c8e28480b900c4a5086ace466bf73","slug":"vue3.2后台管理系统/02ESLint + Git Hooks","date":"2022-08-22T12:02:44.000Z","updated":"2022-08-23T02:01:49.106Z","comments":true,"path":"api/articles/vue3.2后台管理系统/02ESLint + Git Hooks.json","keywords":null,"cover":"/img/photo-1574092403000-ef9c803b84bb.jpg","text":"02ESLint + Git Hooks01：为什么需要编程规范？工欲善其事，必先利其器 对于一些大型的企业级项目而言，通常情况下我们都是需要一个团队来进行开发的。而又因为团队人员对技术理解上的参差不齐，所以就会导致出现一种情况，那就是《一个项目无法具备统一的编程规范，导致项目的...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"18 mins."},"categories":[{"name":"vue3.2后台管理系统","slug":"vue3-2后台管理系统","count":12,"path":"api/categories/vue3-2后台管理系统.json"}],"tags":[{"name":"后台","slug":"后台","count":12,"path":"api/tags/后台.json"}],"author":{"name":"西非","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个跑路的设计师","socials":{"github":"https://github.com/xuhui-web","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/a18482157085","juejin":"https://juejin.cn/user/1535369026995422","customs":{}}}}}