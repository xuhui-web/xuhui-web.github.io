[{"id":"4da4bbb2736245860c5430530ccba5c0","title":"12总结","content":"第十二章：总结12-1：总结回顾一下整个项目，整个项目我们分成了10个章节：\n\n编程规范\n登录处理\nLayout 处理\n后台综合方案\nElementPlus 组件\n权限处理\n动态表格处理\n编辑器处理\n部署方案\n\n通过这10大块内容，把一个后台系统的高频场景都进行了解析。\n","slug":"vue3.2后台管理系统/12总结","date":"2022-08-22T22:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"ceaf92ec45e058e81b36404611c06d3e","title":"11项目部署之通用方案","content":"第十一章：项目部署之通用方案11-1：开篇那么到这里我们的整个课程就已经接近尾声了。\n最后我们就需要来看一下项目的打包和发布功能，这两个功能也就是我们本章节的主要功能。\n11-2：项目构建过程分析与实现本小节我们主要围绕着三个问题来去讲：\n\n为什么需要打包项目？\n打包之后项目可以通过浏览器直接访问吗？\n为什么需要有服务？\n\n为什么需要打包项目：\n浏览器只能识别并运行 html、css、js 文件 。\n那么换句话而言，项目中的 .vue 文件，浏览器是不认识的。\n而打包的过程就是把 .vue 的 单文件组件 打包成 html、css、js 的文件，让浏览器进行识别，并展示我们的项目\n打包之后项目可以通过浏览器直接访问吗？\n我们可以测试一下。\n通过 npm run build 打包项目之后，打包的文件会被放入到 dist 文件夹中，其实我们可以直接双击 index.html 文件，可以发现，浏览器是 无法 显示项目的。\n打开 F12 可以发现，终端中抛出了很多的错误。\n那么根据这些错误可以知道，无法显示的原因是因为 一些文件找不到了。\n那么为什么找不到呢？\n查看我们的 url 可以发现，其实我们的 url 是一个 file 协议。那么对应的文件路径就会编程 盘符下的 xxx ，在我们当前的盘符下没有对应的文件，那么自然是无法找到的。\n而想要解决这个问题的话，就需要把我们的项目运行到一个 服务 中，就像我们开发时的 devServer 一样。\n为什么需要有服务？\n明确了上面的问题之后，为什么要有服务就比较好理解了。\n我们需要通过一个 服务 托管我们的项目，从而避免出现模块无法被找到等问题。\n\n那么明确好了，以上问题之后，接下来我们就可以打包我们的项目，并且把项目部署到服务器之中。\n我们可以通过 npm run build 打包项目，打包好项目之后，接下来我们再来看如何到服务器中部署我们的服务。\n11-3：域名、DNS、公网IP、服务器、Nginx之间的关系在处理我们的服务之前，我们明确一些基本的概念，这些概念有：\n\n域名：https://imooc-admin.lgdsunday.club\nDNS：域名解析服务器\n公网IP：服务器在网络中的唯一地址\n服务器：服务部署的电脑\nNginx：网页服务\n\n\n\n\n\n11-4：阿里云服务器购买指南云服务器 ECS 自定义购买\n11-5：服务器连接方式常见的连接服务器的方式有三种：\n\n阿里云控制台中进行远程链接\n通过 SSH 工具（XShell）\nSSH 指令远程登录\n\n那么我们这里使用第二种 通过 SSH 工具（XShell）进行连接。\n\n新建会话\n确定会话信息，协议为 SSH、主机为服务器 IP、端口号为 22\n双击会话进行连接\n输入你的用户名（默认为 root）\n输入你的密码\n出现此信息，表示连接成功\n\n11-6：Nginx 环境处理\nnginx 编译时依赖 gcc 环境\nyum -y install gcc gcc-c++\n\n安装 prce，让 nginx 支持重写功能\nyum -y install pcre*\n\n安装 zlib，nginx 使用 zlib 对 http 包内容进行 gzip 压缩\nyum -y install zlib zlib-devel \n\n安装 openssl，用于通讯加密\nyum -y install openssl openssl-devel\n\n进行 nginx 安装\n\n创建 nginx 文件夹\n\n下载 nginx 压缩包\nwget https:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.11.5.tar.gz\n\n解压 nginx\ntar -zxvf  nginx-1.11.5.tar.gz\n\n进入 nginx-1.11.5 目录\ncd nginx-1.11.5\n\n检查平台安装环境\n.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx\n\n进行源码编译\nmake \n\n安装 nginx\nmake install\n\n查看 nginx 配置\n&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t\n\n制作 nginx 软连接\n\n进入 usr/bin 目录\ncd &#x2F;usr&#x2F;bin\n\n制作软连接\nln -s &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx nginx\n\n接下来制作配置文件\n\n首先进入到 nginx 的默认配置文件中\nvim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf\n\n在最底部增加配置项（按下 i 进入 输入模式）\ninclude &#x2F;nginx&#x2F;*.conf;\n\n按下 esc 键，通过 :wq! 保存并退出\n\n创建新的配置文件\ntouch &#x2F;nginx&#x2F;nginx.conf\n\n进入到 /root/nginx/nginx.conf 文件\nvim &#x2F;nginx&#x2F;nginx.conf\n\n写入如下配置\n# imooc-admin\nserver &#123;\n    # 端口\n    listen       80;\n    # 域名\n    server_name  localhost;\n    # 资源地址\n    root   &#x2F;nginx&#x2F;dist&#x2F;;\n    # 目录浏览\n    autoindex on;\n    # 缓存处理\n    add_header Cache-Control &quot;no-cache, must-revalidate&quot;;\n    # 请求配置\n    location &#x2F; &#123;\n        # 跨域\n        add_header Access-Control-Allow-Origin *;\n        # 返回 index.html\n        try_files $uri $uri&#x2F; &#x2F;index.html;\n    &#125;\n&#125;\n\n通过 :wq! 保存退出\n\n在 root/nginx 中创建 dist 文件夹\nmkdir &#x2F;nginx&#x2F;dist\n\n在 nginx/dist 中写入 index.html 进行测试\n\n通过 nginx -s reload 重启服务\n\n在 浏览器中通过，IP 测试访问\n\n\n11-7：项目发布可以通过 XFTP 进行数据传输\n11-8：总结本章节主要讲解了一些基础的 部署 相关的知识，这些内容并不复杂，属于通用性内容。\n那么现在我们的项目就已经可以部署到我们的服务器中了，大家就可以根据自己的域名进行对应的访问了\n","slug":"vue3.2后台管理系统/11项目部署之通用方案","date":"2022-08-22T21:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"b1e9e78ac18c4b9597d3b65fe8a20c6a","title":"10富文本与markdown综合处理之创建文章","content":"第十章：富文本与markdown综合处理之创建文章10-1：开篇本章中我们的核心业务就是 编辑文章。\n而对于 编辑文章 而言提供了两种编辑方式：\n\n富文本\nmarkdown\n\n对于这两种编辑形式在现在的前端中都拥有非常多的第三方库，那么对于我们开发者而言，我们肯定也是从中去选择出一个适合我们当前业务的库来进行使用，从而实现出对应的编辑形式。\n那么对于我们本章的内容而言，主要就是分成了三个部分：\n\n辅助业务：创建文章、编辑文章\n富文本库：介绍 、使用\nmarkdown：介绍、使用\n\n那么明确好了对应的内容之后，接下来我们就去进行对应的实现即可\n10-2：辅助业务：创建文章基本结构实现那么首先我们先去完成 创建文章 的基本结构，主要分成三部分：\n\narticle-create 页面：基本结构\nEditor 组件：富文本编辑器\nMarkdown 组件：markdown 编辑器\n\n那么明确好了之后，我们就去进行对应的实现：\n\n创建 views/article-create/components/Editor\n\n创建 views/article-create/components/Markdown\n\n在 views/article-create 完成基本结构\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;article-create&quot;&gt;\n    &lt;el-card&gt;\n      &lt;el-input\n        class&#x3D;&quot;title-input&quot;\n        :placeholder&#x3D;&quot;$t(&#39;msg.article.titlePlaceholder&#39;)&quot;\n        v-model&#x3D;&quot;title&quot;\n        maxlength&#x3D;&quot;20&quot;\n        clearable\n      &gt;\n      &lt;&#x2F;el-input&gt;\n      &lt;el-tabs v-model&#x3D;&quot;activeName&quot;&gt;\n        &lt;el-tab-pane :label&#x3D;&quot;$t(&#39;msg.article.markdown&#39;)&quot; name&#x3D;&quot;markdown&quot;&gt;\n          &lt;markdown&gt;&lt;&#x2F;markdown&gt;\n        &lt;&#x2F;el-tab-pane&gt;\n        &lt;el-tab-pane :label&#x3D;&quot;$t(&#39;msg.article.richText&#39;)&quot; name&#x3D;&quot;editor&quot;&gt;\n          &lt;editor&gt;&lt;&#x2F;editor&gt;\n        &lt;&#x2F;el-tab-pane&gt;\n      &lt;&#x2F;el-tabs&gt;\n    &lt;&#x2F;el-card&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport Editor from &#39;.&#x2F;components&#x2F;Editor.vue&#39;\nimport Markdown from &#39;.&#x2F;components&#x2F;Markdown.vue&#39;\nimport &#123; ref &#125; from &#39;vue&#39;\n\nconst activeName &#x3D; ref(&#39;markdown&#39;)\nconst title &#x3D; ref(&#39;&#39;)\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.title-input &#123;\n  margin-bottom: 20px;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n10-3：编辑库选择标准对于现在的前端编辑库（markdown 与 富文本）而言，如果仅从功能上来去看的话，那么其实都是相差无几的。\n随便从 github 中挑选编辑库，只要 star 在 10K（保守些） 以上的，编辑器之上的常用功能一应俱全。\n那么这样的话就会导致一个问题我们想要去选择一个编辑库的话，应该如何去进行选择呢？\n如果你现在想要去选择一个编辑库，那么可以从以下几点中进行选择：\n\n开源协议：其中尽量选择 MIT 或者 BSD 协议的开源项目\n功能：功能需要满足基本需求\nissue：通过 issue 查看作者对该库的维护程度\n文档：文档越详尽越好，最好提供了中文文档（英文好的可以忽略）\n国产的：或许你 朋友的朋友的朋友 就是这个库的作者\n\n那么根据以上几点，我选择了以下的编辑器库：\n\nmarkdown 编辑器：tui.editor\n富文本编辑器：wangEditor\n\n那么最后给大家推荐一些编辑器库，大家可以进行一些参考：\n\nmarkdown 编辑器：\ntui.editor：Markdown 所见即所得编辑器-高效且可扩展，使用MIT开源协议。\neditor：纯文本 markdown 编辑器\neditor.md：开源可嵌入的在线markdown编辑器(组件)，基于 CodeMirror &amp; jQuery &amp; Marked。国产\nmarkdown-here：谷歌开源，但是已经 多年不更新 了\nstackedit：基于PageDown，Stack Overflow和其他Stack Exchange站点使用的Markdown库的功能齐全的开源Markdown编辑器。两年未更新了\nmarkdown-it：可配置语法，可添加、替换规则。挺长时间未更新了\n\n\n富文本编辑器：\nwangEditor：国产、文档详尽、更新快速\ntinymce：对 IE6+ 和 Firefox1.5+ 都有着非常良好的支持\nquill：代码高亮功能、视频加载功能、公式处理比较强。\nckeditor5：编辑能力强\nwysiwyg-editor：收费的 ， 就是牛\n\n\n\n以上列举出的编辑器，大家可以进行一些参考\n10-4：新建文章：markdown 实现我们通过 tui.editor 实现 markdown 的编辑功能：\n\n下载 tui.editor\nnpm i @toast-ui&#x2F;editor@3.0.2\n\n渲染基本结构\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;markdown-container&quot;&gt;\n    &lt;!-- 渲染区 --&gt;\n    &lt;div id&#x3D;&quot;markdown-box&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;bottom&quot;&gt;\n      &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onSubmitClick&quot;&gt;&#123;&#123;\n        $t(&#39;msg.article.commit&#39;)\n      &#125;&#125;&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.markdown-container &#123;\n  .bottom &#123;\n    margin-top: 20px;\n    text-align: right;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n初始化 editor ，处理国际化内容\n&lt;script setup&gt;\nimport MkEditor from &#39;@toast-ui&#x2F;editor&#39;\nimport &#39;@toast-ui&#x2F;editor&#x2F;dist&#x2F;toastui-editor.css&#39;\nimport &#39;@toast-ui&#x2F;editor&#x2F;dist&#x2F;i18n&#x2F;zh-cn&#39;\nimport &#123; onMounted &#125; from &#39;vue&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\n\n&#x2F;&#x2F; Editor实例\nlet mkEditor\n&#x2F;&#x2F; 处理离开页面切换语言导致 dom 无法被获取\nlet el\nonMounted(() &#x3D;&gt; &#123;\n  el &#x3D; document.querySelector(&#39;#markdown-box&#39;)\n  initEditor()\n&#125;)\n\nconst store &#x3D; useStore()\nconst initEditor &#x3D; () &#x3D;&gt; &#123;\n  mkEditor &#x3D; new MkEditor(&#123;\n    el,\n    height: &#39;500px&#39;,\n    previewStyle: &#39;vertical&#39;,\n    language: store.getters.language &#x3D;&#x3D;&#x3D; &#39;zh&#39; ? &#39;zh-CN&#39; : &#39;en&#39;\n  &#125;)\n\n  mkEditor.getMarkdown()\n&#125;\n&lt;&#x2F;script&gt;\n\n在语言改变时，重置 editor\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n\nwatchSwitchLang(() &#x3D;&gt; &#123;\n  if (!el) return\n  const htmlStr &#x3D; mkEditor.getHTML()\n  mkEditor.destroy()\n  initEditor()\n  mkEditor.setHTML(htmlStr)\n&#125;)\n\n10-5：新建文章：markdown 文章提交\n在 api/article 中，定义创建文章接口\n&#x2F;**\n * 创建文章\n *&#x2F;\nexport const createArticle &#x3D; (data) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;article&#x2F;create&#39;,\n    method: &#39;POST&#39;,\n    data\n  &#125;)\n&#125;\n\n因为 markdown 或者是 富文本 最终都会处理提交事件，所以我们可以把这两件事情合并到一个模块中实现：\n\n创建 article-create/components/commit.js \nimport &#123; createArticle &#125; from &#39;@&#x2F;api&#x2F;article&#39;\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\nimport i18n from &#39;@&#x2F;i18n&#39;\nconst t &#x3D; i18n.global.t\n\nexport const commitArticle &#x3D; async (data) &#x3D;&gt; &#123;\n  const res &#x3D; await createArticle(data)\n  ElMessage.success(t(&#39;msg.article.createSuccess&#39;))\n  return res\n&#125;\n\n\n在 markdown.vue 中导入该方法\nimport &#123; commitArticle &#125; from &#39;.&#x2F;commit&#39;\n\n\n触发按钮提交事件\nconst props &#x3D; defineProps(&#123;\n  title: &#123;\n    required: true,\n    type: String\n  &#125;\n&#125;)\n\nconst emits &#x3D; defineEmits([&#39;onSuccess&#39;])\n...\n&#x2F;&#x2F; 处理提交\nconst onSubmitClick &#x3D; async () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 创建文章\n  await commitArticle(&#123;\n    title: props.title,\n    content: mkEditor.getHTML()\n  &#125;)\n\n  mkEditor.reset()\n  emits(&#39;onSuccess&#39;)\n&#125;\n\n在 article-create 中传递 title，处理 onSuccess 事件\n&#x2F;&#x2F; 创建成功\nconst onSuccess &#x3D; () &#x3D;&gt; &#123;\n  title.value &#x3D; &#39;&#39;\n&#125;\n\n10-6：新建文章：markdown 文章编辑\n在 article-detail 中点击编辑按钮，进入创建文章页面\n&#x2F;&#x2F; 编辑\nconst router &#x3D; useRouter()\nconst onEditClick &#x3D; () &#x3D;&gt; &#123;\n  router.push(&#96;&#x2F;article&#x2F;editor&#x2F;$&#123;articleId&#125;&#96;)\n&#125;\n\n在 article-craete 中，处理 编辑 相关操作\n\n获取当前文章数据\n&#x2F;&#x2F; 处理编辑相关\nconst route &#x3D; useRoute()\nconst articleId &#x3D; route.params.id\nconst detail &#x3D; ref(&#123;&#125;)\nconst getArticleDetail &#x3D; async () &#x3D;&gt; &#123;\n  detail.value &#x3D; await articleDetail(articleId)\n  &#x2F;&#x2F; 标题赋值\n  title.value &#x3D; detail.value.title\n&#125;\nif (articleId) &#123;\n  getArticleDetail()\n&#125;\n\n把获取到的数据传递给 markdown 组件\n&lt;markdown\n    :title&#x3D;&quot;title&quot;\n    :detail&#x3D;&quot;detail&quot;\n    @onSuccess&#x3D;&quot;onSuccess&quot;\n&gt;&lt;&#x2F;markdown&gt;\n\n在 markdown 中接收该数据\nconst props &#x3D; defineProps(&#123;\n ...\n  detail: &#123;\n    type: Object\n  &#125;\n&#125;)\n\n检测数据变化，存在 detail 时，把 detail 赋值给 mkEditor\n&#x2F;&#x2F; 编辑相关\nwatch(\n  () &#x3D;&gt; props.detail,\n  (val) &#x3D;&gt; &#123;\n    if (val &amp;&amp; val.content) &#123;\n      mkEditor.setHTML(val.content)\n    &#125;\n  &#125;,\n  &#123;\n    immediate: true\n  &#125;\n)\n\n创建 编辑文章 接口\n&#x2F;**\n * 编辑文章详情\n *&#x2F;\nexport const articleEdit &#x3D; (data) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;article&#x2F;edit&#39;,\n    method: &#39;POST&#39;,\n    data\n  &#125;)\n&#125;\n\n在 commit.js 中生成 编辑文章 方法\nexport const editArticle &#x3D; async data &#x3D;&gt; &#123;\n  const res &#x3D; await articleEdit(data)\n  ElMessage.success(t(&#39;msg.article.editorSuccess&#39;))\n  return res\n&#125;\n\n在 markdown 中处理提交按钮事件\n&#x2F;&#x2F; 处理提交\nconst onSubmitClick &#x3D; async () &#x3D;&gt; &#123;\n  if (props.detail &amp;&amp; props.detail._id) &#123;\n    &#x2F;&#x2F; 编辑文章\n    await editArticle(&#123;\n      id: props.detail._id,\n      title: props.title,\n      content: mkEditor.getHTML()\n    &#125;)\n  &#125; else &#123;\n    &#x2F;&#x2F; 创建文章\n    await commitArticle(&#123;\n      title: props.title,\n      content: mkEditor.getHTML()\n    &#125;)\n  &#125;\n\n  mkEditor.reset()\n  emits(&#39;onSuccess&#39;)\n&#125;\n\n10-7：新建文章：富文本 实现富文本我们使用 wangEditor，所以我们得先去下载 wangEditor\nnpm i wangeditor@4.7.6\n\n安装完成之后，我们就去实现对应的代码逻辑：\n\n创建基本组件结构\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;editor-container&quot;&gt;\n    &lt;div id&#x3D;&quot;editor-box&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;bottom&quot;&gt;\n      &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onSubmitClick&quot;&gt;&#123;&#123;\n        $t(&#39;msg.article.commit&#39;)\n      &#125;&#125;&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.editor-container &#123;\n  .bottom &#123;\n    margin-top: 20px;\n    text-align: right;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n初始化 wangEditor\n&lt;script setup&gt;\nimport E from &#39;wangeditor&#39;\nimport &#123; onMounted &#125; from &#39;vue&#39;\n\n&#x2F;&#x2F; Editor实例\nlet editor\n&#x2F;&#x2F; 处理离开页面切换语言导致 dom 无法被获取\nlet el\nonMounted(() &#x3D;&gt; &#123;\n  el &#x3D; document.querySelector(&#39;#editor-box&#39;)\n  initEditor()\n&#125;)\n\nconst initEditor &#x3D; () &#x3D;&gt; &#123;\n  editor &#x3D; new E(el)\n  editor.config.zIndex &#x3D; 1\n  &#x2F;&#x2F; 菜单栏提示\n  editor.config.showMenuTooltips &#x3D; true\n  editor.config.menuTooltipPosition &#x3D; &#39;down&#39;\n  editor.create()\n&#125;\n&lt;&#x2F;script&gt;\n\nwangEditor  的 国际化处理，官网支持 i18next，所以想要处理 wangEditor 的国际化，那么我们需要安装 i18next\nnpm i --save i18next@20.4.0\n\n对 wangEditor 进行国际化处理\nimport i18next from &#39;i18next&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\n\nconst store &#x3D; useStore()\n...\nconst initEditor &#x3D; () &#x3D;&gt; &#123;\n  ...\n\n  &#x2F;&#x2F; 国际化相关处理\n  editor.config.lang &#x3D; store.getters.language &#x3D;&#x3D;&#x3D; &#39;zh&#39; ? &#39;zh-CN&#39; : &#39;en&#39;\n  editor.i18next &#x3D; i18next\n\n  editor.create()\n&#125;\n\n处理提交事件\nimport &#123; onMounted, defineProps, defineEmits &#125; from &#39;vue&#39;\nimport &#123; commitArticle &#125; from &#39;.&#x2F;commit&#39;\n\nconst props &#x3D; defineProps(&#123;\n  title: &#123;\n    required: true,\n    type: String\n  &#125;\n&#125;)\n\nconst emits &#x3D; defineEmits([&#39;onSuccess&#39;])\n...\nconst onSubmitClick &#x3D; async () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 创建文章\n  await commitArticle(&#123;\n    title: props.title,\n    content: editor.txt.html()\n  &#125;)\n\n  editor.txt.html(&#39;&#39;)\n  emits(&#39;onSuccess&#39;)\n&#125;\n\n不要忘记在 article-create 中处理对应事件\n&lt;editor\n    :title&#x3D;&quot;title&quot;\n    :detail&#x3D;&quot;detail&quot;\n    @onSuccess&#x3D;&quot;onSuccess&quot;\n&gt;&lt;&#x2F;editor&gt;\n\n最后处理编辑\nconst props &#x3D; defineProps(&#123;\n  ...\n  detail: &#123;\n    type: Object\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 编辑相关\nwatch(\n  () &#x3D;&gt; props.detail,\n  (val) &#x3D;&gt; &#123;\n    if (val &amp;&amp; val.content) &#123;\n      editor.txt.html(val.content)\n    &#125;\n  &#125;,\n  &#123;\n    immediate: true\n  &#125;\n)\n\nconst onSubmitClick &#x3D; async () &#x3D;&gt; &#123;\n  if (props.detail &amp;&amp; props.detail._id) &#123;\n    &#x2F;&#x2F; 编辑文章\n    await editArticle(&#123;\n      id: props.detail._id,\n      title: props.title,\n      content: editor.txt.html()\n    &#125;)\n  &#125; else &#123;\n    &#x2F;&#x2F; 创建文章\n    await commitArticle(&#123;\n      title: props.title,\n      content: editor.txt.html()\n    &#125;)\n  &#125;\n\n  editor.txt.html(&#39;&#39;)\n  emits(&#39;onSuccess&#39;)\n&#125;\n\n10-8：总结本章节中我们的核心重点就是 编辑库 的选择\n常用的编辑库其实主要就分成了这么两种：\n\nmarkdown\n富文本\n\n那么对于大家而言，不一定非要使用我们在课程中使用的这两个编辑器库。\n因为对于编辑器库而言，它的使用方式都是大同小异的，大家只需要根据我们 《编辑器库选择标准》 来选择使用自己当前情况的编辑器库即可\n","slug":"vue3.2后台管理系统/10富文本与markdown综合处理之创建文章","date":"2022-08-22T20:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"003ef1fc8e383b34a44488d3579cdaee","title":"09动态表格渲染方案之文章排名业务实现","content":"第九章：动态表格渲染方案之文章排名业务实现9-01：开篇对于 文章排名 而言，核心的内容是围绕着表格处理来进行的。对应的核心业务主要有两个：\n\n文章排名切换\n动态表格渲染\n\n这两个核心业务配合着其他的一些辅助功能：\n\n文章排名页面展示\n文章详情页面展示\n\n共同组成了咱们这一大章的内容\n9-02：辅助业务：文章排名页面渲染整个 文章排名 的页面渲染分成三个部分：\n\n顶部的动态展示区域\n中间的 table 列表展示区域\n底部的分页展示区域\n\n那么在这一小节中，我们先去渲染第 2、3 两部分：\n\n创建 api/article 文件定义数据获取接口\nimport request from &#39;@&#x2F;utils&#x2F;request&#39;\n\n&#x2F;**\n * 获取列表数据\n *&#x2F;\nexport const getArticleList &#x3D; data &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;article&#x2F;list&#39;,\n    params: data\n  &#125;)\n&#125;\n\n\n在 article-ranking 中获取对应数据\n&lt;script setup&gt;\nimport &#123; ref, onActivated &#125; from &#39;vue&#39;\nimport &#123; getArticleList &#125; from &#39;@&#x2F;api&#x2F;article&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n\n&#x2F;&#x2F; 数据相关\nconst tableData &#x3D; ref([])\nconst total &#x3D; ref(0)\nconst page &#x3D; ref(1)\nconst size &#x3D; ref(10)\n\n&#x2F;&#x2F; 获取数据的方法\nconst getListData &#x3D; async () &#x3D;&gt; &#123;\n  const result &#x3D; await getArticleList(&#123;\n    page: page.value,\n    size: size.value\n  &#125;)\n  tableData.value &#x3D; result.list\n  total.value &#x3D; result.total\n&#125;\ngetListData()\n&#x2F;&#x2F; 监听语言切换\nwatchSwitchLang(getListData)\n&#x2F;&#x2F; 处理数据不重新加载的问题\nonActivated(getListData)\n&lt;&#x2F;script&gt;\n\n根据数据渲染视图\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;article-ranking-container&quot;&gt;\n    &lt;el-card&gt;\n      &lt;el-table ref&#x3D;&quot;tableRef&quot; :data&#x3D;&quot;tableData&quot; border&gt;\n        &lt;el-table-column\n          :label&#x3D;&quot;$t(&#39;msg.article.ranking&#39;)&quot;\n          prop&#x3D;&quot;ranking&quot;\n        &gt;&lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          :label&#x3D;&quot;$t(&#39;msg.article.title&#39;)&quot;\n          prop&#x3D;&quot;title&quot;\n        &gt;&lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          :label&#x3D;&quot;$t(&#39;msg.article.author&#39;)&quot;\n          prop&#x3D;&quot;author&quot;\n        &gt;&lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          :label&#x3D;&quot;$t(&#39;msg.article.publicDate&#39;)&quot;\n          prop&#x3D;&quot;publicDate&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          :label&#x3D;&quot;$t(&#39;msg.article.desc&#39;)&quot;\n          prop&#x3D;&quot;desc&quot;\n        &gt;&lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column :label&#x3D;&quot;$t(&#39;msg.article.action&#39;)&quot;&gt;\n          &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;onShowClick(row)&quot;&gt;&#123;&#123;\n            $t(&#39;msg.article.show&#39;)\n          &#125;&#125;&lt;&#x2F;el-button&gt;\n          &lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;onRemoveClick(row)&quot;&gt;&#123;&#123;\n            $t(&#39;msg.article.remove&#39;)\n          &#125;&#125;&lt;&#x2F;el-button&gt;\n        &lt;&#x2F;el-table-column&gt;\n      &lt;&#x2F;el-table&gt;\n\n      &lt;el-pagination\n        class&#x3D;&quot;pagination&quot;\n        @size-change&#x3D;&quot;handleSizeChange&quot;\n        @current-change&#x3D;&quot;handleCurrentChange&quot;\n        :current-page&#x3D;&quot;page&quot;\n        :page-sizes&#x3D;&quot;[5, 10, 50, 100, 200]&quot;\n        :page-size&#x3D;&quot;size&quot;\n        layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot;\n        :total&#x3D;&quot;total&quot;\n      &gt;\n      &lt;&#x2F;el-pagination&gt;\n    &lt;&#x2F;el-card&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\n...\n&#x2F;**\n * size 改变触发\n *&#x2F;\nconst handleSizeChange &#x3D; currentSize &#x3D;&gt; &#123;\n  size.value &#x3D; currentSize\n  getListData()\n&#125;\n\n&#x2F;**\n * 页码改变触发\n *&#x2F;\nconst handleCurrentChange &#x3D; currentPage &#x3D;&gt; &#123;\n  page.value &#x3D; currentPage\n  getListData()\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.article-ranking-container &#123;\n  .header &#123;\n    margin-bottom: 20px;\n    .dynamic-box &#123;\n      display: flex;\n      align-items: center;\n      .title &#123;\n        margin-right: 20px;\n        font-size: 14px;\n        font-weight: bold;\n      &#125;\n    &#125;\n  &#125;\n\n  ::v-deep .el-table__row &#123;\n    cursor: pointer;\n  &#125;\n\n  .pagination &#123;\n    margin-top: 20px;\n    text-align: center;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n9-03：相对时间与时间国际化处理在 发布时间 列中，我们希望展示相对时间，并且希望相对时间具备国际化的能力。那么我们就去需要到 filters 中对 dayjs 进行处理\n\n定义相对时间的处理方法\n...\nimport rt from &#39;dayjs&#x2F;plugin&#x2F;relativeTime&#39;\n\n...\n\n&#x2F;&#x2F; 加载相对时间插件\ndayjs.extend(rt)\nfunction relativeTime(val) &#123;\n  if (!isNaN(val)) &#123;\n    val &#x3D; parseInt(val)\n  &#125;\n  return dayjs().to(dayjs(val))\n&#125;\n\nexport default app &#x3D;&gt; &#123;\n  app.config.globalProperties.$filters &#x3D; &#123;\n    ...\n    relativeTime\n  &#125;\n&#125;\n\n\n在 article-ranking 中使用相对时间\n&lt;el-table-column :label&#x3D;&quot;$t(&#39;msg.article.publicDate&#39;)&quot;&gt;\n          &lt;template #default&#x3D;&quot;&#123;row&#125;&quot;&gt;\n            &#123;&#123; $filters.relativeTime(row.publicDate) &#125;&#125;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n\n接下来来处理国际化内容\n...\n&#x2F;&#x2F; 语言包\nimport &#39;dayjs&#x2F;locale&#x2F;zh-cn&#39;\nimport store from &#39;@&#x2F;store&#39;\n\n...\nfunction relativeTime(val) &#123;\n ...\n  return dayjs()\n    .locale(store.getters.language &#x3D;&#x3D;&#x3D; &#39;zh&#39; ? &#39;zh-cn&#39; : &#39;en&#39;)\n    .to(dayjs(val))\n&#125;\n\n\n\n9-04：动态表格原理与实现分析所谓动态表格指的是：根据列的勾选，动态展示表格中的列\n那么我们同样把这一句话拆开来去看：\n\n展示可勾选的列\n动态展示表格的列\n\n那么我们先来看第一部分 展示可勾选的列：\n可勾选的列通过 el-checkbox 来进行渲染。\n所以只要我们有对应的数据，那么渲染自然也没有对应的难度。\n然后我们来看 动态展示表格的列：\n所谓 动态展示表格的列 指的就是 动态的渲染 el-table-column ，那么怎么进行动态渲染el-table-column呢？\n我们来看现在的 el-table-column 的渲染，在页面中我们写入了大量的 el-table-column 组件，那么对于这样的组件，我们想一下可不可以通过 v-for 进行渲染？\n依赖于数据，通过 v-for 渲染  el-table-column ，当数据改变时 el-table-column 的渲染自然也就发生了变化，这样我们是不是就完成了 动态的渲染 el-table-column 功能了？\n所以以上两个功能，最核心的部分就是 列数据的指定，只要有了对应的数据，那么对应的渲染也就非常简单了。\n所以我们总结一下对应的实现步骤：\n\n构建列数据（核心）\n根据数据，通过 el-checkbox 渲染可勾选的列\n根据数据，通过 v-for 动态渲染  el-table-column\n\n9-05：方案落地：动态列数据构建因为我们要在 article-ranking 中处理多个业务，如果我们把所有的业务处理都写到 article-ranking 中，那么对应的组件就过于复杂了，所以说我们把所有的 动态列表 相关的业务放入到 article-ranking/dynamic 文件夹中\n\n创建 article-ranking/dynamic/DynamicData 文件，用来指定初始的 列数据\nimport i18n from &#39;@&#x2F;i18n&#39;\n\nconst t &#x3D; i18n.global.t\n\nexport default () &#x3D;&gt; [\n  &#123;\n    label: t(&#39;msg.article.ranking&#39;),\n    prop: &#39;ranking&#39;\n  &#125;,\n  &#123;\n    label: t(&#39;msg.article.title&#39;),\n    prop: &#39;title&#39;\n  &#125;,\n  &#123;\n    label: t(&#39;msg.article.author&#39;),\n    prop: &#39;author&#39;\n  &#125;,\n  &#123;\n    label: t(&#39;msg.article.publicDate&#39;),\n    prop: &#39;publicDate&#39;\n  &#125;,\n  &#123;\n    label: t(&#39;msg.article.desc&#39;),\n    prop: &#39;desc&#39;\n  &#125;,\n  &#123;\n    label: t(&#39;msg.article.action&#39;),\n    prop: &#39;action&#39;\n  &#125;\n]\n\n创建 article-ranking/dynamic/index 文件，对外暴露出\n\n动态列数据\n被勾选的动态列数据\ntable 的列数据\n\nimport getDynamicData from &#39;.&#x2F;DynamicData&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\nimport &#123; watch, ref &#125; from &#39;vue&#39;\n\n&#x2F;&#x2F; 暴露出动态列数据\nexport const dynamicData &#x3D; ref(getDynamicData())\n\n&#x2F;&#x2F; 监听 语言变化\nwatchSwitchLang(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 重新获取国际化的值\n  dynamicData.value &#x3D; getDynamicData()\n  &#x2F;&#x2F; 重新处理被勾选的列数据\n  initSelectDynamicLabel()\n&#125;)\n\n&#x2F;&#x2F; 创建被勾选的动态列数据\nexport const selectDynamicLabel &#x3D; ref([])\n&#x2F;&#x2F; 默认全部勾选\nconst initSelectDynamicLabel &#x3D; () &#x3D;&gt; &#123;\n  selectDynamicLabel.value &#x3D; dynamicData.value.map(item &#x3D;&gt; item.label)\n&#125;\ninitSelectDynamicLabel()\n\n&#x2F;&#x2F; 声明 table 的列数据\nexport const tableColumns &#x3D; ref([])\n&#x2F;&#x2F; 监听选中项的变化，根据选中项动态改变 table 列数据的值\nwatch(\n  selectDynamicLabel,\n  val &#x3D;&gt; &#123;\n    tableColumns.value &#x3D; []\n    &#x2F;&#x2F; 遍历选中项\n    const selectData &#x3D; dynamicData.value.filter(item &#x3D;&gt; &#123;\n      return val.includes(item.label)\n    &#125;)\n    tableColumns.value.push(...selectData)\n  &#125;,\n  &#123;\n    immediate: true\n  &#125;\n)\n\n9-06：方案落地：实现动态表格能力那么现在有了数据之后，我们就可以实现对应的动态表格功能了\n\n在 article-ranking 中渲染 动态表格的 check\n\n导入动态表格的 check 数据\nimport &#123; dynamicData, selectDynamicLabel &#125; from &#39;.&#x2F;dynamic&#39;\n\n完成动态表格的 check 渲染\n&lt;el-card class&#x3D;&quot;header&quot;&gt;\n  &lt;div class&#x3D;&quot;dynamic-box&quot;&gt;\n    &lt;span class&#x3D;&quot;title&quot;&gt;&#123;&#123; $t(&#39;msg.article.dynamicTitle&#39;) &#125;&#125;&lt;&#x2F;span&gt;\n    &lt;el-checkbox-group v-model&#x3D;&quot;selectDynamicLabel&quot;&gt;\n      &lt;el-checkbox\n        v-for&#x3D;&quot;(item, index) in dynamicData&quot;\n        :label&#x3D;&quot;item.label&quot;\n        :key&#x3D;&quot;index&quot;\n        &gt;&#123;&#123; item.label &#125;&#125;&lt;&#x2F;el-checkbox\n      &gt;\n    &lt;&#x2F;el-checkbox-group&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;el-card&gt;\n\n导入动态列数据\nimport &#123; ... tableColumns &#125; from &#39;.&#x2F;dynamic&#39;\n\n完成动态列渲染\n&lt;el-table ref&#x3D;&quot;tableRef&quot; :data&#x3D;&quot;tableData&quot; border&gt;\n  &lt;el-table-column\n    v-for&#x3D;&quot;(item, index) in tableColumns&quot;\n    :key&#x3D;&quot;index&quot;\n    :prop&#x3D;&quot;item.prop&quot;\n    :label&#x3D;&quot;item.label&quot;\n  &gt;\n    &lt;template #default&#x3D;&quot;&#123; row &#125;&quot; v-if&#x3D;&quot;item.prop &#x3D;&#x3D;&#x3D; &#39;publicDate&#39;&quot;&gt;\n      &#123;&#123; $filters.relativeTime(row.publicDate) &#125;&#125;\n    &lt;&#x2F;template&gt;\n    &lt;template #default&#x3D;&quot;&#123; row &#125;&quot; v-else-if&#x3D;&quot;item.prop &#x3D;&#x3D;&#x3D; &#39;action&#39;&quot;&gt;\n      &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;onShowClick(row)&quot;&gt;&#123;&#123;\n        $t(&#39;msg.article.show&#39;)\n      &#125;&#125;&lt;&#x2F;el-button&gt;\n      &lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;onRemoveClick(row)&quot;&gt;&#123;&#123;\n        $t(&#39;msg.article.remove&#39;)\n      &#125;&#125;&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;el-table-column&gt;\n&lt;&#x2F;el-table&gt;\n\n9-07：动态表格实现总结对于动态表格而言，没有涉及到新的技术点，主要是对现有技术的一个灵活使用。\n把动态表格拆开来去看，主要就是分成了两部分：\n\n展示可勾选的列\n动态展示表格的列\n\n那么对于这两部分而言，核心的就是 数据。只要我们可以实现对应的数据，那么想要实现这两个功能就非常的简单了。\n9-08：拖拽排序原理与实现分析那么接下来我们来实现 表格拖动排序 的功能\n对于这个功能，我们需要先来分析一下它的具体业务：\n\n鼠标在某一行中按下\n移动鼠标位置\n产生对应的替换样式\n鼠标抬起，表格行顺序发生变化\n\n依据以上的业务，那么实现该功能的核心就在于：监听鼠标事件，完成对应的 UI 视图处理\n具体来说：\n\n监听鼠标的按下事件\n监听鼠标的移动事件\n生成对应的 UI 样式\n监听鼠标的抬起事件\n\n那么对于以上的原理而言，想要落实到具体的代码中，其实还是比较复杂的。\n但是在现在的前端开发中，只要有对应的需求，那么在大多数的情况下都会存在对应的轮子（并且不止一个）。所以说咱们这里依然会借助对应的轮子来去实现。\n这个轮子就是 sortablejs：用于在列表中实现拖动排序\n那么我们整个 拖动排序 的核心实现，就是围绕着 sortablejs 来进行的\n那么以此，我们得出最终的实现方案：\n\n利用 sortablejs 实现表格拖拽功能\n在拖拽完成后，调用接口完成排序\n\n9-09：方案落地：实现表格拖拽功能\n下载 sortablejs\nnpm i sortablejs@1.14.0\n\n创建 article-ranking/sortable/index 文件，完成 sortable 初始化\nimport &#123; ref &#125; from &#39;vue&#39;\nimport Sortable from &#39;sortablejs&#39;\n\n&#x2F;&#x2F; 排序相关\nexport const tableRef &#x3D; ref(null)\n\n&#x2F;**\n * 初始化排序\n *&#x2F;\nexport const initSortable &#x3D; (tableData, cb) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置拖拽效果\n  const el &#x3D; tableRef.value.$el.querySelectorAll(\n    &#39;.el-table__body-wrapper &gt; table &gt; tbody&#39;\n  )[0]\n  &#x2F;&#x2F; 1. 要拖拽的元素\n  &#x2F;&#x2F; 2. 配置对象\n  Sortable.create(el, &#123;\n    &#x2F;&#x2F; 拖拽时类名\n    ghostClass: &#39;sortable-ghost&#39;,\n    &#x2F;&#x2F; 拖拽结束的回调方法\n    onEnd(event) &#123;&#125;\n  &#125;)\n&#125;\n\n在 article-ranking 中导入 tableRef, initSortable，并完成初始化\nimport &#123; tableRef, initSortable &#125; from &#39;.&#x2F;sortable&#39;\n\n&#x2F;&#x2F; 表格拖拽相关\nonMounted(() &#x3D;&gt; &#123;\n  initSortable(tableData, getListData)\n&#125;)\n\n指定拖拽时的样式\n::v-deep .sortable-ghost &#123;\n  opacity: 0.6;\n  color: #fff !important;\n  background: #304156 !important;\n&#125;\n\n9-10：方案落地：完成拖拽后的排序完成拖拽后的排序主要是在 拖拽结束的回调方法 中进行。\n我们需要在 拖拽结束的回调方法中调用对应的服务端接口完成持久化的排序\n\n在 api/article 中定义排序接口\n&#x2F;**\n * 修改排序\n *&#x2F;\nexport const articleSort &#x3D; data &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;article&#x2F;sort&#39;,\n    method: &#39;POST&#39;,\n    data\n  &#125;)\n&#125;\n\n在拖拽结束的回调方法中调用接口\n&#x2F;&#x2F; 拖拽结束的回调方法\nasync onEnd(event) &#123;\n  const &#123; newIndex, oldIndex &#125; &#x3D; event\n  &#x2F;&#x2F; 修改数据\n  await articleSort(&#123;\n    initRanking: tableData.value[oldIndex].ranking,\n    finalRanking: tableData.value[newIndex].ranking\n  &#125;)\n  ElMessage.success(&#123;\n    message: i18n.global.t(&#39;msg.article.sortSuccess&#39;),\n    type: &#39;success&#39;\n  &#125;)\n  &#x2F;&#x2F; 直接重新获取数据无法刷新 table！！\n  tableData.value &#x3D; []\n  &#x2F;&#x2F; 重新获取数据\n  cb &amp;&amp; cb()\n&#125;\n\n9-11：拖拽排序方案总结整个拖拽排序的功能我们围绕着 sortablejs 来去进行实现。\nsortablejs 提供了对于 table 的一个排序能力，我们只需要利用这个能力，并且在拖拽完成之后，对数据的排序进行一个持久化的存储即可。\n9-12：辅助业务：文章删除\n定义删除接口\n&#x2F;**\n * 删除文章\n *&#x2F;\nexport const deleteArticle &#x3D; articleId &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#96;&#x2F;article&#x2F;delete&#x2F;$&#123;articleId&#125;&#96;\n  &#125;)\n&#125;\n\n\n\n为删除按钮添加点击事件\n&lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;onRemoveClick(row)&quot;&gt;&#123;&#123;\n              $t(&#39;msg.article.remove&#39;)\n            &#125;&#125;&lt;&#x2F;el-button&gt;\n\n处理删除操作\n&#x2F;&#x2F; 删除用户\nconst i18n &#x3D; useI18n()\nconst onRemoveClick &#x3D; row &#x3D;&gt; &#123;\n  ElMessageBox.confirm(\n    i18n.t(&#39;msg.article.dialogTitle1&#39;) +\n      row.title +\n      i18n.t(&#39;msg.article.dialogTitle2&#39;),\n    &#123;\n      type: &#39;warning&#39;\n    &#125;\n  ).then(async () &#x3D;&gt; &#123;\n    await deleteArticle(row._id)\n    ElMessage.success(i18n.t(&#39;msg.article.removeSuccess&#39;))\n    &#x2F;&#x2F; 重新渲染数据\n    getListData()\n  &#125;)\n&#125;\n\n9-13：辅助业务：文章详情展示对于文章详情的展示而言，主要是为了配合 创建文章 的功能而产生的。\n文章详情中包含一个 编辑 按钮，用于对文章的编辑功能。与 创建文章 配合，达到相辅相成的目的。\n但是现在 创建文章 尚未实现，所以 编辑文章 也就暂时无从谈起，所以说我们此时仅先实现 文章详情展示 的功能，后续在完成了 创建文章 之后，再去实现 文章编辑\n\n在 api/article 中定义获取文章详情接口\n&#x2F;**\n * 获取文章详情\n *&#x2F;\nexport const articleDetail &#x3D; (articleId) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#96;&#x2F;article&#x2F;$&#123;articleId&#125;&#96;\n  &#125;)\n&#125;\n\n在 article-detail 中获取文章详情数据\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nimport &#123; useRoute &#125; from &#39;vue-router&#39;\nimport &#123; articleDetail &#125; from &#39;@&#x2F;api&#x2F;article&#39;\n\n&#x2F;&#x2F; 获取数据\nconst route &#x3D; useRoute()\nconst articleId &#x3D; route.params.id\nconst detail &#x3D; ref(&#123;&#125;)\nconst getArticleDetail &#x3D; async () &#x3D;&gt; &#123;\n  detail.value &#x3D; await articleDetail(articleId)\n&#125;\ngetArticleDetail()\n&lt;&#x2F;script&gt;\n\n根据数据渲染视图\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;article-detail-container&quot;&gt;\n    &lt;h2 class&#x3D;&quot;title&quot;&gt;&#123;&#123; detail.title &#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;div class&#x3D;&quot;header&quot;&gt;\n      &lt;span class&#x3D;&quot;author&quot;\n        &gt;&#123;&#123; $t(&#39;msg.article.author&#39;) &#125;&#125;：&#123;&#123; detail.author &#125;&#125;&lt;&#x2F;span\n      &gt;\n      &lt;span class&#x3D;&quot;time&quot;\n        &gt;&#123;&#123; $t(&#39;msg.article.publicDate&#39;) &#125;&#125;：&#123;&#123;\n          $filters.relativeTime(detail.publicDate)\n        &#125;&#125;&lt;&#x2F;span\n      &gt;\n      &lt;el-button type&#x3D;&quot;text&quot; class&#x3D;&quot;edit&quot; @click&#x3D;&quot;onEditClick&quot;&gt;&#123;&#123;\n        $t(&#39;msg.article.edit&#39;)\n      &#125;&#125;&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;content&quot; v-html&#x3D;&quot;detail.content&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n...\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.article-detail-container &#123;\n  .title &#123;\n    font-size: 22px;\n    text-align: center;\n    padding: 12px 0;\n  &#125;\n  .header &#123;\n    padding: 26px 0;\n    .author &#123;\n      font-size: 14px;\n      color: #555666;\n      margin-right: 20px;\n    &#125;\n    .time &#123;\n      font-size: 14px;\n      color: #999aaa;\n      margin-right: 20px;\n    &#125;\n    .edit &#123;\n      float: right;\n    &#125;\n  &#125;\n  .content &#123;\n    font-size: 14px;\n    padding: 20px 0;\n    border-top: 1px solid #d4d4d4;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n点击进入详情页面\n&#x2F;**\n * 查看按钮点击事件\n *&#x2F;\nconst router &#x3D; useRouter()\nconst onShowClick &#x3D; row &#x3D;&gt; &#123;\n  router.push(&#96;&#x2F;article&#x2F;$&#123;row._id&#125;&#96;)\n&#125;\n\n9-14：总结那么到这里我们整个的 动态表格 渲染的功能就算是全部完成了，整个 动态表格 功能围绕着：\n\n文章排名切换\n动态表格渲染\n\n这两个核心进行开发，整体的一个逻辑应该并不算复杂\n","slug":"vue3.2后台管理系统/09动态表格渲染方案之文章排名业务实现","date":"2022-08-22T19:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"afeb731b4a15e87120e5289a564db893","title":"08分级分控权限管理","content":"第八章：分级分控权限管理8-01：开篇那么从这一章开始我们就来解决我们的权限控制问题。\n本章以权限控制为主，整个章节会分成三部分来去讲解：\n\n权限理论：明确什么是 RBAC 权限控制体现\n辅助业务：完善 用户、角色、权限 三个页面功能\n核心功能：落地实现 RBAC 权限控制系统\n\n列举出来这三部分的目的是为了让大家能够对本章的内容有个清楚的认知，那么接下来我们就先来看第一部分 权限理论\n8-02：权限理论：RBAC 权限控制体系权限控制在开发中一直是一个比较复杂的问题，甚至有很多同学对什么是权限控制还不是很了解。所以我们需要先来统一一下认知，明确项目中的权限控制系统。\n在我们当前的项目中，我们可以通过：\n\n员工管理为用户指定角色\n通过角色列表为角色指定权限\n通过权限列表查看当前项目所有权限\n\n那么换句话而言，以上三条就制定了一个用户由：用户 -&gt; 角色 -&gt; 权限 的一个分配关系。\n当我们通过角色为某一个用户指定到不同的权限之后，那么该用户就会在 项目中体会到不同权限的功能\n那么这样的一套关系就是我们的 RBAC 权限控制体系，也就是 基于 角色的权限 控制 用户的访问\n通过以下图片可以很好的说明这种权限控制体系的含义：\n\n\n\n\n8-03：辅助业务：角色列表展示那么明确好了 RBAC 的概念之后，接下来我们就可以来去实现我们的辅助业务了，所谓辅助业务具体指的就是：\n\n员工管理（用户列表）\n为用户分配角色\n\n\n角色列表\n角色列表展示\n为角色分配权限\n\n\n权限列表\n权限列表展示\n\n\n\n那么这一小节我们就先来实现其中的 角色列表展示\n\n创建 api/role 接口文件：\nimport request from &#39;@&#x2F;utils&#x2F;request&#39;\n\n&#x2F;**\n * 获取所有角色\n *&#x2F;\nexport const roleList &#x3D; () &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;role&#x2F;list&#39;\n  &#125;)\n&#125;\n\n\n在 views/role-list 中获取数据\nimport &#123; roleList &#125; from &#39;@&#x2F;api&#x2F;role&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\nimport &#123; ref &#125; from &#39;vue&#39;\n\nconst allRoles &#x3D; ref([])\nconst getRoleList &#x3D; async () &#x3D;&gt; &#123;\n  allRoles.value &#x3D; await roleList()\n&#125;\ngetRoleList()\nwatchSwitchLang(getRoleList)\n\n通过 el-table 进行数据展示\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;\n    &lt;el-card&gt;\n      &lt;el-table :data&#x3D;&quot;allRoles&quot; border style&#x3D;&quot;width: 100%&quot;&gt;\n        &lt;el-table-column :label&#x3D;&quot;$t(&#39;msg.role.index&#39;)&quot; type&#x3D;&quot;index&quot; width&#x3D;&quot;120&quot;&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column :label&#x3D;&quot;$t(&#39;msg.role.name&#39;)&quot; prop&#x3D;&quot;title&quot;&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column :label&#x3D;&quot;$t(&#39;msg.role.desc&#39;)&quot; prop&#x3D;&quot;describe&quot;&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          :label&#x3D;&quot;$t(&#39;msg.role.action&#39;)&quot;\n          prop&#x3D;&quot;action&quot;\n          width&#x3D;&quot;260&quot;\n        &gt;\n          &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot;&gt;\n            &#123;&#123; $t(&#39;msg.role.assignPermissions&#39;) &#125;&#125;\n          &lt;&#x2F;el-button&gt;\n        &lt;&#x2F;el-table-column&gt;\n      &lt;&#x2F;el-table&gt;\n    &lt;&#x2F;el-card&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n8-04：辅助业务：权限列表展示\n创建 api/permission 文件\nimport request from &#39;@&#x2F;utils&#x2F;request&#39;\n\n&#x2F;**\n * 获取所有权限\n *&#x2F;\nexport const permissionList &#x3D; () &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;permission&#x2F;list&#39;\n  &#125;)\n&#125;\n\n\n在 views/permission-list 获取数据\n&lt;script setup&gt;\nimport &#123; permissionList &#125; from &#39;@&#x2F;api&#x2F;permission&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\nimport &#123; ref &#125; from &#39;vue&#39;\n&#x2F;**\n * 权限分级：\n * 1. 一级权限为页面权限\n *  permissionMark 对应 路由名称\n * 2. 二级权限为功能权限\n *  permissionMark 对应 功能权限表\n *&#x2F;\n&#x2F;&#x2F; 所有权限\nconst allPermission &#x3D; ref([])\nconst getPermissionList &#x3D; async () &#x3D;&gt; &#123;\n  allPermission.value &#x3D; await permissionList()\n&#125;\ngetPermissionList()\nwatchSwitchLang(getPermissionList)\n&lt;&#x2F;script&gt;\n\n通过 el-table 进行数据展示\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;\n    &lt;el-card&gt;\n      &lt;el-table\n        :data&#x3D;&quot;allPermission&quot;\n        style&#x3D;&quot;width: 100%; margin-bottom: 20px&quot;\n        row-key&#x3D;&quot;id&quot;\n        border\n        default-expand-all\n        :tree-props&#x3D;&quot;&#123; children: &#39;children&#39;, hasChildren: &#39;hasChildren&#39; &#125;&quot;\n      &gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;permissionName&quot;\n          :label&#x3D;&quot;$t(&#39;msg.permission.name&#39;)&quot;\n          width&#x3D;&quot;180&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;permissionMark&quot;\n          :label&#x3D;&quot;$t(&#39;msg.permission.mark&#39;)&quot;\n          width&#x3D;&quot;180&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;permissionDesc&quot;\n          :label&#x3D;&quot;$t(&#39;msg.permission.desc&#39;)&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n      &lt;&#x2F;el-table&gt;\n    &lt;&#x2F;el-card&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n8-05：辅助业务：为用户分配角色\n创建为用户分配角色弹出层 views/user-manage/components/roles\n&lt;template&gt;\n  &lt;el-dialog\n    :title&#x3D;&quot;$t(&#39;msg.excel.roleDialogTitle&#39;)&quot;\n    :model-value&#x3D;&quot;modelValue&quot;\n    @close&#x3D;&quot;closed&quot;\n  &gt;\n    内容\n\n    &lt;template #footer&gt;\n      &lt;span class&#x3D;&quot;dialog-footer&quot;&gt;\n        &lt;el-button @click&#x3D;&quot;closed&quot;&gt;&#123;&#123; $t(&#39;msg.universal.cancel&#39;) &#125;&#125;&lt;&#x2F;el-button&gt;\n        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onConfirm&quot;&gt;&#123;&#123;\n          $t(&#39;msg.universal.confirm&#39;)\n        &#125;&#125;&lt;&#x2F;el-button&gt;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; defineProps, defineEmits &#125; from &#39;vue&#39;\ndefineProps(&#123;\n  modelValue: &#123;\n    type: Boolean,\n    required: true\n  &#125;\n&#125;)\nconst emits &#x3D; defineEmits([&#39;update:modelValue&#39;])\n\n&#x2F;**\n  确定按钮点击事件\n *&#x2F;\nconst onConfirm &#x3D; async () &#x3D;&gt; &#123;\n  closed()\n&#125;\n\n&#x2F;**\n * 关闭\n *&#x2F;\nconst closed &#x3D; () &#x3D;&gt; &#123;\n  emits(&#39;update:modelValue&#39;, false)\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;\n\n\n在 user-manage 中点击查看，展示弹出层\n&lt;roles-dialog v-model&#x3D;&quot;roleDialogVisible&quot;&gt;&lt;&#x2F;roles-dialog&gt;\n\nimport RolesDialog from &#39;.&#x2F;components&#x2F;roles.vue&#39;\n\n&#x2F;**\n * 查看角色的点击事件\n *&#x2F;\nconst roleDialogVisible &#x3D; ref(false)\nconst onShowRoleClick &#x3D; row &#x3D;&gt; &#123;\n  roleDialogVisible.value &#x3D; true\n&#125;\n\n在弹出层中我们需要利用 el-checkbox 进行数据展示，此时数据分为两种：\n\n所有角色（已存在）\n用户当前角色\n\n\n所以我们需要先获取对应数据\n\n在 api/user-manage 中定义获取用户当前角色接口\n&#x2F;**\n * 获取指定用户角色\n *&#x2F;\nexport const userRoles &#x3D; (id) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#96;&#x2F;user-manage&#x2F;role&#x2F;$&#123;id&#125;&#96;\n  &#125;)\n&#125;\n\n在 roles 组件中获取所有角色数据\nimport &#123; defineProps, defineEmits, ref &#125; from &#39;vue&#39;\nimport &#123; roleList &#125; from &#39;@&#x2F;api&#x2F;role&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n...\n\n&#x2F;&#x2F; 所有角色\nconst allRoleList &#x3D; ref([])\n&#x2F;&#x2F; 获取所有角色数据的方法\nconst getListData &#x3D; async () &#x3D;&gt; &#123;\n  allRoleList.value &#x3D; await roleList()\n&#125;\ngetListData()\nwatchSwitchLang(getListData)\n\n&#x2F;&#x2F; 当前用户角色\nconst userRoleTitleList &#x3D; ref([])\n\n利用 el-checkbox 渲染所有角色\n&lt;el-checkbox-group v-model&#x3D;&quot;userRoleTitleList&quot;&gt;\n  &lt;el-checkbox\n    v-for&#x3D;&quot;item in allRoleList&quot;\n    :key&#x3D;&quot;item.id&quot;\n    :label&#x3D;&quot;item.title&quot;\n  &gt;&lt;&#x2F;el-checkbox&gt;\n&lt;&#x2F;el-checkbox-group&gt;\n\n接下来渲染选中项，即：用户当前角色\n\n调用 userRoles 接口需要 当前用户 ID，所以我们需要定义对应的 props\nconst props &#x3D; defineProps(&#123;\n  ...\n  userId: &#123;\n    type: String,\n    required: true\n  &#125;\n&#125;)\n\n接下来我们可以根据 userId 获取数据，但是这里大家要注意：因为该 userId 需要在 user-manage 用户点击之后获取当前点击行的 id。所以在 roles 组件的初始状态下，获取到的 userId 为 null 。 因此我们想要根据 userId 获取用户当前角色数据，我们需要 watch userId 在 userId 有值的前提下，获取数据\n&#x2F;&#x2F; 当前用户角色\nconst userRoleTitleList &#x3D; ref([])\n&#x2F;&#x2F; 获取当前用户角色\nconst getUserRoles &#x3D; async () &#x3D;&gt; &#123;\n  const res &#x3D; await userRoles(props.userId)\n  userRoleTitleList.value &#x3D; res.role.map(item &#x3D;&gt; item.title)\n&#125;\nwatch(\n  () &#x3D;&gt; props.userId,\n  val &#x3D;&gt; &#123;\n    if (val) getUserRoles()\n  &#125;\n)\n\n在 user-manage 中传递数据\n&lt;roles-dialog\n      v-model&#x3D;&quot;roleDialogVisible&quot;\n      :userId&#x3D;&quot;selectUserId&quot;\n    &gt;&lt;&#x2F;roles-dialog&gt;\n    \nconst selectUserId &#x3D; ref(&#39;&#39;)\nconst onShowRoleClick &#x3D; row &#x3D;&gt; &#123;\n  selectUserId.value &#x3D; row._id\n&#125;\n\n在 dialog 关闭时重置 selectUserId\n&#x2F;&#x2F; 保证每次打开重新获取用户角色数据\nwatch(roleDialogVisible, val &#x3D;&gt; &#123;\n  if (!val) selectUserId.value &#x3D; &#39;&#39;\n&#125;)\n\n在 api/user-manage 中定义分配角色接口\n&#x2F;**\n * 分用户分配角色\n *&#x2F;\nexport const updateRole &#x3D; (id, roles) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#96;&#x2F;user-manage&#x2F;update-role&#x2F;$&#123;id&#125;&#96;,\n    method: &#39;POST&#39;,\n    data: &#123;\n      roles\n    &#125;\n  &#125;)\n&#125;\n\n点击确定调用接口\n&#x2F;**\n  确定按钮点击事件\n *&#x2F;\nconst i18n &#x3D; useI18n()\nconst onConfirm &#x3D; async () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 处理数据结构\n  const roles &#x3D; userRoleTitleList.value.map(title &#x3D;&gt; &#123;\n    return allRoleList.value.find(role &#x3D;&gt; role.title &#x3D;&#x3D;&#x3D; title)\n  &#125;)\n\n  await updateRole(props.userId, roles)\n\n  ElMessage.success(i18n.t(&#39;msg.role.updateRoleSuccess&#39;))\n  closed()\n&#125;\n\n修改成功后，发送事件\nconst emits &#x3D; defineEmits([&#39;update:modelValue&#39;, &#39;updateRole&#39;])\n\nconst onConfirm &#x3D; async () &#x3D;&gt; &#123;\n  ...\n  &#x2F;&#x2F; 角色更新成功\n  emits(&#39;updateRole&#39;)\n&#125;\n\n在 user-manage 中监听角色更新成功事件，重新获取数据\n&lt;roles-dialog\n      v-model&#x3D;&quot;roleDialogVisible&quot;\n      :userId&#x3D;&quot;selectUserId&quot;\n      @updateRole&#x3D;&quot;getListData&quot;\n    &gt;&lt;&#x2F;roles-dialog&gt;\n\n8-06：辅助业务：为角色指定权限为角色指定权限通过 弹出层中的 树形控件 处理，整体的流程与上一小节相差无几。\n\n创建 为角色指定权限弹出层\n&lt;template&gt;\n  &lt;el-dialog\n    :title&#x3D;&quot;$t(&#39;msg.excel.roleDialogTitle&#39;)&quot;\n    :model-value&#x3D;&quot;modelValue&quot;\n    @close&#x3D;&quot;closed&quot;\n  &gt;\n    内容\n\n    &lt;template #footer&gt;\n      &lt;span class&#x3D;&quot;dialog-footer&quot;&gt;\n        &lt;el-button @click&#x3D;&quot;closed&quot;&gt;&#123;&#123; $t(&#39;msg.universal.cancel&#39;) &#125;&#125;&lt;&#x2F;el-button&gt;\n        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onConfirm&quot;&gt;&#123;&#123;\n          $t(&#39;msg.universal.confirm&#39;)\n        &#125;&#125;&lt;&#x2F;el-button&gt;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; defineProps, defineEmits &#125; from &#39;vue&#39;\ndefineProps(&#123;\n  modelValue: &#123;\n    type: Boolean,\n    required: true\n  &#125;\n&#125;)\nconst emits &#x3D; defineEmits([&#39;update:modelValue&#39;])\n\n&#x2F;**\n  确定按钮点击事件\n *&#x2F;\nconst onConfirm &#x3D; async () &#x3D;&gt; &#123;\n  closed()\n&#125;\n\n&#x2F;**\n * 关闭\n *&#x2F;\nconst closed &#x3D; () &#x3D;&gt; &#123;\n  emits(&#39;update:modelValue&#39;, false)\n&#125;\n&lt;&#x2F;script&gt;\n\n在 roles-list 中点击查看，展示弹出层\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;\n    &lt;el-card&gt;\n      &lt;el-table :data&#x3D;&quot;allRoles&quot; border style&#x3D;&quot;width: 100%&quot;&gt;\n        ...\n        &lt;el-table-column\n          ...\n          #default&#x3D;&quot;&#123; row &#125;&quot;\n        &gt;\n          &lt;el-button\n            type&#x3D;&quot;primary&quot;\n            size&#x3D;&quot;mini&quot;\n            @click&#x3D;&quot;onDistributePermissionClick(row)&quot;\n          &gt;\n            &#123;&#123; $t(&#39;msg.role.assignPermissions&#39;) &#125;&#125;\n          &lt;&#x2F;el-button&gt;\n        &lt;&#x2F;el-table-column&gt;\n      &lt;&#x2F;el-table&gt;\n    &lt;&#x2F;el-card&gt;\n\n    &lt;distribute-permission\n      v-model&#x3D;&quot;distributePermissionVisible&quot;\n    &gt;&lt;&#x2F;distribute-permission&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\n...\nimport DistributePermission from &#39;.&#x2F;components&#x2F;DistributePermission.vue&#39;\n\n...\n\n&#x2F;**\n * 分配权限\n *&#x2F;\nconst distributePermissionVisible &#x3D; ref(false)\nconst onDistributePermissionClick &#x3D; row &#x3D;&gt; &#123;\n  distributePermissionVisible.value &#x3D; true\n&#125;\n&lt;&#x2F;script&gt;\n\n\n在弹出层中我们需要利用 el-tree 进行数据展示，此时数据分为两种：\n\n所有权限（已存在）\n角色对应的权限\n\n\n所以我们需要先获取对应数据\n\n在 api/role 中定义获取角色当前权限\n&#x2F;**\n * 获取指定角色的权限\n *&#x2F;\nexport const rolePermission &#x3D; (roleId) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#96;&#x2F;role&#x2F;permission&#x2F;$&#123;roleId&#125;&#96;\n  &#125;)\n&#125;\n\n在 DistributePermission 组件中获取所有权限数据\n&lt;script setup&gt;\nimport &#123; defineProps, defineEmits, ref &#125; from &#39;vue&#39;\nimport &#123; permissionList &#125; from &#39;@&#x2F;api&#x2F;permission&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n...\n\n&#x2F;&#x2F; 所有权限\nconst allPermission &#x3D; ref([])\nconst getPermissionList &#x3D; async () &#x3D;&gt; &#123;\n  allPermission.value &#x3D; await permissionList()\n&#125;\ngetPermissionList()\nwatchSwitchLang(getPermissionList)\n\n...\n&lt;&#x2F;script&gt;\n\n使用  el-tree 渲染权限数据\n&lt;template&gt;\n  ...\n    &lt;el-tree\n      ref&#x3D;&quot;treeRef&quot;\n      :data&#x3D;&quot;allPermission&quot;\n      show-checkbox\n      check-strictly\n      node-key&#x3D;&quot;id&quot;\n      default-expand-all\n      :props&#x3D;&quot;defaultProps&quot;\n    &gt;\n    &lt;&#x2F;el-tree&gt;\n...\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\n...\n&#x2F;&#x2F; 属性结构配置\nconst defaultProps &#x3D; &#123;\n  children: &#39;children&#39;,\n  label: &#39;permissionName&#39;\n&#125;\n...\n&lt;&#x2F;script&gt;\n\n\n接下来渲染选中项，即：角色当前权限\n\n调用 rolePermission 接口需要 当前角色 ID，所以我们需要定义对应的 props\nconst props &#x3D; defineProps(&#123;\n  modelValue: &#123;\n    type: Boolean,\n    required: true\n  &#125;,\n  roleId: &#123;\n    type: String,\n    required: true\n  &#125;\n&#125;)\n\n在 role-list 中传递角色ID\n    &lt;distribute-permission\n      v-model&#x3D;&quot;distributePermissionVisible&quot;\n      :roleId&#x3D;&quot;selectRoleId&quot;\n    &gt;&lt;&#x2F;distribute-permission&gt;\n    \n    \n&#x2F;**\n * 分配权限\n *&#x2F;\nconst selectRoleId &#x3D; ref(&#39;&#39;)\nconst onDistributePermissionClick &#x3D; row &#x3D;&gt; &#123;\n  selectRoleId.value &#x3D; row.id\n&#125;\n\n调用 rolePermission 接口获取数据\nimport &#123; rolePermission &#125; from &#39;@&#x2F;api&#x2F;role&#39;\n\n\n&#x2F;&#x2F; 获取当前用户角色的权限\nconst getRolePermission &#x3D; async () &#x3D;&gt; &#123;\n  const checkedKeys &#x3D; await rolePermission(props.roleId)\n  console.log(checkedKeys)\n&#125;\n\nwatch(\n  () &#x3D;&gt; props.roleId,\n  val &#x3D;&gt; &#123;\n    if (val) getRolePermission()\n  &#125;\n)\n\n\n根据获取到的数据渲染选中的 tree\n&#x2F;&#x2F; tree 节点\nconst treeRef &#x3D; ref(null)\n\n&#x2F;&#x2F; 获取当前用户角色的权限\nconst getRolePermission &#x3D; async () &#x3D;&gt; &#123;\n  const checkedKeys &#x3D; await rolePermission(props.roleId)\n  treeRef.value.setCheckedKeys(checkedKeys)\n&#125;\n\n在 api/role 中定义分配权限接口\n&#x2F;**\n * 为角色修改权限\n *&#x2F;\nexport const distributePermission &#x3D; (data) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;role&#x2F;distribute-permission&#39;,\n    method: &#39;POST&#39;,\n    data\n  &#125;)\n&#125;\n\n\n点击确定调用接口\nimport &#123; rolePermission, distributePermission &#125; from &#39;@&#x2F;api&#x2F;role&#39;\nimport &#123; useI18n &#125; from &#39;vue-i18n&#39;\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\n\n&#x2F;**\n  确定按钮点击事件\n *&#x2F;\nconst i18n &#x3D; useI18n()\nconst onConfirm &#x3D; async () &#x3D;&gt; &#123;\n  await distributePermission(&#123;\n    roleId: props.roleId,\n    permissions: treeRef.value.getCheckedKeys()\n  &#125;)\n  ElMessage.success(i18n.t(&#39;msg.role.updateRoleSuccess&#39;))\n  closed()\n&#125;\n\n\n8-07：基于 RBAC 的权限控制体系原理与实现分析那么接下来就进入我们本章中的核心内容 基于 RBAC 的权限控制 ，在之前我们的 权限理论 这一小节的时候说过 RBAC 是基于 用户 -&gt; 角色 -&gt; 权限 的 基于 角色的权限 控制 用户的访问 的体系。\n在这套体系中，最基层的就是 权限部分 。那么这个权限部分在我们的项目中具体的呈现是什么呢？那么下面我们就来看一下：\n\n我们可以先为 员工角色 指定 空权限\n然后为我们的 测试用户 指定指定 员工角色\n此时我们重新登录 测试用户\n可以发现左侧菜单中仅存在 个人中心 页面\n然后我们重新登录 超级管理员 账号\n为 员工角色 指定 员工管理 &amp;&amp; 分配角色 权限\n然后为我们的 测试用户 指定指定 员工角色\n此时我们重新登录 测试用户\n可以发现左侧菜单中多出 员工管理 页面，并且页面中仅存在指定的 分配角色 功能\n\n以上就是我们权限系统中的具体呈现。\n那么由此呈现我们可以看出，整个权限系统其实分成了两部分：\n\n页面权限：比如 员工管理\n功能权限：比如 分配角色\n\n其中 页面权限 表示：当前用户可以访问的页面\n功能权限 表示：当前用户可以访问的权限功能（PS：并非所有功能有需要权限）\n那么明确好了以上内容之后，接下来我们来看下，以上功能如何进行实现呢？\n首先我们先来看 页面权限：\n所谓页面权限包含两部分内容：\n\n用户可看到的：左侧 menu 菜单的 item 展示\n用户看不到的：路由表配置\n\n我们知道 左侧 menu 菜单是根据路由表自动生成的。 所以以上第一部分的内容其实就是由第二部分引起的。\n那么我们就可以来看一下 路由表配置了。\n不知道大家还记不记得，之前我们设置路由表的时候，把路由表分成了两部分：\n\n私有路由表 privateRoutes：依据权限进行动态配置的\n公开路由表 publicRoutes：无权限要求的\n\n那么想要实现我们的  页面权限 核心的点就是在我们的 私有路由表 privateRoutes\n那么在 私有路由表 privateRoutes 这里我们能做什么呢？\n时刻记住我们最终的目的，我们期望的是：不同的权限进入系统可以看到不同的路由 。那么换句话而言是不是就是：根据不同的权限数据，生成不同的私有路由表？\n对于 vue-router 4 而言，提供了 addRoute API ，可以 动态添加路由到路由表中，那么我们就可以利用这个 API 生成不同的路由表数据。\n那么现在我们来总结一下以上所说的内容：\n\n页面权限实现的核心在于 路由表配置\n路由表配置的核心在于 私有路由表 privateRoutes\n私有路由表 privateRoutes 的核心在于 addRoute API\n\n那么简单一句话总结，我们只需要：**根据不同的权限数据，利用  addRoute API 生成不同的私有路由表 ** 即可实现 页面权限 功能\n那么接下来我们来明确  功能权限：\n 功能权限 的难度低于页面权限，所谓功能权限指的只有一点：\n\n根据不同的 权限数据，展示不同的 功能按钮\n\n那么看这一条，依据我们刚才所说的 页面权限 经验，估计大家就应该比较好理解了。\n对于 功能权限 而言，我们只需要：根据权限数据，隐藏功能按钮 即可\n那么到这里我们已经分析完了 页面权限 与 功能权限 \n那么接下来我们就可以分别来看一下两者的实现方案了。\n首先我们来看 页面权限：\n整个 页面权限 实现分为以下几步：\n\n获取 权限数据\n私有路由表 不再被直接加入到 routes 中\n利用 addRoute API 动态添加路由到 路由表 中\n\n接下来是 功能权限：\n整个 功能权限 实现分为以下几步：\n\n获取 权限数据\n定义 隐藏按钮方式（通过指令）\n依据数据隐藏按钮\n\n8-08：业务落地：定义页面权限控制动作，实现页面权限受控那么这一小节我们来实现 页面权限\n首先我们先来明确前两步的内容：\n\n页面权限数据在 userInfo -&gt; permission -&gt; menus 之中\n\n私有路由表 不再被直接加入到 routes 中\nexport const privateRoutes &#x3D; [...]\nexport const publicRoutes &#x3D; [...]\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHashHistory(),\n  routes: publicRoutes\n&#125;)\n\n最后我们来实现第三步：利用 addRoute API 动态添加路由到 路由表 中\n\n定义添加的动作，该动作我们通过一个新的 vuex 模块进行\n\n创建 store/modules/permission 模块\n&#x2F;&#x2F; 专门处理权限路由的模块\nimport &#123; publicRoutes, privateRoutes &#125; from &#39;@&#x2F;router&#39;\nexport default &#123;\n  namespaced: true,\n  state: &#123;\n    &#x2F;&#x2F; 路由表：初始拥有静态路由权限\n    routes: publicRoutes\n  &#125;,\n  mutations: &#123;\n    &#x2F;**\n     * 增加路由\n     *&#x2F;\n    setRoutes(state, newRoutes) &#123;\n      &#x2F;&#x2F; 永远在静态路由的基础上增加新路由\n      state.routes &#x3D; [...publicRoutes, ...newRoutes]\n    &#125;\n  &#125;,\n  actions: &#123;\n    &#x2F;**\n     * 根据权限筛选路由\n     *&#x2F;\n    filterRoutes(context, menus) &#123;\n    &#125;\n  &#125;\n&#125;\n\n\n那么 filterRoutes 这个动作我们怎么制作呢？\n\n我们可以为每个权限路由指定一个 name，每个 name 对应一个 页面权限\n\n通过 name 与 页面权限 匹配的方式筛选出对应的权限路由\n\n所以我们需要对现有的私有路由表进行重制\n\n创建 router/modules 文件夹\n\n写入 5 个页面权限路由\n\nUserManage.js\nimport layout from &#39;@&#x2F;layout&#39;\n\nexport default &#123;\n  path: &#39;&#x2F;user&#39;,\n  component: layout,\n  redirect: &#39;&#x2F;user&#x2F;manage&#39;,\n  name: &#39;userManage&#39;,\n  meta: &#123;\n    title: &#39;user&#39;,\n    icon: &#39;personnel&#39;\n  &#125;,\n  children: [\n    &#123;\n      path: &#39;&#x2F;user&#x2F;manage&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;user-manage&#x2F;index&#39;),\n      meta: &#123;\n        title: &#39;userManage&#39;,\n        icon: &#39;personnel-manage&#39;\n      &#125;\n    &#125;,\n    &#123;\n      path: &#39;&#x2F;user&#x2F;info&#x2F;:id&#39;,\n      name: &#39;userInfo&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;user-info&#x2F;index&#39;),\n      props: true,\n      meta: &#123;\n        title: &#39;userInfo&#39;\n      &#125;\n    &#125;,\n    &#123;\n      path: &#39;&#x2F;user&#x2F;import&#39;,\n      name: &#39;import&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;import&#x2F;index&#39;),\n      meta: &#123;\n        title: &#39;excelImport&#39;\n      &#125;\n    &#125;\n  ]\n&#125;\n\n\nRoleList.js\nimport layout from &#39;@&#x2F;layout&#39;\n\nexport default &#123;\n  path: &#39;&#x2F;user&#39;,\n  component: layout,\n  redirect: &#39;&#x2F;user&#x2F;manage&#39;,\n  name: &#39;roleList&#39;,\n  meta: &#123;\n    title: &#39;user&#39;,\n    icon: &#39;personnel&#39;\n  &#125;,\n  children: [\n    &#123;\n      path: &#39;&#x2F;user&#x2F;role&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;role-list&#x2F;index&#39;),\n      meta: &#123;\n        title: &#39;roleList&#39;,\n        icon: &#39;role&#39;\n      &#125;\n    &#125;\n  ]\n&#125;\n\n\nPermissionList.js\nimport layout from &#39;@&#x2F;layout&#39;\n\nexport default &#123;\n  path: &#39;&#x2F;user&#39;,\n  component: layout,\n  redirect: &#39;&#x2F;user&#x2F;manage&#39;,\n  name: &#39;roleList&#39;,\n  meta: &#123;\n    title: &#39;user&#39;,\n    icon: &#39;personnel&#39;\n  &#125;,\n  children: [\n    &#123;\n      path: &#39;&#x2F;user&#x2F;permission&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;permission-list&#x2F;index&#39;),\n      meta: &#123;\n        title: &#39;permissionList&#39;,\n        icon: &#39;permission&#39;\n      &#125;\n    &#125;\n  ]\n&#125;\n\n\nArticle.js\nimport layout from &#39;@&#x2F;layout&#39;\n\nexport default &#123;\n  path: &#39;&#x2F;article&#39;,\n  component: layout,\n  redirect: &#39;&#x2F;article&#x2F;ranking&#39;,\n  name: &#39;articleRanking&#39;,\n  meta: &#123; title: &#39;article&#39;, icon: &#39;article&#39; &#125;,\n  children: [\n    &#123;\n      path: &#39;&#x2F;article&#x2F;ranking&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;article-ranking&#x2F;index&#39;),\n      meta: &#123;\n        title: &#39;articleRanking&#39;,\n        icon: &#39;article-ranking&#39;\n      &#125;\n    &#125;,\n    &#123;\n      path: &#39;&#x2F;article&#x2F;:id&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;article-detail&#x2F;index&#39;),\n      meta: &#123;\n        title: &#39;articleDetail&#39;\n      &#125;\n    &#125;\n  ]\n&#125;\n\n\nArticleCreate.js\nimport layout from &#39;@&#x2F;layout&#39;\n\nexport default &#123;\n  path: &#39;&#x2F;article&#39;,\n  component: layout,\n  redirect: &#39;&#x2F;article&#x2F;ranking&#39;,\n  name: &#39;articleCreate&#39;,\n  meta: &#123; title: &#39;article&#39;, icon: &#39;article&#39; &#125;,\n  children: [\n    &#123;\n      path: &#39;&#x2F;article&#x2F;create&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;article-create&#x2F;index&#39;),\n      meta: &#123;\n        title: &#39;articleCreate&#39;,\n        icon: &#39;article-create&#39;\n      &#125;\n    &#125;,\n    &#123;\n      path: &#39;&#x2F;article&#x2F;editor&#x2F;:id&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;article-create&#x2F;index&#39;),\n      meta: &#123;\n        title: &#39;articleEditor&#39;\n      &#125;\n    &#125;\n  ]\n&#125;\n\n\n以上内容存放于 课程资料 -&gt; 动态路由表 中\n\n在 router/index 中合并这些路由到 privateRoutes 中\nimport ArticleCreaterRouter from &#39;.&#x2F;modules&#x2F;ArticleCreate&#39;\nimport ArticleRouter from &#39;.&#x2F;modules&#x2F;Article&#39;\nimport PermissionListRouter from &#39;.&#x2F;modules&#x2F;PermissionList&#39;\nimport RoleListRouter from &#39;.&#x2F;modules&#x2F;RoleList&#39;\nimport UserManageRouter from &#39;.&#x2F;modules&#x2F;UserManage&#39;\n\nexport const asyncRoutes &#x3D; [\n  RoleListRouter,\n  UserManageRouter,\n  PermissionListRouter,\n  ArticleCreaterRouter,\n  ArticleRouter\n]\n\n此时所有的 权限页面 都拥有一个名字，这个名字与 权限数据 匹配\n\n所以我们就可以据此生成 权限路由表数据\n&#x2F;**\n * 根据权限筛选路由\n *&#x2F;\nfilterRoutes(context, menus) &#123;\n  const routes &#x3D; []\n  &#x2F;&#x2F; 路由权限匹配\n  menus.forEach(key &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 权限名 与 路由的 name 匹配\n    routes.push(...privateRoutes.filter(item &#x3D;&gt; item.name &#x3D;&#x3D;&#x3D; key))\n  &#125;)\n  &#x2F;&#x2F; 最后添加 不匹配路由进入 404\n  routes.push(&#123;\n    path: &#39;&#x2F;:catchAll(.*)&#39;,\n    redirect: &#39;&#x2F;404&#39;\n  &#125;)\n  context.commit(&#39;setRoutes&#39;, routes)\n  return routes\n&#125;\n\n在 store/index 中设置该 modules\n...\nexport default createStore(&#123;\n  getters,\n  modules: &#123;\n    ...\n    permission\n  &#125;\n&#125;)\n\n\n\n\n在 src/permission 中，获取用户数据之后调用该动作\n&#x2F;&#x2F; 判断用户资料是否获取\n      &#x2F;&#x2F; 若不存在用户信息，则需要获取用户信息\n      if (!store.getters.hasUserInfo) &#123;\n        &#x2F;&#x2F; 触发获取用户信息的 action，并获取用户当前权限\n        const &#123; permission &#125; &#x3D; await store.dispatch(&#39;user&#x2F;getUserInfo&#39;)\n        &#x2F;&#x2F; 处理用户权限，筛选出需要添加的权限\n        const filterRoutes &#x3D; await store.dispatch(\n          &#39;permission&#x2F;filterRoutes&#39;,\n          permission.menus\n        )\n        &#x2F;&#x2F; 利用 addRoute 循环添加\n        filterRoutes.forEach(item &#x3D;&gt; &#123;\n          router.addRoute(item)\n        &#125;)\n        &#x2F;&#x2F; 添加完动态路由之后，需要在进行一次主动跳转\n        return next(to.path)\n      &#125;\n      next()\n\n因为我们主动获取了 getUserInfo 动作的返回值，所以不要忘记在 getUserInfo 中 return res\n\n\n那么到这里，当我们更换用户之后，刷新页面，路由表即可动态生成。\n但是此时大家应该可以发现，如果不刷新页面得话，左侧菜单是不会自动改变的？那么这是怎么回事呢？大家可以先思考一下这个问题，然后我们下一节再来处理。\n8-09：业务落地：重置路由表数据在上一小节中我们遇到了一个问题：重新登录权限账户，不刷新页面，左侧菜单不会自动改变。\n那么出现这个问题的原因其实非常简单：退出登录时，添加的路由表并未被删除\n所以想要解决这个问题，我们只需要在退出登录时，删除动态添加的路由表即可。\n那么删除动态添加的路由可以使用 removeRoute 方法进行。\n\n在 router/index 中定义 resetRouter 方法\n&#x2F;**\n * 初始化路由表\n *&#x2F;\nexport function resetRouter() &#123;\n  if (\n    store.getters.userInfo &amp;&amp;\n    store.getters.userInfo.permission &amp;&amp;\n    store.getters.userInfo.permission.menus\n  ) &#123;\n    const menus &#x3D; store.getters.userInfo.permission.menus\n    menus.forEach((menu) &#x3D;&gt; &#123;\n      router.removeRoute(menu)\n    &#125;)\n  &#125;\n\n在退出登录的动作下，触发该方法\nimport router, &#123; resetRouter &#125; from &#39;@&#x2F;router&#39;\n\nlogout(context) &#123;\n      resetRouter()\n      ...\n    &#125;\n\n8-10：业务落地：创建功能受控指令在前面分析 功能权限 时，我们说过，实现功能权限的核心在于 根据数据隐藏功能按钮，那么隐藏的方式我们可以通过指令进行。\n所以首先我们先去创建这样一个指令（vue3 自定义指令）\n\n我们期望最终可以通过这样格式的指令进行功能受控 v-permission=&quot;[&#39;importUser&#39;]&quot;\n\n以此创建对应的自定义指令 directives/permission\nimport store from &#39;@&#x2F;store&#39;\n\nfunction checkPermission(el, binding) &#123;\n  &#x2F;&#x2F; 获取绑定的值，此处为权限\n  const &#123; value &#125; &#x3D; binding\n  &#x2F;&#x2F; 获取所有的功能指令\n  const points &#x3D; store.getters.userInfo.permission.points\n  &#x2F;&#x2F; 当传入的指令集为数组时\n  if (value &amp;&amp; value instanceof Array) &#123;\n    &#x2F;&#x2F; 匹配对应的指令\n    const hasPermission &#x3D; points.some(point &#x3D;&gt; &#123;\n      return value.includes(point)\n    &#125;)\n    &#x2F;&#x2F; 如果无法匹配，则表示当前用户无该指令，那么删除对应的功能按钮\n    if (!hasPermission) &#123;\n      el.parentNode &amp;&amp; el.parentNode.removeChild(el)\n    &#125;\n  &#125; else &#123;\n    &#x2F;&#x2F; eslint-disabled-next-line\n    throw new Error(&#39;v-permission value is [&quot;admin&quot;,&quot;editor&quot;]&#39;)\n  &#125;\n&#125;\n\nexport default &#123;\n  &#x2F;&#x2F; 在绑定元素的父组件被挂载后调用\n  mounted(el, binding) &#123;\n    checkPermission(el, binding)\n  &#125;,\n  &#x2F;&#x2F; 在包含组件的 VNode 及其子组件的 VNode 更新后调用\n  update(el, binding) &#123;\n    checkPermission(el, binding)\n  &#125;\n&#125;\n\n\n在 directives/index 中绑定该指令\n...\nimport permission from &#39;.&#x2F;permission&#39;\n\nexport default (app) &#x3D;&gt; &#123;\n  ...\n  app.directive(&#39;permission&#39;, permission)\n&#125;\n\n\n在所有功能中，添加该指令\n\nviews/role-list/index\n&lt;el-button\n    ...\n    v-permission&#x3D;&quot;[&#39;distributePermission&#39;]&quot;\n&gt;\n&#123;&#123; $t(&#39;msg.role.assignPermissions&#39;) &#125;&#125;\n&lt;&#x2F;el-button&gt;\n\nviews/user-manage/index\n&lt;el-button\n    ...\n    v-permission&#x3D;&quot;[&#39;importUser&#39;]&quot;\n&gt;\n&#123;&#123; $t(&#39;msg.excel.importExcel&#39;) &#125;&#125;&lt;&#x2F;el-button\n        &gt;\n\n&lt;el-button\n    ...\n    v-permission&#x3D;&quot;[&#39;distributeRole&#39;]&quot;\n&gt;&#123;&#123; $t(&#39;msg.excel.showRole&#39;) &#125;&#125;&lt;&#x2F;el-button\n&gt;\n\n&lt;el-button\n    ...\n    v-permission&#x3D;&quot;[&#39;removeUser&#39;]&quot;\n&gt;&#123;&#123; $t(&#39;msg.excel.remove&#39;) &#125;&#125;&lt;&#x2F;el-button\n&gt;\n\n8-11：总结那么到这里我们整个权限受控的章节就算是全部完成了。\n整个这一大章中，核心就是 RBAC的权限受控体系 。围绕着 用户-&gt;角色-&gt;权限 的体系是现在在包含权限控制的系统中使用率最广的一种方式。\n那么怎么针对于权限控制的方案而言，除了课程中提到的这种方案之外，其实还有很多其他的方案，大家可以在我们的话题讨论中踊跃发言，多多讨论。\n","slug":"vue3.2后台管理系统/08分级分控权限管理","date":"2022-08-22T18:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"569348560a15d3e35abb58031a3aedf4","title":"07用户权限处理","content":"第七章：用户权限处理7-01：开篇在处理完成了 个人中心之后， 那么接下来我们就需要来处理 用户 相关的模块了\n整个用户相关的模块分为三部分：\n\n员工管理\n角色列表\n权限列表\n\n这三部分的内容我们会分成两个大章来进行处理。\n那么这一大章我们要来处理的就是 员工管理 模块的内容，整个 员工管理 模块可以分为以下功能：\n\n用户列表分页展示\nexcel 导入用户\n用户列表导出为 excel\n用户详情的表格展示\n用户详情表格打印\n用户删除\n用户角色分配（需要在完成角色列表之后处理）\n\n那么明确好了这样的内容之后，接下来我们就进入到  员工管理 模块的开发之中\n7-02：用户列表分页展示首先我们先来处理最基础的 用户列表分页展示 功能，整个功能大体可以分为两步：\n\n获取分页数据\n利用 el-table 和 el-pagination 渲染数据\n\n那么下面我们就根据这个步骤进行一个实现即可：\n\n创建 api/user-manage 文件，用于定义接口\nimport request from &#39;@&#x2F;utils&#x2F;request&#39;\n\n&#x2F;**\n * 获取用户列表数据\n *&#x2F;\nexport const getUserManageList &#x3D; data &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;user-manage&#x2F;list&#39;,\n    params: data\n  &#125;)\n&#125;\n\n\n在 user-manage 中获取对应数据\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nimport &#123; getUserManageList &#125; from &#39;@&#x2F;api&#x2F;user-manage&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n\n&#x2F;&#x2F; 数据相关\nconst tableData &#x3D; ref([])\nconst total &#x3D; ref(0)\nconst page &#x3D; ref(1)\nconst size &#x3D; ref(2)\n&#x2F;&#x2F; 获取数据的方法\nconst getListData &#x3D; async () &#x3D;&gt; &#123;\n  const result &#x3D; await getUserManageList(&#123;\n    page: page.value,\n    size: size.value\n  &#125;)\n  tableData.value &#x3D; result.list\n  total.value &#x3D; result.total\n&#125;\ngetListData()\n&#x2F;&#x2F; 监听语言切换\nwatchSwitchLang(getListData)\n&lt;&#x2F;script&gt;\n\n根据数据利用 el-table 和 el-pagination 渲染视图\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;user-manage-container&quot;&gt;\n    &lt;el-card class&#x3D;&quot;header&quot;&gt;\n      &lt;div&gt;\n        &lt;el-button type&#x3D;&quot;primary&quot;&gt; &#123;&#123; $t(&#39;msg.excel.importExcel&#39;) &#125;&#125;&lt;&#x2F;el-button&gt;\n        &lt;el-button type&#x3D;&quot;success&quot;&gt;\n          &#123;&#123; $t(&#39;msg.excel.exportExcel&#39;) &#125;&#125;\n        &lt;&#x2F;el-button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;el-card&gt;\n    &lt;el-card&gt;\n      &lt;el-table :data&#x3D;&quot;tableData&quot; border style&#x3D;&quot;width: 100%&quot;&gt;\n        &lt;el-table-column label&#x3D;&quot;#&quot; type&#x3D;&quot;index&quot; &#x2F;&gt;\n        &lt;el-table-column prop&#x3D;&quot;username&quot; :label&#x3D;&quot;$t(&#39;msg.excel.name&#39;)&quot;&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column prop&#x3D;&quot;mobile&quot; :label&#x3D;&quot;$t(&#39;msg.excel.mobile&#39;)&quot;&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column :label&#x3D;&quot;$t(&#39;msg.excel.avatar&#39;)&quot; align&#x3D;&quot;center&quot;&gt;\n          &lt;template v-slot&#x3D;&quot;&#123; row &#125;&quot;&gt;\n            &lt;el-image\n              class&#x3D;&quot;avatar&quot;\n              :src&#x3D;&quot;row.avatar&quot;\n              :preview-src-list&#x3D;&quot;[row.avatar]&quot;\n            &gt;&lt;&#x2F;el-image&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column :label&#x3D;&quot;$t(&#39;msg.excel.role&#39;)&quot;&gt;\n          &lt;template #default&#x3D;&quot;&#123; row &#125;&quot;&gt;\n            &lt;div v-if&#x3D;&quot;row.role &amp;&amp; row.role.length &gt; 0&quot;&gt;\n              &lt;el-tag v-for&#x3D;&quot;item in row.role&quot; :key&#x3D;&quot;item.id&quot; size&#x3D;&quot;mini&quot;&gt;&#123;&#123;\n                item.title\n              &#125;&#125;&lt;&#x2F;el-tag&gt;\n            &lt;&#x2F;div&gt;\n            &lt;div v-else&gt;\n              &lt;el-tag size&#x3D;&quot;mini&quot;&gt;&#123;&#123; $t(&#39;msg.excel.defaultRole&#39;) &#125;&#125;&lt;&#x2F;el-tag&gt;\n            &lt;&#x2F;div&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column prop&#x3D;&quot;openTime&quot; :label&#x3D;&quot;$t(&#39;msg.excel.openTime&#39;)&quot;&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          :label&#x3D;&quot;$t(&#39;msg.excel.action&#39;)&quot;\n          fixed&#x3D;&quot;right&quot;\n          width&#x3D;&quot;260&quot;\n        &gt;\n          &lt;template #default&gt;\n            &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot;&gt;&#123;&#123;\n              $t(&#39;msg.excel.show&#39;)\n            &#125;&#125;&lt;&#x2F;el-button&gt;\n            &lt;el-button type&#x3D;&quot;info&quot; size&#x3D;&quot;mini&quot;&gt;&#123;&#123;\n              $t(&#39;msg.excel.showRole&#39;)\n            &#125;&#125;&lt;&#x2F;el-button&gt;\n            &lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;mini&quot;&gt;&#123;&#123;\n              $t(&#39;msg.excel.remove&#39;)\n            &#125;&#125;&lt;&#x2F;el-button&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n      &lt;&#x2F;el-table&gt;\n\n      &lt;el-pagination\n        class&#x3D;&quot;pagination&quot;\n        @size-change&#x3D;&quot;handleSizeChange&quot;\n        @current-change&#x3D;&quot;handleCurrentChange&quot;\n        :current-page&#x3D;&quot;page&quot;\n        :page-sizes&#x3D;&quot;[2, 5, 10, 20]&quot;\n        :page-size&#x3D;&quot;size&quot;\n        layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot;\n        :total&#x3D;&quot;total&quot;\n      &gt;\n      &lt;&#x2F;el-pagination&gt;\n    &lt;&#x2F;el-card&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nimport &#123; getUserManageList &#125; from &#39;@&#x2F;api&#x2F;user-manage&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n\n&#x2F;&#x2F; 数据相关\nconst tableData &#x3D; ref([])\nconst total &#x3D; ref(0)\nconst page &#x3D; ref(1)\nconst size &#x3D; ref(2)\n&#x2F;&#x2F; 获取数据的方法\nconst getListData &#x3D; async () &#x3D;&gt; &#123;\n  const result &#x3D; await getUserManageList(&#123;\n    page: page.value,\n    size: size.value\n  &#125;)\n  tableData.value &#x3D; result.list\n  total.value &#x3D; result.total\n&#125;\ngetListData()\n&#x2F;&#x2F; 监听语言切换\nwatchSwitchLang(getListData)\n\n&#x2F;&#x2F; 分页相关\n&#x2F;**\n * size 改变触发\n *&#x2F;\nconst handleSizeChange &#x3D; currentSize &#x3D;&gt; &#123;\n  size.value &#x3D; currentSize\n  getListData()\n&#125;\n\n&#x2F;**\n * 页码改变触发\n *&#x2F;\nconst handleCurrentChange &#x3D; currentPage &#x3D;&gt; &#123;\n  page.value &#x3D; currentPage\n  getListData()\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.user-manage-container &#123;\n  .header &#123;\n    margin-bottom: 22px;\n    text-align: right;\n  &#125;\n  ::v-deep .avatar &#123;\n    width: 60px;\n    height: 60px;\n    border-radius: 50%;\n  &#125;\n\n  ::v-deep .el-tag &#123;\n    margin-right: 6px;\n  &#125;\n\n  .pagination &#123;\n    margin-top: 20px;\n    text-align: center;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n7-03：全局属性处理时间展示问题在 Vue3中取消了 过滤器的概念，其中：\n\n局部过滤器被完全删除\n全局过滤器虽然被移除，但是可以使用 全局属性 进行替代\n\n那么在列表中的时间处理部分，在 vue2 时代通常我们都是通过 全局过滤器 来进行实现的，所以在 vue3 中我们就顺理成章的通过  全局属性 替代实现\n\n时间处理部分我们通过 Day.js 进行处理\n\n下载 Day.js \nnpm i dayjs@1.10.6\n\n创建 src/filter 文件夹，用于定义 全局属性 \nimport dayjs from &#39;dayjs&#39;\n\nconst dateFilter &#x3D; (val, format &#x3D; &#39;YYYY-MM-DD&#39;) &#x3D;&gt; &#123;\n  if (!isNaN(val)) &#123;\n    val &#x3D; parseInt(val)\n  &#125;\n\n  return dayjs(val).format(format)\n&#125;\n\nexport default app &#x3D;&gt; &#123;\n  app.config.globalProperties.$filters &#x3D; &#123;\n    dateFilter\n  &#125;\n&#125;\n\n在 main.js 中导入\n&#x2F;&#x2F; filter\nimport installFilter from &#39;@&#x2F;filters&#39;\n\ninstallFilter(app)\n\n在 user-manage 中使用全局属性处理时间解析\n&lt;el-table-column :label&#x3D;&quot;$t(&#39;msg.excel.openTime&#39;)&quot;&gt;\n          &lt;template #default&#x3D;&quot;&#123; row &#125;&quot;&gt;\n            &#123;&#123; $filters.dateFilter(row.openTime) &#125;&#125;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n\n7-04：excel 导入原理与实现分析在处理完成这些基础的内容展示之后，接下来我们来看 excel 导入 功能\n对于 excel 导入 首先我们先来明确一下它的业务流程：\n\n点击  excel 导入 按钮进入  excel 导入页面\n页面提供了两种导入形式\n点击按钮上传 excel \n把 excel 拖入指定区域\n\n\n选中文件，进行两步操作\n解析 excel 数据\n上传解析之后的数据\n\n\n上传成功之后，返回 员工管理（用户列表） 页面，进行数据展示\n\n所以根据这个业务我们可以看出，整个 excel 导入核心的原理部分在于 选中文件之后，上传成功之前 的操作，即：\n\n解析 excel 数据（最重要）\n上传解析之后的数据\n\n对于解析部分，我们回头再去详细说明，在这里我们只需要明确大的实现流程即可。\n根据上面所说，整个的实现流程我们也可以很轻松得出：\n\n创建 excel 导入页面\n点击 excel 导入按钮，进入该页面\n该页面提供两种文件导入形式\n选中文件之后，解析 excel 数据（核心）\n上传解析之后的数据\n返回 员工管理（用户列表） 页面\n\n那么明确好了这样的流程之后，接下来我们就可以实现对应的代码了。\n7-05：业务落地：提供两种文件导入形式 excel 页面我们在之前已经创建过了，就是 views/import/index 。\n所以此处，我们只需要在按钮处完成页面跳转即可，在 user-manage 中：\n&lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onImportExcelClick&quot;&gt;\n          &#123;&#123; $t(&#39;msg.excel.importExcel&#39;) &#125;&#125;&lt;&#x2F;el-button\n        &gt;\n\nconst router &#x3D; useRouter()\n&#x2F;**\n * excel 导入点击事件\n *&#x2F;\nconst onImportExcelClick &#x3D; () &#x3D;&gt; &#123;\n  router.push(&#39;&#x2F;user&#x2F;import&#39;)\n&#125;\n\n这样我们就已经完成了前面两步，那么接下来我们就来实现 提供两种文件导入形式\n\n创建 components/UploadExcel 组件，用于处理上传 excel 相关的问题\n\n在 import 中导入该组件\n&lt;template&gt;\n  &lt;upload-excel&gt;&lt;&#x2F;upload-excel&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport UploadExcel from &#39;@&#x2F;components&#x2F;UploadExcel&#39;\n&lt;&#x2F;script&gt;\n\n整个 UploadExcel 组件的内容可以分成两部分：\n\n样式\n逻辑\n\n\n那么首先我们先处理样式内容\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;upload-excel&quot;&gt;\n    &lt;div class&#x3D;&quot;btn-upload&quot;&gt;\n      &lt;el-button :loading&#x3D;&quot;loading&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;handleUpload&quot;&gt;\n        &#123;&#123; $t(&#39;msg.uploadExcel.upload&#39;) &#125;&#125;\n      &lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;input\n      ref&#x3D;&quot;excelUploadInput&quot;\n      class&#x3D;&quot;excel-upload-input&quot;\n      type&#x3D;&quot;file&quot;\n      accept&#x3D;&quot;.xlsx, .xls&quot;\n      @change&#x3D;&quot;handleChange&quot;\n    &#x2F;&gt;\n    &lt;!-- https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;HTML_Drag_and_Drop_API --&gt;\n    &lt;div\n      class&#x3D;&quot;drop&quot;\n      @drop.stop.prevent&#x3D;&quot;handleDrop&quot;\n      @dragover.stop.prevent&#x3D;&quot;handleDragover&quot;\n      @dragenter.stop.prevent&#x3D;&quot;handleDragover&quot;\n    &gt;\n      &lt;i class&#x3D;&quot;el-icon-upload&quot; &#x2F;&gt;\n      &lt;span&gt;&#123;&#123; $t(&#39;msg.uploadExcel.drop&#39;) &#125;&#125;&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.upload-excel &#123;\n  display: flex;\n  justify-content: center;\n  margin-top: 100px;\n  .excel-upload-input &#123;\n    display: none;\n    z-index: -9999;\n  &#125;\n  .btn-upload,\n  .drop &#123;\n    border: 1px dashed #bbb;\n    width: 350px;\n    height: 160px;\n    text-align: center;\n    line-height: 160px;\n  &#125;\n  .drop &#123;\n    line-height: 60px;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    color: #bbb;\n    i &#123;\n      font-size: 60px;\n      display: block;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n7-06：业务落地：文件选择之后的数据解析处理那么接下来我们来处理整个业务中最核心的一块内容 选中文件之后，解析 excel 数据 \n解析的方式根据我们的导入形式的不同也可以分为两种：\n\n文件选择（选择隐藏域）导入\n文件拖拽导入\n\n那么这一小节，我们先来处理第一种。\n处理之前我们需要先来做一件事情：\n\n解析 excel 数据我们需要使用 xlsx ，所以我们需要先下载它\nnpm i xlsx@0.17.0\n\n xlsx 安装完成之后，接下来我们就可以来去实现对应代码了：\n&lt;script setup&gt;\nimport XLSX from &#39;xlsx&#39;\nimport &#123; defineProps, ref &#125; from &#39;vue&#39;\nimport &#123; getHeaderRow &#125; from &#39;.&#x2F;utils&#39;\n\nconst props &#x3D; defineProps(&#123;\n  &#x2F;&#x2F; 上传前回调\n  beforeUpload: Function,\n  &#x2F;&#x2F; 成功回调\n  onSuccess: Function\n&#125;)\n\n&#x2F;**\n * 点击上传触发\n *&#x2F;\nconst loading &#x3D; ref(false)\nconst excelUploadInput &#x3D; ref(null)\nconst handleUpload &#x3D; () &#x3D;&gt; &#123;\n  excelUploadInput.value.click()\n&#125;\nconst handleChange &#x3D; e &#x3D;&gt; &#123;\n  const files &#x3D; e.target.files\n  const rawFile &#x3D; files[0] &#x2F;&#x2F; only use files[0]\n  if (!rawFile) return\n  upload(rawFile)\n&#125;\n\n&#x2F;**\n * 触发上传事件\n *&#x2F;\nconst upload &#x3D; rawFile &#x3D;&gt; &#123;\n  excelUploadInput.value.value &#x3D; null\n  &#x2F;&#x2F; 如果没有指定上传前回调的话\n  if (!props.beforeUpload) &#123;\n    readerData(rawFile)\n    return\n  &#125;\n  &#x2F;&#x2F; 如果指定了上传前回调，那么只有返回 true 才会执行后续操作\n  const before &#x3D; props.beforeUpload(rawFile)\n  if (before) &#123;\n    readerData(rawFile)\n  &#125;\n&#125;\n\n&#x2F;**\n * 读取数据（异步）\n *&#x2F;\nconst readerData &#x3D; rawFile &#x3D;&gt; &#123;\n  loading.value &#x3D; true\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;FileReader\n    const reader &#x3D; new FileReader()\n    &#x2F;&#x2F; 该事件在读取操作完成时触发\n    &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;FileReader&#x2F;onload\n    reader.onload &#x3D; e &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 1. 获取解析到的数据\n      const data &#x3D; e.target.result\n      &#x2F;&#x2F; 2. 利用 XLSX 对数据进行解析\n      const workbook &#x3D; XLSX.read(data, &#123; type: &#39;array&#39; &#125;)\n      &#x2F;&#x2F; 3. 获取第一张表格(工作簿)名称\n      const firstSheetName &#x3D; workbook.SheetNames[0]\n      &#x2F;&#x2F; 4. 只读取 Sheet1（第一张表格）的数据\n      const worksheet &#x3D; workbook.Sheets[firstSheetName]\n      &#x2F;&#x2F; 5. 解析数据表头\n      const header &#x3D; getHeaderRow(worksheet)\n      &#x2F;&#x2F; 6. 解析数据体\n      const results &#x3D; XLSX.utils.sheet_to_json(worksheet)\n      &#x2F;&#x2F; 7. 传入解析之后的数据\n      generateData(&#123; header, results &#125;)\n      &#x2F;&#x2F; 8. loading 处理\n      loading.value &#x3D; false\n      &#x2F;&#x2F; 9. 异步完成\n      resolve()\n    &#125;\n    &#x2F;&#x2F; 启动读取指定的 Blob 或 File 内容\n    reader.readAsArrayBuffer(rawFile)\n  &#125;)\n&#125;\n\n&#x2F;**\n * 根据导入内容，生成数据\n *&#x2F;\nconst generateData &#x3D; excelData &#x3D;&gt; &#123;\n  props.onSuccess &amp;&amp; props.onSuccess(excelData)\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\ngetHeaderRow 为 xlsx 解析表头数据的通用方法，直接使用即可\nimport XLSX from &#39;xlsx&#39;\n&#x2F;**\n * 获取表头（通用方式）\n *&#x2F;\nexport const getHeaderRow &#x3D; sheet &#x3D;&gt; &#123;\n  const headers &#x3D; []\n  const range &#x3D; XLSX.utils.decode_range(sheet[&#39;!ref&#39;])\n  let C\n  const R &#x3D; range.s.r\n  &#x2F;* start in the first row *&#x2F;\n  for (C &#x3D; range.s.c; C &lt;&#x3D; range.e.c; ++C) &#123;\n    &#x2F;* walk every column in the range *&#x2F;\n    const cell &#x3D; sheet[XLSX.utils.encode_cell(&#123; c: C, r: R &#125;)]\n    &#x2F;* find the cell in the first row *&#x2F;\n    let hdr &#x3D; &#39;UNKNOWN &#39; + C &#x2F;&#x2F; &lt;-- replace with your desired default\n    if (cell &amp;&amp; cell.t) hdr &#x3D; XLSX.utils.format_cell(cell)\n    headers.push(hdr)\n  &#125;\n  return headers\n&#125;\n\n\n在 import 组件中传入 onSuccess 事件，获取解析成功之后的 excel 数据\n&lt;template&gt;\n  &lt;upload-excel :onSuccess&#x3D;&quot;onSuccess&quot;&gt;&lt;&#x2F;upload-excel&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport UploadExcel from &#39;@&#x2F;components&#x2F;UploadExcel&#39;\n\n&#x2F;**\n * 数据解析成功之后的回调\n *&#x2F;\nconst onSuccess &#x3D; excelData &#x3D;&gt; &#123;\n  console.log(excelData)\n&#125;\n&lt;&#x2F;script&gt;、\n\n\n\n\n7-07：业务落地：文件拖入之后的数据解析处理想要了解 文件拖入，那么我们就必须要先能够了解 HTML_Drag_and_Drop（HTML 拖放 API） 事件，我们这里主要使用到其中三个事件：\n\ndrop (en-US)：当元素或选中的文本在可释放目标上被释放时触发\ndragover (en-US)：当元素或选中的文本被拖到一个可释放目标上时触发\ndragenter (en-US)：当拖拽元素或选中的文本到一个可释放目标时触发\n\n那么明确好了这三个事件之后，我们就可以实现对应的拖入代码逻辑了\n&lt;script setup&gt;\n...\nimport &#123; getHeaderRow, isExcel &#125; from &#39;.&#x2F;utils&#39;\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\n\n...\n&#x2F;**\n * 拖拽文本释放时触发\n *&#x2F;\nconst handleDrop &#x3D; e &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 上传中跳过\n  if (loading.value) return\n  const files &#x3D; e.dataTransfer.files\n  if (files.length !&#x3D;&#x3D; 1) &#123;\n    ElMessage.error(&#39;必须要有一个文件&#39;)\n    return\n  &#125;\n  const rawFile &#x3D; files[0]\n  if (!isExcel(rawFile)) &#123;\n    ElMessage.error(&#39;文件必须是 .xlsx, .xls, .csv 格式&#39;)\n    return false\n  &#125;\n  &#x2F;&#x2F; 触发上传事件\n  upload(rawFile)\n&#125;\n\n&#x2F;**\n * 拖拽悬停时触发\n *&#x2F;\nconst handleDragover &#x3D; e &#x3D;&gt; &#123;\n  &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;DataTransfer&#x2F;dropEffect\n  &#x2F;&#x2F; 在新位置生成源项的副本\n  e.dataTransfer.dropEffect &#x3D; &#39;copy&#39;\n&#125;\n\n。。。\n&lt;&#x2F;script&gt;\n\n在 utils 中生成 isExcel 方法\nexport const isExcel &#x3D; file &#x3D;&gt; &#123;\n  return &#x2F;\\.(xlsx|xls|csv)$&#x2F;.test(file.name)\n&#125;\n\n\n\n7-08：业务落地：传递解析后的 excel 数据那么到现在我们已经处理好了 excel 的数据解析操作。\n接下来就可以实现对应的数据上传，完成 excel 导入功能了\n\n定义 api/user-manage 上传接口\n&#x2F;**\n * 批量导入\n *&#x2F;\nexport const userBatchImport &#x3D; (data) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;user-manage&#x2F;batch&#x2F;import&#39;,\n    method: &#39;POST&#39;,\n    data\n  &#125;)\n&#125;\n\n在 onSuccess 中调用接口上传数据，但是此处大家要注意两点内容：\n\nheader 头不需要上传\nresults 中 key 为中文，我们必须要按照接口要求进行上传\n\n\n所以我们需要处理 results 中的数据结构\n\n创建 import/utils 文件\n&#x2F;**\n * 导入数据对应表\n *&#x2F;\nexport const USER_RELATIONS &#x3D; &#123;\n  姓名: &#39;username&#39;,\n  联系方式: &#39;mobile&#39;,\n  角色: &#39;role&#39;,\n  开通时间: &#39;openTime&#39;\n&#125;\n\n\n创建数据解析方法，生成新数组\n&#x2F;**\n * 筛选数据\n *&#x2F;\nconst generateData &#x3D; results &#x3D;&gt; &#123;\n  const arr &#x3D; []\n  results.forEach(item &#x3D;&gt; &#123;\n    const userInfo &#x3D; &#123;&#125;\n    Object.keys(item).forEach(key &#x3D;&gt; &#123;\n      userInfo[USER_RELATIONS[key]] &#x3D; item[key]\n    &#125;)\n    arr.push(userInfo)\n  &#125;)\n  return arr\n&#125;\n\n完成数据上传即可\n&#x2F;**\n * 数据解析成功之后的回调\n *&#x2F;\nconst onSuccess &#x3D; async (&#123; header, results &#125;) &#x3D;&gt; &#123;\n  const updateData &#x3D; generateData(results)\n  await userBatchImport(updateData)\n  ElMessage.success(&#123;\n    message: results.length + i18n.t(&#39;msg.excel.importSuccess&#39;),\n    type: &#39;success&#39;\n  &#125;)\n  router.push(&#39;&#x2F;user&#x2F;manage&#39;)\n&#125;\n\n7-09：业务落地：处理剩余 bug截止到目前整个 excel 上传我们就已经处理完成了，只不过目前还存在两个小 bug 需要处理：\n\n上传之后的时间解析错误\n返回用户列表之后，数据不会自动刷新\n\n那么这一小节我们就针对这两个问题进行分别处理\n上传之后的时间解析错误：\n导致该问题出现的原因是因为 excel 导入解析时间会出现错误， 处理的方案也很简单，是一个固定方案，我们只需要进行固定的时间解析处理即可：\n\n在 import/utils 中新增事件处理方法（固定方式直接使用即可）\n&#x2F;**\n * 解析 excel 导入的时间格式\n *&#x2F;\nexport const formatDate &#x3D; (numb) &#x3D;&gt; &#123;\n  const time &#x3D; new Date((numb - 1) * 24 * 3600000 + 1)\n  time.setYear(time.getFullYear() - 70)\n  const year &#x3D; time.getFullYear() + &#39;&#39;\n  const month &#x3D; time.getMonth() + 1 + &#39;&#39;\n  const date &#x3D; time.getDate() - 1 + &#39;&#39;\n  return (\n    year +\n    &#39;-&#39; +\n    (month &lt; 10 ? &#39;0&#39; + month : month) +\n    &#39;-&#39; +\n    (date &lt; 10 ? &#39;0&#39; + date : date)\n  )\n&#125;\n\n\n在 generateData 中针对 openTime 进行单独处理\n&#x2F;**\n * 筛选数据\n *&#x2F;\nconst generateData &#x3D; results &#x3D;&gt; &#123;\n  ...\n    Object.keys(item).forEach(key &#x3D;&gt; &#123;\n      if (USER_RELATIONS[key] &#x3D;&#x3D;&#x3D; &#39;openTime&#39;) &#123;\n        userInfo[USER_RELATIONS[key]] &#x3D; formatDate(item[key])\n        return\n      &#125;\n      userInfo[USER_RELATIONS[key]] &#x3D; item[key]\n    &#125;)\n    ...\n  &#125;)\n  return arr\n&#125;\n\n返回用户列表之后，数据不会自动刷新：\n出现该问题的原因是因为：**appmain 中使用 keepAlive 进行了组件缓存**。\n解决的方案也很简单，只需要：监听 onActivated 事件，重新获取数据即可 \n在 user-manage 中：\nimport &#123; ref, onActivated &#125; from &#39;vue&#39;\n\n&#x2F;&#x2F; 处理导入用户后数据不重新加载的问题\nonActivated(getListData)\n\n\n\n7-10：excel 导入功能总结那么到这里我们的 excel 导入功能我们就已经实现完成了，再来回顾一下我们整体的流程：\n\n创建 excel 导入页面\n点击 excel 导入按钮，进入该页面\n该页面提供两种文件导入形式\n选中文件之后，解析 excel 数据（核心）\n上传解析之后的数据\n返回 员工管理（用户列表） 页面\n\n游离于这些流程之外的，还包括额外的两个小 bug 的处理，特别是 excel 的时间格式问题， 大家要格外注意，因为这是一个必然会出现的错误，当然处理方案也是固定的。\n7-11：辅助业务之用户删除完成了 excel 的用户导入之后，那么我们肯定会产生很多的无用数据，所以说接下来我们来完成一个辅助功能：删除用户（希望大家都可以在完成 excel 导入功能之后，删除掉无用数据，以方便其他的同学进行功能测试）\n删除用户的功能比较简单，我们只需要 调用对应的接口即可\n\n在 api/user-manage 中指定删除接口\n&#x2F;**\n * 删除指定数据\n *&#x2F;\nexport const deleteUser &#x3D; (id) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#96;&#x2F;user-manage&#x2F;detele&#x2F;$&#123;id&#125;&#96;\n  &#125;)\n&#125;\n\n在 views/user-manage 中调用删除接口接口\n&lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;onRemoveClick(row)&quot;&gt;&#123;&#123;\n              $t(&#39;msg.excel.remove&#39;)\n            &#125;&#125;&lt;&#x2F;el-button&gt;\n\n&#x2F;**\n * 删除按钮点击事件\n *&#x2F;\nconst i18n &#x3D; useI18n()\nconst onRemoveClick &#x3D; row &#x3D;&gt; &#123;\n  ElMessageBox.confirm(\n    i18n.t(&#39;msg.excel.dialogTitle1&#39;) +\n      row.username +\n      i18n.t(&#39;msg.excel.dialogTitle2&#39;),\n    &#123;\n      type: &#39;warning&#39;\n    &#125;\n  ).then(async () &#x3D;&gt; &#123;\n    await deleteUser(row._id)\n    ElMessage.success(i18n.t(&#39;msg.excel.removeSuccess&#39;))\n    &#x2F;&#x2F; 重新渲染数据\n    getListData()\n  &#125;)\n&#125;\n\n7-12：excel 导出原理与实现分析对于 excel 导出而言我们还是先来分析一下它的业务逻辑：\n\n点击 excel 导出按钮\n展示 dialog 弹出层\n确定导出的 excel 文件名称\n点击导出按钮\n获取 所有用户列表数据\n将 json 结构数据转化为 excel 数据，并下载\n\n有了 excel 导入的经验之后，再来看这样的一套业务逻辑，相信大家应该可以直接根据这样的一套业务逻辑得出 excel 导出的核心原理了：将 json 结构数据转化为 excel 数据，并下载\n那么我们对应的实现方案也可以直接得出了：\n\n创建 excel 导出弹出层\n处理弹出层相关的业务\n点击导出按钮，将 json 结构数据转化为 excel 数据，并下载（核心）\n\n7-13：业务落地：Export2Excel 组件那么首先我们先去创建 excel 弹出层组件 Export2Excel \n\n创建 views/user-manage/components/Export2Excel \n&lt;template&gt;\n  &lt;el-dialog\n    :title&#x3D;&quot;$t(&#39;msg.excel.title&#39;)&quot;\n    :model-value&#x3D;&quot;modelValue&quot;\n    @close&#x3D;&quot;closed&quot;\n    width&#x3D;&quot;30%&quot;\n  &gt;\n    &lt;el-input\n      :placeholder&#x3D;&quot;$t(&#39;msg.excel.placeholder&#39;)&quot;\n    &gt;&lt;&#x2F;el-input&gt;\n    &lt;template #footer&gt;\n      &lt;span class&#x3D;&quot;dialog-footer&quot;&gt;\n        &lt;el-button @click&#x3D;&quot;closed&quot;&gt;&#123;&#123; $t(&#39;msg.excel.close&#39;) &#125;&#125;&lt;&#x2F;el-button&gt;\n        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onConfirm&quot;&gt;&#123;&#123;\n          $t(&#39;msg.excel.confirm&#39;)\n        &#125;&#125;&lt;&#x2F;el-button&gt;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; defineProps, defineEmits &#125; from &#39;vue&#39;\n\ndefineProps(&#123;\n  modelValue: &#123;\n    type: Boolean,\n    required: true\n  &#125;\n&#125;)\nconst emits &#x3D; defineEmits([&#39;update:modelValue&#39;])\n\n&#x2F;**\n * 导出按钮点击事件\n *&#x2F;\nconst onConfirm &#x3D; async () &#x3D;&gt; &#123;\n  closed()\n&#125;\n\n&#x2F;**\n * 关闭\n *&#x2F;\nconst closed &#x3D; () &#x3D;&gt; &#123;\n  emits(&#39;update:modelValue&#39;, false)\n&#125;\n&lt;&#x2F;script&gt;\n\n\n在 user-manage 中进行导入 dialog 组件\n\n指定 excel按钮 点击事件\n&lt;el-button type&#x3D;&quot;success&quot; @click&#x3D;&quot;onToExcelClick&quot;&gt;\n\t&#123;&#123; $t(&#39;msg.excel.exportExcel&#39;) &#125;&#125;\n&lt;&#x2F;el-button&gt;\n\n导入 ExportToExcel 组件\n&lt;export-to-excel v-model&#x3D;&quot;exportToExcelVisible&quot;&gt;&lt;&#x2F;export-to-excel&gt;\nimport ExportToExcel from &#39;.&#x2F;components&#x2F;Export2Excel.vue&#39;\n\n点击事件处理函数\n&#x2F;**\n * excel 导出点击事件\n *&#x2F;\nconst exportToExcelVisible &#x3D; ref(false)\nconst onToExcelClick &#x3D; () &#x3D;&gt; &#123;\n  exportToExcelVisible.value &#x3D; true\n&#125;\n\n\n\n7-14：业务落地：导出前置业务处理那么这一小节我们来处理一些实现 excel 导出时的前置任务，具体有：\n\n指定 input 默认导出文件名称\n定义 获取全部用户 列表接口，并调用\n\n那么下面我们先来处理第一步：指定 input 默认导出文件名称\n\n指定 input 的双向绑定\n&lt;el-input\n      v-model&#x3D;&quot;excelName&quot;\n      :placeholder&#x3D;&quot;$t(&#39;msg.excel.placeholder&#39;)&quot;\n    &gt;&lt;&#x2F;el-input&gt;\n\n指定默认文件名\nconst i18n &#x3D; useI18n()\nlet exportDefaultName &#x3D; i18n.t(&#39;msg.excel.defaultName&#39;)\nconst excelName &#x3D; ref(&#39;&#39;)\nexcelName.value &#x3D; exportDefaultName\nwatchSwitchLang(() &#x3D;&gt; &#123;\n  exportDefaultName &#x3D; i18n.t(&#39;msg.excel.defaultName&#39;)\n  excelName.value &#x3D; exportDefaultName\n&#125;)\n\n定义获取全部用户列表接口，并调用：\n\n在 user-manage 中定义获取全部数据接口\n&#x2F;**\n * 获取所有用户列表数据\n *&#x2F;\nexport const getUserManageAllList &#x3D; () &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;user-manage&#x2F;all-list&#39;\n  &#125;)\n&#125;\n\n调用接口数据，并指定 loading\n&lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onConfirm&quot; :loading&#x3D;&quot;loading&quot;&gt;&#123;&#123;\n\t$t(&#39;msg.excel.confirm&#39;)\n&#125;&#125;&lt;&#x2F;el-button&gt;\n\n\n\nimport &#123; getUserManageAllList &#125; from &#39;@&#x2F;api&#x2F;user-manage&#39;\n\n&#x2F;**\n * 导出按钮点击事件\n *&#x2F;\nconst loading &#x3D; ref(false)\nconst onConfirm &#x3D; async () &#x3D;&gt; &#123;\n  loading.value &#x3D; true\n  const allUser &#x3D; (await getUserManageAllList()).list\n\n  closed()\n&#125;\n\n&#x2F;**\n * 关闭\n *&#x2F;\nconst closed &#x3D; () &#x3D;&gt; &#123;\n  loading.value &#x3D; false\n  emits(&#39;update:modelValue&#39;, false)\n&#125;\n\n7-15：业务落地：实现 excel 导出逻辑那么万事俱备，到此时我们就可以来实现整个业务逻辑的最后步骤：\n\n将 json 结构数据转化为 excel 数据\n下载对应的 excel 数据\n\n对于这两步的逻辑而言，最复杂的莫过于 将 json 结构数据转化为 excel 数据 这一步的功能，不过万幸的是对于该操作的逻辑是 通用处理逻辑，搜索 Export2Excel 我们可以得到巨多的解决方案，所以此处我们 没有必要 手写对应的转换逻辑\n该转化逻辑我已经把它放置到 课程资料/Export2Excel.js 文件中，大家可以直接把该代码复制到 utils 文件夹下\n\n\n\n\n\n\n\n\n\nPS：如果大家想要了解该代码的话，那么对应的业务逻辑我们也已经全部标出，大家可以直接查看\n那么有了 Export2Excel.js 的代码之后 ，接下来我们还需要导入两个依赖库：\n\nxlsx （已下载）：excel 解析器和编译器\nfile-saver：文件下载工具，通过 npm i file-saver@2.0.5 下载\n\n那么一切准备就绪，我们去实现 excel 导出功能：\n\n动态导入 Export2Excel.js \n&#x2F;&#x2F; 导入工具包\n  const excel &#x3D; await import(&#39;@&#x2F;utils&#x2F;Export2Excel&#39;)\n\n因为从服务端获取到的为 json 数组对象 结构，但是导出时的数据需要为 二维数组，所以我们需要有一个方法来把 json 结构转化为 二维数组\n\n创建转化方法\n\n创建 views/user-manage/components/Export2ExcelConstants.js 中英文对照表\n&#x2F;**\n * 导入数据对应表\n *&#x2F;\nexport const USER_RELATIONS &#x3D; &#123;\n  姓名: &#39;username&#39;,\n  联系方式: &#39;mobile&#39;,\n  角色: &#39;role&#39;,\n  开通时间: &#39;openTime&#39;\n&#125;\n\n创建数据解析方法\n&#x2F;&#x2F; 该方法负责将数组转化成二维数组\nconst formatJson &#x3D; (headers, rows) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 首先遍历数组\n  &#x2F;&#x2F; [&#123; username: &#39;张三&#39;&#125;,&#123;&#125;,&#123;&#125;]  &#x3D;&gt; [[’张三&#39;],[],[]]\n  return rows.map(item &#x3D;&gt; &#123;\n    return Object.keys(headers).map(key &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 角色特殊处理\n      if (headers[key] &#x3D;&#x3D;&#x3D; &#39;role&#39;) &#123;\n        const roles &#x3D; item[headers[key]]\n\n        return JSON.stringify(roles.map(role &#x3D;&gt; role.title))\n      &#125;\n      return item[headers[key]]\n    &#125;)\n  &#125;)\n&#125;\n\n\n调用该方法，获取导出的二维数组数据\nimport &#123; USER_RELATIONS &#125; from &#39;.&#x2F;Export2ExcelConstants&#39;\n\nconst data &#x3D; formatJson(USER_RELATIONS, allUser)\n\n调用 export_json_to_excel 方法，完成 excel 导出\nexcel.export_json_to_excel(&#123;\n  &#x2F;&#x2F; excel 表头\n  header: Object.keys(USER_RELATIONS),\n  &#x2F;&#x2F; excel 数据（二维数组结构）\n  data,\n  &#x2F;&#x2F; 文件名称\n  filename: excelName.value || exportDefaultName,\n  &#x2F;&#x2F; 是否自动列宽\n  autoWidth: true,\n  &#x2F;&#x2F; 文件类型\n  bookType: &#39;xlsx&#39;\n&#125;)\n\n7-16：业务落地：excel 导出时的时间逻辑处理因为服务端返回的 openTime 格式问题，所以我们需要在 excel 导出时对时间格式进行单独处理\n\n导入时间格式处理工具\nimport &#123; dateFormat &#125; from &#39;@&#x2F;filters&#39;\n\n对时间格式进行单独处理\n&#x2F;&#x2F; 时间特殊处理\n      if (headers[key] &#x3D;&#x3D;&#x3D; &#39;openTime&#39;) &#123;\n        return dateFormat(item[headers[key]])\n      &#125;\n\n7-17：excel  导出功能总结那么到这里我们的整个 excel 导出就算是实现完成了。\n整个 excel 导出遵循以下业务逻辑：\n\n创建 excel 导出弹出层\n处理弹出层相关的业务\n点击导出按钮，将 json 结构数据转化为 excel 数据\njson 数据转化为 二维数组\n时间处理\n角色数组处理\n\n\n下载 excel 数据\n\n其中 将 json 结构数据转化为 excel 数据 部分因为有通用的实现方式，所以我们没有必要进行手动的代码书写，毕竟 “程序猿是最懒的群体嘛”\n但是如果大家想要了解一下这个业务逻辑中所进行的事情，我们也对代码进行了完整的备注，大家可以直接进行查看\n7-18：局部打印详情原理与实现分析那么接下来就是我们本章中最后一个功能 员工详情打印\n整个员工详情的打印逻辑分为两部分：\n\n以表格的形式展示员工详情\n打印详情表格\n\n其中 以表格的形式展示员工详情 部分我们需要使用到 el-descriptions 组件，并且想要利用该组件实现详情的表格效果还需要一些小的技巧，这个具体的我们到时候再去说\n而 打印详情表格 的功能就是建立在展示详情页面之上的\n大家知道，当我们在浏览器右键时，其实可以直接看到对应的 打印 选项，但是这个打印选项是直接打印整个页面，不能指定打印页面中的某一部分的。\n所以说 打印是浏览器本身的功能，但是这个功能存在一定的小缺陷，那就是 只能打印整个页面\n而我们想要实现 详情打印，那么就需要在这个功能的基础之上做到指定打印具体的某一块视图，而这个功能已经有一个第三方的包 vue-print-nb 帮助我们进行了实现，所以我们只需要使用这个包即可完成打印功能\n那么明确好了原理之后，接下来步骤就呼之欲出了：\n\n获取员工详情数据\n在员工详情页面，渲染详情数据\n利用  vue-print-nb 进行局部打印\n\n7-19：业务落地：获取展示数据首先我们来获取对应的展示数据\n\n在 api/user-manage 中定义获取用户详情接口\n&#x2F;**\n * 获取用户详情\n *&#x2F;\nexport const userDetail &#x3D; (id) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#96;&#x2F;user-manage&#x2F;detail&#x2F;$&#123;id&#125;&#96;\n  &#125;)\n&#125;\n\n在 views/user-info 中根据 id 获取接口详情数据，并进行国际化处理\n&lt;script setup&gt;\nimport &#123; userDetail &#125; from &#39;@&#x2F;api&#x2F;user-manage&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\nimport &#123; defineProps, ref &#125; from &#39;vue&#39;\n\nconst props &#x3D; defineProps(&#123;\n  id: &#123;\n    type: String,\n    required: true\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 数据相关\nconst detailData &#x3D; ref(&#123;&#125;)\nconst getUserDetail &#x3D; async () &#x3D;&gt; &#123;\n  detailData.value &#x3D; await userDetail(props.id)\n&#125;\ngetUserDetail()\n&#x2F;&#x2F; 语言切换\nwatchSwitchLang(getUserDetail)\n&lt;&#x2F;script&gt;\n\n因为用户详情可以会以组件的形式进行呈现，所以对于此处我们需要得到的 id ，可以通过 vue-router Props 传参 的形式进行\n\n指定路由表\n&#123;\n        path: &#39;&#x2F;user&#x2F;info&#x2F;:id&#39;,\n        name: &#39;userInfo&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;user-info&#x2F;index&#39;),\n        props: true,\n        meta: &#123;\n          title: &#39;userInfo&#39;\n        &#125;\n      &#125;\n\n在 views/user-manage 中传递用户 id\n&lt;el-button\n    type&#x3D;&quot;primary&quot;\n    size&#x3D;&quot;mini&quot;\n    @click&#x3D;&quot;onShowClick(row._id)&quot;\n&gt;\n\t&#123;&#123; $t(&#39;msg.excel.show&#39;) &#125;&#125;\n&lt;&#x2F;el-button&gt;\n\n&#x2F;**\n * 查看按钮点击事件\n *&#x2F;\nconst onShowClick &#x3D; id &#x3D;&gt; &#123;\n  router.push(&#96;&#x2F;user&#x2F;info&#x2F;$&#123;id&#125;&#96;)\n&#125;\n\n7-20：业务落地：渲染详情结构渲染用户详情结构我们需要借助 el-descriptions 组件，只不过使用该组件时我们需要一些小的技巧\n因为 el-descriptions 组件作用为：渲染描述列表。但是我们想要的包含头像的用户详情样式，直接利用一个 el-descriptions 组件并无法进行渲染，所以此时我们需要对多个 el-descriptions 组件 与 img 标签进行配合使用\n\n\n如果得出渲染代码\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;user-info-container&quot;&gt;\n    &lt;el-card class&#x3D;&quot;print-box&quot;&gt;\n      &lt;el-button type&#x3D;&quot;primary&quot;&gt;&#123;&#123; $t(&#39;msg.userInfo.print&#39;) &#125;&#125;&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;el-card&gt;\n    &lt;el-card&gt;\n      &lt;div class&#x3D;&quot;user-info-box&quot;&gt;\n        &lt;!-- 标题 --&gt;\n        &lt;h2 class&#x3D;&quot;title&quot;&gt;&#123;&#123; $t(&#39;msg.userInfo.title&#39;) &#125;&#125;&lt;&#x2F;h2&gt;\n\n        &lt;div class&#x3D;&quot;header&quot;&gt;\n          &lt;!-- 头部渲染表格 --&gt;\n          &lt;el-descriptions :column&#x3D;&quot;2&quot; border&gt;\n            &lt;el-descriptions-item :label&#x3D;&quot;$t(&#39;msg.userInfo.name&#39;)&quot;&gt;&#123;&#123;\n              detailData.username\n            &#125;&#125;&lt;&#x2F;el-descriptions-item&gt;\n            &lt;el-descriptions-item :label&#x3D;&quot;$t(&#39;msg.userInfo.sex&#39;)&quot;&gt;&#123;&#123;\n              detailData.gender\n            &#125;&#125;&lt;&#x2F;el-descriptions-item&gt;\n            &lt;el-descriptions-item :label&#x3D;&quot;$t(&#39;msg.userInfo.nation&#39;)&quot;&gt;&#123;&#123;\n              detailData.nationality\n            &#125;&#125;&lt;&#x2F;el-descriptions-item&gt;\n            &lt;el-descriptions-item :label&#x3D;&quot;$t(&#39;msg.userInfo.mobile&#39;)&quot;&gt;&#123;&#123;\n              detailData.mobile\n            &#125;&#125;&lt;&#x2F;el-descriptions-item&gt;\n            &lt;el-descriptions-item :label&#x3D;&quot;$t(&#39;msg.userInfo.province&#39;)&quot;&gt;&#123;&#123;\n              detailData.province\n            &#125;&#125;&lt;&#x2F;el-descriptions-item&gt;\n            &lt;el-descriptions-item :label&#x3D;&quot;$t(&#39;msg.userInfo.date&#39;)&quot;&gt;&#123;&#123;\n              $filters.dateFilter(detailData.openTime)\n            &#125;&#125;&lt;&#x2F;el-descriptions-item&gt;\n            &lt;el-descriptions-item :label&#x3D;&quot;$t(&#39;msg.userInfo.remark&#39;)&quot; :span&#x3D;&quot;2&quot;&gt;\n              &lt;el-tag\n                class&#x3D;&quot;remark&quot;\n                size&#x3D;&quot;small&quot;\n                v-for&#x3D;&quot;(item, index) in detailData.remark&quot;\n                :key&#x3D;&quot;index&quot;\n                &gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;el-tag\n              &gt;\n            &lt;&#x2F;el-descriptions-item&gt;\n            &lt;el-descriptions-item\n              :label&#x3D;&quot;$t(&#39;msg.userInfo.address&#39;)&quot;\n              :span&#x3D;&quot;2&quot;\n              &gt;&#123;&#123; detailData.address &#125;&#125;&lt;&#x2F;el-descriptions-item\n            &gt;\n          &lt;&#x2F;el-descriptions&gt;\n          &lt;!-- 头像渲染 --&gt;\n          &lt;el-image\n            class&#x3D;&quot;avatar&quot;\n            :src&#x3D;&quot;detailData.avatar&quot;\n            :preview-src-list&#x3D;&quot;[detailData.avatar]&quot;\n          &gt;&lt;&#x2F;el-image&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;body&quot;&gt;\n          &lt;!-- 内容渲染表格 --&gt;\n          &lt;el-descriptions direction&#x3D;&quot;vertical&quot; :column&#x3D;&quot;1&quot; border&gt;\n            &lt;el-descriptions-item :label&#x3D;&quot;$t(&#39;msg.userInfo.experience&#39;)&quot;&gt;\n              &lt;ul&gt;\n                &lt;li v-for&#x3D;&quot;(item, index) in detailData.experience&quot; :key&#x3D;&quot;index&quot;&gt;\n                  &lt;span&gt;\n                    &#123;&#123; $filters.dateFilter(item.startTime, &#39;YYYY&#x2F;MM&#39;) &#125;&#125;\n                    ----\n                    &#123;&#123; $filters.dateFilter(item.endTime, &#39;YYYY&#x2F;MM&#39;) &#125;&#125;&lt;&#x2F;span\n                  &gt;\n                  &lt;span&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;span&gt;\n                  &lt;span&gt;&#123;&#123; item.desc &#125;&#125;&lt;&#x2F;span&gt;\n                &lt;&#x2F;li&gt;\n              &lt;&#x2F;ul&gt;\n            &lt;&#x2F;el-descriptions-item&gt;\n            &lt;el-descriptions-item :label&#x3D;&quot;$t(&#39;msg.userInfo.major&#39;)&quot;&gt;\n              &#123;&#123; detailData.major &#125;&#125;\n            &lt;&#x2F;el-descriptions-item&gt;\n            &lt;el-descriptions-item :label&#x3D;&quot;$t(&#39;msg.userInfo.glory&#39;)&quot;&gt;\n              &#123;&#123; detailData.glory &#125;&#125;\n            &lt;&#x2F;el-descriptions-item&gt;\n          &lt;&#x2F;el-descriptions&gt;\n        &lt;&#x2F;div&gt;\n        &lt;!-- 尾部签名 --&gt;\n        &lt;div class&#x3D;&quot;foot&quot;&gt;&#123;&#123; $t(&#39;msg.userInfo.foot&#39;) &#125;&#125;&lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;el-card&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.print-box &#123;\n  margin-bottom: 20px;\n  text-align: right;\n&#125;\n.user-info-box &#123;\n  width: 1024px;\n  margin: 0 auto;\n  .title &#123;\n    text-align: center;\n    margin-bottom: 18px;\n  &#125;\n  .header &#123;\n    display: flex;\n    ::v-deep .el-descriptions &#123;\n      flex-grow: 1;\n    &#125;\n    .avatar &#123;\n      width: 187px;\n      box-sizing: border-box;\n      padding: 30px 20px;\n      border: 1px solid #ebeef5;\n      border-left: none;\n    &#125;\n    .remark &#123;\n      margin-right: 12px;\n    &#125;\n  &#125;\n  .body &#123;\n    ul &#123;\n      list-style: none;\n      li &#123;\n        span &#123;\n          margin-right: 62px;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  .foot &#123;\n    margin-top: 42px;\n    text-align: right;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n\n\n7-21：业务落地：局部打印功能实现局部详情打印功能我们需要借助 vue-print-nb，所以首先我们需要下载该插件\nnpm i vue3-print-nb@0.1.4\n\n然后利用该工具完成下载功能：\n\n指定 printLoading\n&lt;el-button type&#x3D;&quot;primary&quot; :loading&#x3D;&quot;printLoading&quot;&gt;&#123;&#123;\n        $t(&#39;msg.userInfo.print&#39;)\n      &#125;&#125;&lt;&#x2F;el-button&gt;\n\n&#x2F;&#x2F; 打印相关\nconst printLoading &#x3D; ref(false)\n\n创建打印对象\nconst printObj &#x3D; &#123;\n  &#x2F;&#x2F; 打印区域\n  id: &#39;userInfoBox&#39;,\n  &#x2F;&#x2F; 打印标题\n  popTitle: &#39;imooc-vue-element-admin&#39;,\n  &#x2F;&#x2F; 打印前\n  beforeOpenCallback(vue) &#123;\n    printLoading.value &#x3D; true\n  &#125;,\n  &#x2F;&#x2F; 执行打印\n  openCallback(vue) &#123;\n    printLoading.value &#x3D; false\n  &#125;\n&#125;\n\n指定打印区域 id 匹配\n&lt;div id&#x3D;&quot;userInfoBox&quot; class&#x3D;&quot;user-info-box&quot;&gt;\n\nvue-print-nb 以指令的形式存在，所以我们需要创建对应指令\n\n新建 directives 文件夹，创建 index.js\n\n写入如下代码\nimport print from &#39;vue3-print-nb&#39;\n\nexport default app &#x3D;&gt; &#123;\n  app.use(print)\n&#125;\n\n\n在 main.js 中导入该指令\nimport installDirective from &#39;@&#x2F;directives&#39;\ninstallDirective(app)\n\n将打印指令挂载到 el-button 中\n&lt;el-button type&#x3D;&quot;primary&quot; v-print&#x3D;&quot;printObj&quot; :loading&#x3D;&quot;printLoading&quot;&gt;&#123;&#123;\n      $t(&#39;msg.userInfo.print&#39;)\n    &#125;&#125;&lt;&#x2F;el-button&gt;\n\n7-22：局部打印功能总结整个局部打印详情功能，整体的核心逻辑就是这么两块：\n\n以表格的形式展示员工详情\n打印详情表格\n\n其中第一部分使用  el-descriptions 组件配合一些小技巧即可实现\n而局部打印功能则需要借助 vue-print-nb 这个第三方库进行实现\n所以整个局部打印功能应该并不算复杂，掌握这两部分即可轻松实现\n7-23：总结那么到这里我们整个章节就全部完成了，最后的 为用户分配角色 功能需要配合 角色列表 进行实现，所以我们需要等到后面进行\n那么整个章节所实现的功能有：\n\n用户列表分页展示\nexcel 导入用户\n用户列表导出为 excel\n用户详情的表格展示\n用户详情表格打印\n用户删除\n\n这么六个\n其中比较复杂的应该就是 excel 导入 &amp; 导出 了，所以针对这两个功能我们花费了最多的篇幅进行讲解\n但是这里有一点大家不要忘记，我们在本章开篇的时候说过，员工管理 是 用户权限中的一个前置！ 比如我们的分配角色功能就需要配合其他的业务实现，那么具体的整个用户权限都包含了哪些内容呢？\n想要知道快来看下一章节吧！\n","slug":"vue3.2后台管理系统/07用户权限处理","date":"2022-08-22T17:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"7e9c877cd1e65a897a0339a3e374ff44","title":"06vue3+ElementPlus综合实现","content":"第六章：vue3+ElementPlus综合实现6-1：开篇那么经过前面的学习，我们已经完成了：\n\n编程规范\n登录\nlayout\n通用功能\n\n这四个大的模块开发，那么接下来我们就可以进入到项目的业务模块开发之中，结合具体的业务来去分析方案，也是一个非常重要的能力。\n那么这一章节，我们要去制作的就是 个人中心 模块。\n个人中心模块是一个集合了 vue + element-plus 的业务模块，主要分成三个大块：\n\nelement-plus 组件\n自定义业务组件\n业务中的国际化处理\n\n那么明确好了本章的主要内容之后，接下来我们就进入本章节的业务功能开发吧。\n6-2：个人中心模块基本布局整个 个人中心 被分为左右两大块：\n\n项目介绍\ntabs\n功能\n章节\n作者\n\n\n\n根据功能划分，整个项目应该包含 4 个组件，分别对应着 4 个功能。\n所以，我们想要完成 个人中心模块基本布局 那么就需要先创建出这四个组件\n\n在 views/profile/components 下创建 项目介绍 组件 ProjectCard\n\n在 views/profile/components 下创建 功能 组件 feature\n\n在 views/profile/components 下创建 章节 组件 chapter\n\n在 views/profile/components 下创建 作者 组件 author\n\n进入到 views/profile/index 页面，绘制基本布局结构\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;my-container&quot;&gt;\n    &lt;el-row&gt;\n      &lt;el-col :span&#x3D;&quot;6&quot;&gt;\n        &lt;project-card class&#x3D;&quot;user-card&quot;&gt;&lt;&#x2F;project-card&gt;\n      &lt;&#x2F;el-col&gt;\n      &lt;el-col :span&#x3D;&quot;18&quot;&gt;\n        &lt;el-card&gt;\n          &lt;el-tabs v-model&#x3D;&quot;activeName&quot;&gt;\n            &lt;el-tab-pane :label&#x3D;&quot;$t(&#39;msg.profile.feature&#39;)&quot; name&#x3D;&quot;feature&quot;&gt;\n              &lt;feature &#x2F;&gt;\n            &lt;&#x2F;el-tab-pane&gt;\n            &lt;el-tab-pane :label&#x3D;&quot;$t(&#39;msg.profile.chapter&#39;)&quot; name&#x3D;&quot;chapter&quot;&gt;\n              &lt;chapter &#x2F;&gt;\n            &lt;&#x2F;el-tab-pane&gt;\n            &lt;el-tab-pane :label&#x3D;&quot;$t(&#39;msg.profile.author&#39;)&quot; name&#x3D;&quot;author&quot;&gt;\n              &lt;author &#x2F;&gt;\n            &lt;&#x2F;el-tab-pane&gt;\n          &lt;&#x2F;el-tabs&gt;\n        &lt;&#x2F;el-card&gt;\n      &lt;&#x2F;el-col&gt;\n    &lt;&#x2F;el-row&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport ProjectCard from &#39;.&#x2F;components&#x2F;ProjectCard.vue&#39;\nimport Chapter from &#39;.&#x2F;components&#x2F;Chapter.vue&#39;\nimport Feature from &#39;.&#x2F;components&#x2F;Feature.vue&#39;\nimport Author from &#39;.&#x2F;components&#x2F;Author.vue&#39;\nimport &#123; ref &#125; from &#39;vue&#39;\nconst activeName &#x3D; ref(&#39;feature&#39;)\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.my-container &#123;\n  .user-card &#123;\n    margin-right: 20px;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n6-3：创建 PanThumb 头像组件对于四个功能模块而言，我们首先处理 项目介绍 模块。\n在 项目介绍 模块中，存在一个头像：鼠标移入之后，头像会移开，显示出后面的文本\n那么本小节我们要来开发的就是这个组件 PanThumb ，整个组件核心的移动处理我们可以直接通过 css 进行实现\n\n创建 components/PanThumb/index\n&lt;template&gt;\n  &lt;div\n    :style&#x3D;&quot;&#123; zIndex: zIndex, height: height, width: width &#125;&quot;\n    class&#x3D;&quot;pan-item&quot;\n  &gt;\n    &lt;div class&#x3D;&quot;pan-info&quot;&gt;\n      &lt;div class&#x3D;&quot;pan-info-roles-container&quot;&gt;\n        &lt;slot &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div :style&#x3D;&quot;&#123; backgroundImage: &#96;url($&#123;image&#125;)&#96; &#125;&quot; class&#x3D;&quot;pan-thumb&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; defineProps &#125; from &#39;vue&#39;\ndefineProps(&#123;\n  image: &#123;\n    type: String\n  &#125;,\n  zIndex: &#123;\n    type: Number,\n    default: 1\n  &#125;,\n  width: &#123;\n    type: String,\n    default: &#39;150px&#39;\n  &#125;,\n  height: &#123;\n    type: String,\n    default: &#39;150px&#39;\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n.pan-item &#123;\n  width: 200px;\n  height: 200px;\n  border-radius: 50%;\n  display: inline-block;\n  position: relative;\n  cursor: pointer;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);\n\n  .pan-info &#123;\n    position: absolute;\n    width: inherit;\n    height: inherit;\n    border-radius: 50%;\n    overflow: hidden;\n    box-shadow: inset 0 0 0 5px rgba(0, 0, 0, 0.05);\n\n    h3 &#123;\n      color: #fff;\n      text-transform: uppercase;\n      position: relative;\n      letter-spacing: 2px;\n      font-size: 14px;\n      margin: 0 60px;\n      padding: 22px 0 0 0;\n      height: 85px;\n      font-family: &#39;Open Sans&#39;, Arial, sans-serif;\n      text-shadow: 0 0 1px #fff, 0 1px 2px rgba(0, 0, 0, 0.3);\n    &#125;\n\n    p &#123;\n      color: #fff;\n      padding: 10px 5px;\n      font-style: italic;\n      margin: 0 30px;\n      font-size: 12px;\n      border-top: 1px solid rgba(255, 255, 255, 0.5);\n\n      a &#123;\n        display: block;\n        color: #333;\n        width: 80px;\n        height: 80px;\n        background: rgba(255, 255, 255, 0.3);\n        border-radius: 50%;\n        color: #fff;\n        font-style: normal;\n        font-weight: 700;\n        text-transform: uppercase;\n        font-size: 9px;\n        letter-spacing: 1px;\n        padding-top: 24px;\n        margin: 7px auto 0;\n        font-family: &#39;Open Sans&#39;, Arial, sans-serif;\n        opacity: 0;\n        transition: transform 0.3s ease-in-out 0.2s,\n          opacity 0.3s ease-in-out 0.2s, background 0.2s linear 0s;\n        transform: translateX(60px) rotate(90deg);\n      &#125;\n\n      a:hover &#123;\n        background: rgba(255, 255, 255, 0.5);\n      &#125;\n    &#125;\n\n    .pan-info-roles-container &#123;\n      padding: 20px;\n      text-align: center;\n    &#125;\n  &#125;\n\n  .pan-thumb &#123;\n    width: 100%;\n    height: 100%;\n    background-position: center center;\n    background-size: cover;\n    border-radius: 50%;\n    overflow: hidden;\n    position: absolute;\n    transform-origin: 95% 40%;\n    transition: all 0.3s ease-in-out;\n  &#125;\n\n  .pan-item:hover .pan-thumb &#123;\n    transform: rotate(-110deg);\n  &#125;\n\n  .pan-item:hover .pan-info p a &#123;\n    opacity: 1;\n    transform: translateX(0px) rotate(0deg);\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n在 projectCard 中导入测试\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;\n    &lt;pan-thumb\n      :image&#x3D;&quot;$store.getters.userInfo.avatar&quot;\n      :height&#x3D;&quot;&#39;100px&#39;&quot;\n      :width&#x3D;&quot;&#39;100px&#39;&quot;\n      :hoverable&#x3D;&quot;false&quot;\n    &gt;\n      &lt;div&gt;Hello&lt;&#x2F;div&gt;\n      &#123;&#123; $store.getters.userInfo.title &#125;&#125;\n    &lt;&#x2F;pan-thumb&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n6-4：element-plus：项目介绍模块开发项目介绍从上到下可以分为三部分：\n\n头像区域\n项目介绍\n项目功能\n\n对于这三块的数据而言，前面两个是直接在前端写死的，项目功能 是从服务端获取到的。\n对于前端写死部分，我们已经在之前定义到了 i18n/lang 之下\n而对于从服务端获取部分，我们就需要单独定义上接口了：\n\n创建 api/user 模块\nimport request from &#39;@&#x2F;utils&#x2F;request&#39;\n\nexport const feature &#x3D; () &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;user&#x2F;feature&#39;\n  &#125;)\n&#125;\n\n\n因为该数据会同时在 ProjectCard 和 Feature 组件中使用，所以我们可以在 profile 中调用该接口获取数据，然后再把数据分别传入到两个子级组件中\nimport &#123; feature &#125; from &#39;@&#x2F;api&#x2F;user&#39;\n\nconst featureData &#x3D; ref([])\nconst getFeatureData &#x3D; async () &#x3D;&gt; &#123;\n  featureData.value &#x3D; await feature()\n&#125;\ngetFeatureData()\n\n传递数据到 ProjectCard\n&lt;project-card class&#x3D;&quot;user-card&quot; :features&#x3D;&quot;featureData&quot;&gt;&lt;&#x2F;project-card&gt;\n\n有了数据之后，接下来我们就可以去完成 项目介绍 模块：\n\n先处理头像区域\n&lt;template&gt;\n  &lt;el-card class&#x3D;&quot;user-container&quot;&gt;\n    &lt;template #header&gt;\n      &lt;div class&#x3D;&quot;header&quot;&gt;\n        &lt;span&gt;&#123;&#123; $t(&#39;msg.profile.introduce&#39;) &#125;&#125;&lt;&#x2F;span&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;template&gt;\n\n    &lt;div class&#x3D;&quot;user-profile&quot;&gt;\n      &lt;!-- 头像 --&gt;\n      &lt;div class&#x3D;&quot;box-center&quot;&gt;\n        &lt;pan-thumb\n          :image&#x3D;&quot;$store.getters.userInfo.avatar&quot;\n          :height&#x3D;&quot;&#39;100px&#39;&quot;\n          :width&#x3D;&quot;&#39;100px&#39;&quot;\n          :hoverable&#x3D;&quot;false&quot;\n        &gt;\n          &lt;div&gt;Hello&lt;&#x2F;div&gt;\n          &#123;&#123; $store.getters.userInfo.title &#125;&#125;\n        &lt;&#x2F;pan-thumb&gt;\n      &lt;&#x2F;div&gt;\n      &lt;!-- 姓名 &amp;&amp; 角色 --&gt;\n      &lt;div class&#x3D;&quot;box-center&quot;&gt;\n        &lt;div class&#x3D;&quot;user-name text-center&quot;&gt;\n          &#123;&#123; $store.getters.userInfo.username &#125;&#125;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;user-role text-center text-muted&quot;&gt;\n          &#123;&#123; $store.getters.userInfo.title &#125;&#125;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;el-card&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport PanThumb from &#39;@&#x2F;components&#x2F;PanThumb&#x2F;index.vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.user-container &#123;\n  .text-muted &#123;\n    font-size: 14px;\n    color: #777;\n  &#125;\n\n  .user-profile &#123;\n    text-align: center;\n    .user-name &#123;\n      font-weight: bold;\n    &#125;\n\n    .box-center &#123;\n      padding-top: 10px;\n    &#125;\n\n    .user-role &#123;\n      padding-top: 10px;\n      font-weight: 400;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n接下来是项目介绍区域\n&lt;template&gt;\n  &lt;el-card class&#x3D;&quot;user-container&quot;&gt;\n    ...\n    &lt;!-- 简介 --&gt;\n    &lt;div class&#x3D;&quot;project-bio&quot;&gt;\n      &lt;div class&#x3D;&quot;project-bio-section&quot;&gt;\n        &lt;div class&#x3D;&quot;project-bio-section-header&quot;&gt;\n          &lt;svg-icon icon&#x3D;&quot;introduce&quot; &#x2F;&gt;\n          &lt;span&gt;&#123;&#123; $t(&#39;msg.profile.projectIntroduction&#39;) &#125;&#125;&lt;&#x2F;span&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;project-bio-section-body&quot;&gt;\n          &lt;div class&#x3D;&quot;text-muted&quot;&gt;\n            &#123;&#123; $t(&#39;msg.profile.muted&#39;) &#125;&#125;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;el-card&gt;\n&lt;&#x2F;template&gt;\n\n....\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.user-container &#123;\n  ...\n  .project-bio &#123;\n    margin-top: 20px;\n    color: #606266;\n    span &#123;\n      padding-left: 4px;\n    &#125;\n\n    .project-bio-section &#123;\n      margin-bottom: 36px;\n      .project-bio-section-header &#123;\n        border-bottom: 1px solid #dfe6ec;\n        padding-bottom: 10px;\n        margin-bottom: 10px;\n        font-weight: bold;\n      &#125;\n      .project-bio-section-body &#123;\n        .progress-item &#123;\n          margin-top: 10px;\n          div &#123;\n            font-size: 14px;\n            margin-bottom: 2px;\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n最后是项目功能区域，先接收项目功能数据\n&lt;script setup&gt;\nimport &#123; defineProps &#125; from &#39;vue&#39;\ndefineProps(&#123;\n  features: &#123;\n    type: Array,\n    required: true\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n处理对应视图\n&lt;div class&#x3D;&quot;project-bio-section&quot;&gt;\n        &lt;div class&#x3D;&quot;project-bio-section-header&quot;&gt;\n          &lt;svg-icon icon&#x3D;&quot;reward&quot; &#x2F;&gt;&lt;span&gt;&#123;&#123;\n            $t(&#39;msg.profile.projectFunction&#39;)\n          &#125;&#125;&lt;&#x2F;span&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;project-bio-section-body&quot;&gt;\n          &lt;div class&#x3D;&quot;progress-item&quot; v-for&#x3D;&quot;item in features&quot; :key&#x3D;&quot;item.id&quot;&gt;\n            &lt;div&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;div&gt;\n            &lt;el-progress :percentage&#x3D;&quot;item.percentage&quot; status&#x3D;&quot;success&quot; &#x2F;&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n\n6-5：接口国际化：处理接口国际化问题在现在我们去切换语言，发现在 项目功能 部分，数据并没有进行国际化展示，所以接下来我们需要处理的就是这部分数据的国际化内容\n在前面我们知道整个 项目介绍 中，数据存在两种：\n\n本地写死的国际化数据\n接口获取到的数据\n\n那么针对于第一种数据是可以直接完成国际化展示的。\n但是第二种数据因为是从服务端获取到的，所以说，服务端返回什么内容，那么前端就会展示什么内容。\n所以说如果我们想要完成接口的国际化，那么就需要让服务端返回对应国际化的数据。\n如果想要达到这个目的，那么我们需要：在接口请求的 headers 中增加 Accept-Language 表明当前我们所需要的语言类型，在 支持国际化 的接口服务中，可以直接获取到国际化数据\n\n在 utils/request.js 的请求拦截器中增加 headers 配置\n&#x2F;&#x2F; 请求拦截器\nservice.interceptors.request.use(\n  config &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 在这个位置需要统一的去注入token\n    if (store.getters.token) &#123;\n     ...\n    &#125;\n    &#x2F;&#x2F; 配置接口国际化\n    config.headers[&#39;Accept-Language&#39;] &#x3D; store.getters.language\n    return config &#x2F;&#x2F; 必须返回配置\n  &#125;,\n  error &#x3D;&gt; &#123;\n    return Promise.reject(error)\n  &#125;\n)\n\n其实我们发现，在我们切换了语言之后，刷新 页面即可获取到 国际化返回数据\n但是每次都刷新页面的操作未免不太友好，那么有没有什么办法可以跳过刷新这个步骤呢？\n还记不记得，我们之前定义过的 watchSwitchLang 方法，该方法可以 监听到语言的变化，然后指定操作。依赖这个方法得出以下代码：\n\n在 views/profile/index 中\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n&#x2F;&#x2F; 监听语言切换\nwatchSwitchLang(getFeatureData)\n\n那么现在 项目介绍 的数据已经可以实现国际化了\n剩下的就是 用户信息 数据的国际化实现，在 app.js 中监听语言变化，重新制定获取用户信息的动作\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n\n&#x2F;**\n * 监听 语言变化，重新获取个人信息\n *&#x2F;\nwatchSwitchLang(() &#x3D;&gt; &#123;\n  if (store.getters.token) &#123;\n    store.dispatch(&#39;user&#x2F;getUserInfo&#39;)\n  &#125;\n&#125;)\n\n\n\n\n\n6-6：element-plus：功能模块开发处理完成接口的国际化之后，接下来我们来看功能模块开发\n功能模块中我们会使用到 element-plus 的 el-collapse 组件\n\n在 profile 中传递数据到 Feature\n&lt;feature :features&#x3D;&quot;featureData&quot; &#x2F;&gt;\n\n&lt;script setup&gt;\nimport &#123; defineProps &#125; from &#39;vue&#39;\ndefineProps(&#123;\n  features: &#123;\n    type: Array,\n    required: true\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n利用 el-collapse 渲染结构\n&lt;template&gt;\n  &lt;el-collapse v-model&#x3D;&quot;activeName&quot; accordion&gt;\n    &lt;el-collapse-item\n      v-for&#x3D;&quot;item in features&quot;\n      :key&#x3D;&quot;item.id&quot;\n      :title&#x3D;&quot;item.title&quot;\n      :name&#x3D;&quot;item.id&quot;\n    &gt;\n      &lt;div v-html&#x3D;&quot;item.content&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;&#x2F;el-collapse-item&gt;\n  &lt;&#x2F;el-collapse&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref, defineProps &#125; from &#39;vue&#39;\nconst activeName &#x3D; ref(0)\ndefineProps(&#123;\n  features: &#123;\n    type: Array,\n    required: true\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n::v-deep .el-collapse-item__header &#123;\n  font-weight: bold;\n&#125;\n\n.el-collapse-item &#123;\n  ::v-deep a &#123;\n    color: #2d62f7;\n    margin: 0 4px;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n6-7：element-plus：章节模块开发对于章节模块的处理，我们只需要在获取到数据之后，利用 Timeline 进行渲染即可。\n\n在 api/user 下定义接口\nexport const chapter &#x3D; () &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;user&#x2F;chapter&#39;\n  &#125;)\n&#125;\n\n在 Chapter 调用接口，处理接口国际化\n&lt;script setup&gt;\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\nimport &#123; chapter &#125; from &#39;@&#x2F;api&#x2F;user&#39;\nimport &#123; ref &#125; from &#39;vue&#39;\nconst chapterData &#x3D; ref([])\n\nconst getChapterData &#x3D; async () &#x3D;&gt; &#123;\n  chapterData.value &#x3D; await chapter()\n&#125;\ngetChapterData()\n\n&#x2F;&#x2F; 监听语言切换\nwatchSwitchLang(getChapterData)\n&lt;&#x2F;script&gt;\n\n根据数据，利用  Timeline 进行渲染\n&lt;template&gt;\n  &lt;el-timeline&gt;\n    &lt;el-timeline-item\n      v-for&#x3D;&quot;item in chapterData&quot;\n      :key&#x3D;&quot;item.id&quot;\n      :timestamp&#x3D;&quot;item.timestamp&quot;\n      placement&#x3D;&quot;top&quot;\n    &gt;\n      &lt;el-card&gt;\n        &lt;h4&gt;&#123;&#123; item.content &#125;&#125;&lt;&#x2F;h4&gt;\n      &lt;&#x2F;el-card&gt;\n    &lt;&#x2F;el-timeline-item&gt;\n  &lt;&#x2F;el-timeline&gt;\n&lt;&#x2F;template&gt;\n\n6-8：element-plus：作者模块开发作者模块整体比较简单，我们直接使用本地数据进行渲染即可\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;author-container&quot;&gt;\n    &lt;div class&#x3D;&quot;header&quot;&gt;\n      &lt;pan-thumb\n        image&#x3D;&quot;https:&#x2F;&#x2F;img4.sycdn.imooc.com&#x2F;61110c2b0001152907400741-140-140.jpg&quot;\n        height&#x3D;&quot;60px&quot;\n        width&#x3D;&quot;60px&quot;\n        :hoverable&#x3D;&quot;false&quot;\n      &gt;\n        &#123;&#123; $t(&#39;msg.profile.name&#39;) &#125;&#125;\n      &lt;&#x2F;pan-thumb&gt;\n      &lt;div class&#x3D;&quot;header-desc&quot;&gt;\n        &lt;h3&gt;&#123;&#123; $t(&#39;msg.profile.name&#39;) &#125;&#125;&lt;&#x2F;h3&gt;\n        &lt;span&gt;&#123;&#123; $t(&#39;msg.profile.job&#39;) &#125;&#125;&lt;&#x2F;span&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;info&quot;&gt;\n      &#123;&#123; $t(&#39;msg.profile.Introduction&#39;) &#125;&#125;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport PanThumb from &#39;@&#x2F;components&#x2F;PanThumb&#x2F;index.vue&#39;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.author-container &#123;\n  .header &#123;\n    display: flex;\n    .header-desc &#123;\n      margin-left: 12px;\n      display: flex;\n      flex-direction: column;\n      justify-content: space-around;\n\n      span &#123;\n        font-size: 14px;\n      &#125;\n    &#125;\n  &#125;\n  .info &#123;\n    margin-top: 16px;\n    line-height: 22px;\n    font-size: 14px;\n    text-indent: 26px;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n\n\n6-9：总结本章节中的内容主要就是分成了\n\nelement-plus 组件\n自定义业务组件\n业务中的国际化处理\n\n这三个模块，整体来说复杂度比前面的章节要小不少，算是一个过渡章节。\n那么从下一章节开发，我们就要进入到 用户模块 的业务开发了，整个  用户模块 包含了\n\n员工管理\n角色列表\n权限列表\n\n三个大的部分\n并且我们会在这三个模块的业务权限纠缠中处理更多的功能解决方案，想要了解更多？那么快来看下一个章节的内容吧！\n","slug":"vue3.2后台管理系统/06vue3+ElementPlus综合实现","date":"2022-08-22T16:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"5c163a9965f56c02ab2c674f0a7895b4","title":"05通用功能开发","content":"第五章：通用功能开发5-01：开篇在后台项目的前端开发之中，存在着很多的通用业务功能，并且存在着一定的技术难度。\n所以说就有很多人在面临这些功能的时候，大多数时都是采用 ctrl + c || v 的形式来进行实现。这就导致了虽然做过类似的功能，但是对这些功能的实现原理一知半解。\n那么针对于这样的问题，就有了咱们这一章。\n在本章中我们列举出了常见的一些通用功能，具体如下：\n\n国际化\n动态换肤\nscreenfull\nheaderSearch\ntagView\nguide\n\n来为大家进行讲解。\n相信大家完成了本章的学习之后，对于这些功能无论是从 原理上 还是从 实现上 都可以做到 了然于胸 的目标\n5-02：国际化实现原理先来看一个需求：\n\n\n\n\n\n\n\n\n\n我们有一个变量 msg ，但是这个 msg 有且只能有两个值：\n\nhello world\n你好世界\n\n要求：根据需要切换 msg 的值\n这样的一个需求就是 国际化 的需求，那么我们可以通过以下代码来实现这个需求\n&lt;script&gt;\n  &#x2F;&#x2F; 1. 定义 msg 值的数据源\n  const messages &#x3D; &#123;\n    en: &#123;\n      msg: &#39;hello world&#39;\n    &#125;,\n    zh: &#123;\n      msg: &#39;你好世界&#39;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 2. 定义切换变量\n  let locale &#x3D; &#39;en&#39;\n  &#x2F;&#x2F; 3. 定义赋值函数\n  function t(key) &#123;\n    return messages[locale][key]\n  &#125;\n  &#x2F;&#x2F; 4. 为 msg 赋值 \n  let msg &#x3D; t(&#39;msg&#39;)\n  console.log(msg);\n  &#x2F;&#x2F; 修改 locale， 重新执行 t 方法，获取不同语言环境下的值\n\n&lt;&#x2F;script&gt;\n\n 总结：\n\n通过一个变量来 控制 语言环境\n所有语言环境下的数据源要 预先 定义好\n通过一个方法来获取 当前语言 下 指定属性 的值\n该值即为国际化下展示值\n\n5-03：基于 vue-i18n V9  的国际化实现方案分析在 vue 的项目中，我们不需要手写这么复杂的一些基础代码，可以直接使用 vue-i18n 进行实现（注意：**vue3 下需要使用 V 9.x 的 i18n**）\nvue-i18n 的使用可以分为四个部分：\n\n创建 messages 数据源\n创建 locale 语言变量\n初始化 i18n 实例\n注册 i18n 实例\n\n那么接下来我们就去实现以下：\n\n安装 vue-i18n\nnpm install vue-i18n@next\n\n\n\n创建 i18n/index.js 文件\n\n创建 messages 数据源\nconst messages &#x3D; &#123;\n  en: &#123;\n    msg: &#123;\n      test: &#39;hello world&#39;\n    &#125;\n  &#125;,\n  zh: &#123;\n    msg: &#123;\n      test: &#39;你好世界&#39;\n    &#125;\n  &#125;\n&#125;\n\n创建 locale 语言变量\nconst locale &#x3D; &#39;en&#39;\n\n初始化 i18n 实例\nimport &#123; createI18n &#125; from &#39;vue-i18n&#39;\n\nconst i18n &#x3D; createI18n(&#123;\n  &#x2F;&#x2F; 使用 Composition API 模式，则需要将其设置为false\n  legacy: false,\n  &#x2F;&#x2F; 全局注入 $t 函数\n  globalInjection: true,\n  locale,\n  messages\n&#125;)\n\n把 i18n 注册到 vue 实例\n\nexport default i18n\n\n在 main.js 中导入\n&#x2F;&#x2F; i18n （PS：导入放到 APP.vue 导入之前，因为后面我们会在 app.vue 中使用国际化内容）\nimport i18n from &#39;@&#x2F;i18n&#39;\n...\napp.use(i18n)\n\n在 layout/components/Sidebar/index.vue 中使用 i18n\n&lt;h1 class&#x3D;&quot;logo-title&quot; v-if&#x3D;&quot;$store.getters.sidebarOpened&quot;&gt;\n        &#123;&#123; $t(&#39;msg.test&#39;) &#125;&#125;\n&lt;&#x2F;h1&gt;\n\n修改 locale 的值，即可改变展示的内容\n\n\n截止到现在我们已经实现了 i18n 的最基础用法，那么解下来我们就可以在项目中使用 i18n 完成国际化。\n项目中完成国际化分成以下几步进行:\n\n封装 langSelect 组件用于修改 locale\n导入 el-locale 语言包\n创建自定义语言包\n\n5-04：方案落地：封装  langSelect  组件\n定义 store/app.js\nimport &#123; LANG &#125; from &#39;@&#x2F;constant&#39;\nimport &#123; getItem, setItem &#125; from &#39;@&#x2F;utils&#x2F;storage&#39;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;\n    ...\n    language: getItem(LANG) || &#39;zh&#39;\n  &#125;),\n  mutations: &#123;\n    ...\n    &#x2F;**\n     * 设置国际化\n     *&#x2F;\n    setLanguage(state, lang) &#123;\n      setItem(LANG, lang)\n      state.language &#x3D; lang\n    &#125;\n  &#125;,\n  actions: &#123;&#125;\n&#125;\n\n\n\n\n在 constant 中定义常量\n&#x2F;&#x2F; 国际化\nexport const LANG &#x3D; &#39;language&#39;\n\n\n\n创建 components/LangSelect/index \n&lt;template&gt;\n  &lt;el-dropdown\n    trigger&#x3D;&quot;click&quot;\n    class&#x3D;&quot;international&quot;\n    @command&#x3D;&quot;handleSetLanguage&quot;\n  &gt;\n    &lt;div&gt;\n      &lt;el-tooltip content&#x3D;&quot;国际化&quot; :effect&#x3D;&quot;effect&quot;&gt;\n        &lt;svg-icon icon&#x3D;&quot;language&quot; &#x2F;&gt;\n      &lt;&#x2F;el-tooltip&gt;\n    &lt;&#x2F;div&gt;\n    &lt;template #dropdown&gt;\n      &lt;el-dropdown-menu&gt;\n        &lt;el-dropdown-item :disabled&#x3D;&quot;language &#x3D;&#x3D;&#x3D; &#39;zh&#39;&quot; command&#x3D;&quot;zh&quot;&gt;\n          中文\n        &lt;&#x2F;el-dropdown-item&gt;\n        &lt;el-dropdown-item :disabled&#x3D;&quot;language &#x3D;&#x3D;&#x3D; &#39;en&#39;&quot; command&#x3D;&quot;en&quot;&gt;\n          English\n        &lt;&#x2F;el-dropdown-item&gt;\n      &lt;&#x2F;el-dropdown-menu&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;el-dropdown&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; useI18n &#125; from &#39;vue-i18n&#39;\nimport &#123; defineProps, computed &#125; from &#39;vue&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\n\ndefineProps(&#123;\n  effect: &#123;\n    type: String,\n    default: &#39;dark&#39;,\n    validator: function(value) &#123;\n      &#x2F;&#x2F; 这个值必须匹配下列字符串中的一个\n      return [&#39;dark&#39;, &#39;light&#39;].indexOf(value) !&#x3D;&#x3D; -1\n    &#125;\n  &#125;\n&#125;)\n\nconst store &#x3D; useStore()\nconst language &#x3D; computed(() &#x3D;&gt; store.getters.language)\n\n&#x2F;&#x2F; 切换语言的方法\nconst i18n &#x3D; useI18n()\nconst handleSetLanguage &#x3D; lang &#x3D;&gt; &#123;\n  i18n.locale.value &#x3D; lang\n  store.commit(&#39;app&#x2F;setLanguage&#39;, lang)\n  ElMessage.success(&#39;更新成功&#39;)\n&#125;\n&lt;&#x2F;script&gt;\n\n在 navbar 中导入 LangSelect\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;navbar&quot;&gt;\n    ...\n    &lt;div class&#x3D;&quot;right-menu&quot;&gt;\n      &lt;lang-select class&#x3D;&quot;right-menu-item hover-effect&quot; &#x2F;&gt;\n      &lt;!-- 头像 --&gt;\n      ...\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport LangSelect from &#39;@&#x2F;components&#x2F;LangSelect&#39;\n...\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.navbar &#123;\n  ...\n\n  .right-menu &#123;\n    ...\n\n    ::v-deep .right-menu-item &#123;\n      display: inline-block;\n      padding: 0 18px 0 0;\n      font-size: 24px;\n      color: #5a5e66;\n      vertical-align: text-bottom;\n\n      &amp;.hover-effect &#123;\n        cursor: pointer;\n      &#125;\n    &#125;\n\n    ...\n&#125;\n&lt;&#x2F;style&gt;\n\n\n5-05：方案落地：element-plus 国际化处理截止到目前，我们的国际化内容已经基本功能已经处理完成了。接下来需要处理的就是对应的语言包，有了语言包就可以实现整个项目中的所有国际化处理了。\n那么对于语言包来说，我们整个项目中会分成两部分：\n\nelement-plus 语言包：用来处理 element 组件的国际化功能\n自定义语言包：用来处理 非element 组件的国际化功能\n\n那么首先我们先来处理 element-plus 语言包：\n**按照正常的逻辑，我们是可以通过 element-ui 配合 vue-i18n来实现国际化功能的，但是目前的 element-plus 尚未提供配合  vue-i18n 实现国际化的方式！ **\n所以说，我们暂时只能先去做临时处理，等到 element-plus 支持 vue-i18n 功能之后，我们再进行对接实现\n那么临时处理我们怎么去做呢？\n\n升级 element-plus 到最新版本\nnpm i element-plus\n\n目前项目中使用的最新版本为：^1.1.0-beta.15\n\n升级版本之后，左侧 menu 菜单无法正常显示，这是因为 element-plus 修改了 el-submenu 的组件名称\n\n到 layout/components/Sidebar/SidebarItem 中，修改 el-submenu 为 el-sub-menu\n\n接下来实现国际化\n\n在 plugins/index 中导入 element 的中文、英文语言包：\n\n\nimport zhCn from &#39;element-plus&#x2F;es&#x2F;locale&#x2F;lang&#x2F;zh-cn&#39;\nimport en from &#39;element-plus&#x2F;lib&#x2F;locale&#x2F;lang&#x2F;en&#39;\n\n\n注册 element 时，根据当前语言选择使用哪种语言包\nimport store from &#39;@&#x2F;store&#39;\n\nexport default app &#x3D;&gt; &#123;\n  app.use(ElementPlus, &#123;\n    locale: store.getters.language &#x3D;&#x3D;&#x3D; &#39;en&#39; ? en : zhCn\n  &#125;)\n&#125;\n\n5-06：方案落地：自定义语言包国际化处理处理完 element 的国际化内容之后，接下来我们来处理 自定义语言包。\n自定义语言包我们使用了 commonJS 导出了一个对象，这个对象就是所有的 自定义语言对象 \n\n\n\n\n\n\n\n\n\n大家可以在 资料&#x2F;lang 中获取到所有的语言包\n\n复制 lang 文件夹到 i18n 中\n\n在 lang/index 中，导入语言包\nimport mZhLocale from &#39;.&#x2F;lang&#x2F;zh&#39;\nimport mEnLocale from &#39;.&#x2F;lang&#x2F;en&#39;\n\n在 messages 中注册到语言包\nconst messages &#x3D; &#123;\n  en: &#123;\n    msg: &#123;\n      ...mEnLocale\n    &#125;\n  &#125;,\n  zh: &#123;\n    msg: &#123;\n      ...mZhLocale\n    &#125;\n  &#125;\n&#125;\n\n5-07：方案落地：处理项目国际化内容在处理好了国际化的语言包之后，接下来我们就可以应用国际化功能到我们的项目中\n对于我们目前的项目而言，需要进行国际化处理的地方主要分为：\n\n登录页面\nnavbar 区域\nsidebar 区域\n面包屑区域\n\n那么这一小节，我们先来处理前两个\n登录页面：\nlogin/index\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    ...\n      &lt;div class&#x3D;&quot;title-container&quot;&gt;\n        &lt;h3 class&#x3D;&quot;title&quot;&gt;&#123;&#123; $t(&#39;msg.login.title&#39;) &#125;&#125;&lt;&#x2F;h3&gt;\n          &lt;lang-select class&#x3D;&quot;lang-select&quot; effect&#x3D;&quot;light&quot;&gt;&lt;&#x2F;lang-select&gt;\n      &lt;&#x2F;div&gt;\n\n      ...\n\n      &lt;el-button\n        type&#x3D;&quot;primary&quot;\n        style&#x3D;&quot;width: 100%; margin-bottom: 30px&quot;\n        :loading&#x3D;&quot;loading&quot;\n        @click&#x3D;&quot;handleLogin&quot;\n        &gt;&#123;&#123; $t(&#39;msg.login.loginBtn&#39;) &#125;&#125;&lt;&#x2F;el-button\n      &gt;\n      \n      &lt;div class&#x3D;&quot;tips&quot; v-html&#x3D;&quot;$t(&#39;msg.login.desc&#39;)&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;&#x2F;el-form&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; useI18n &#125; from &#39;vue-i18n&#39;\n...\n&#x2F;&#x2F; 验证规则\nconst i18n &#x3D; useI18n()\nconst loginRules &#x3D; ref(&#123;\n  username: [\n    &#123;\n      ...\n      message: i18n.t(&#39;msg.login.usernameRule&#39;)\n    &#125;\n  ],\n  ...\n&#125;)\n...\n&lt;&#x2F;script&gt;\n\n\n\nlogin/rules\nimport i18n from &#39;@&#x2F;i18n&#39;\nexport const validatePassword &#x3D; () &#x3D;&gt; &#123;\n  return (rule, value, callback) &#x3D;&gt; &#123;\n    if (value.length &lt; 6) &#123;\n      callback(new Error(i18n.global.t(&#39;msg.login.passwordRule&#39;)))\n    &#125; else &#123;\n      callback()\n    &#125;\n  &#125;\n&#125;\n\n\n navbar 区域\nlayout/components/navbar\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;navbar&quot;&gt;\n    ...\n        &lt;template #dropdown&gt;\n          &lt;el-dropdown-menu class&#x3D;&quot;user-dropdown&quot;&gt;\n            &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;\n              &lt;el-dropdown-item&gt; &#123;&#123; $t(&#39;msg.navBar.home&#39;) &#125;&#125; &lt;&#x2F;el-dropdown-item&gt;\n            &lt;&#x2F;router-link&gt;\n            &lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;&quot;&gt;\n              &lt;el-dropdown-item&gt;&#123;&#123; $t(&#39;msg.navBar.course&#39;) &#125;&#125;&lt;&#x2F;el-dropdown-item&gt;\n            &lt;&#x2F;a&gt;\n            &lt;el-dropdown-item divided @click&#x3D;&quot;logout&quot;&gt;\n              &#123;&#123; $t(&#39;msg.navBar.logout&#39;) &#125;&#125;\n            &lt;&#x2F;el-dropdown-item&gt;\n          &lt;&#x2F;el-dropdown-menu&gt;\n        &lt;&#x2F;template&gt;\n      &lt;&#x2F;el-dropdown&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\ncomponents/LangSelect/index\n&lt;el-tooltip :content&#x3D;&quot;$t(&#39;msg.navBar.lang&#39;)&quot; :effect&#x3D;&quot;effect&quot;&gt;\n       ...\n    \n    \nconst handleSetLanguage &#x3D; lang &#x3D;&gt; &#123;\n  ...\n  ElMessage.success(i18n.t(&#39;msg.toast.switchLangSuccess&#39;))\n&#125;\n\n\n\n5-08：方案落地：sidebar 与 面包屑 区域的国际化处理sidebar 区域\n目前对于 sidebar 而言，显示的文本是我们在定义路由表时的 title\n&lt;span&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;span&gt;\n\n我们可以 把 title 作为语言包内容的 key 进行处理\n创建 utils/i18n 工具模块，用于 将 title 转化为国际化内容\nimport i18n from &#39;@&#x2F;i18n&#39;\nexport function generateTitle(title) &#123;\n  return i18n.global.t(&#39;msg.route.&#39; + title)\n&#125;\n\n\n在 layout/components/Sidebar/MenuItem.vue 中导入该方法：\n&lt;template&gt;\n  ...\n  &lt;span&gt;&#123;&#123; generateTitle(title) &#125;&#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; generateTitle &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n...\n&lt;&#x2F;script&gt;\n\n\n最后修改下 sidebarHeader 的内容\n&lt;h1 class&#x3D;&quot;logo-title&quot; v-if&#x3D;&quot;$store.getters.sidebarOpened&quot;&gt;\n\timooc-admin\n&lt;&#x2F;h1&gt;\n\n\n\n面包屑区域：\n在 components/Breadcrumb/index\n&lt;template&gt;\n...\n    &lt;!-- 不可点击项 --&gt;\n    &lt;span v-if&#x3D;&quot;index &#x3D;&#x3D;&#x3D; breadcrumbData.length - 1&quot; class&#x3D;&quot;no-redirect&quot;&gt;&#123;&#123;\n        generateTitle(item.meta.title)\n        &#125;&#125;&lt;&#x2F;span&gt;\n    &lt;!-- 可点击项 --&gt;\n    &lt;a v-else class&#x3D;&quot;redirect&quot; @click.prevent&#x3D;&quot;onLinkClick(item)&quot;&gt;&#123;&#123;\n        generateTitle(item.meta.title)\n        &#125;&#125;&lt;&#x2F;a&gt;\n...\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; generateTitle &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n...\n&lt;&#x2F;script&gt;\n\n\n\n\n5-09：方案落地：国际化缓存处理我们希望在 刷新页面后，当前的国际化选择可以被保留，所以想要实现这个功能，那么就需要进行 国际化的缓存处理\n此处的缓存，我们依然通过两个方面进行：\n\nvuex 缓存\nLocalStorage 缓存\n\n只不过这里的缓存，我们已经在处理 langSelect 组件时 处理完成了，所以此时我们只需要使用缓存下来的数据即可。\n在 i18n/index 中，创建 getLanguage 方法：\nimport store from &#39;@&#x2F;store&#39;\n&#x2F;**\n * 返回当前 lang\n *&#x2F;\nfunction getLanguage() &#123;\n  return store &amp;&amp; store.getters &amp;&amp; store.getters.language\n&#125;\n\n修改 createI18n 的 locale 为 getLanguage() \nconst i18n &#x3D; createI18n(&#123;\n  ...\n  locale: getLanguage()\n&#125;)\n\n\n\n5-10：国际化方案总结国际化是前端项目中的一个非常常见的功能，那么在前端项目中实现国际化主要依靠的就是 vue-i18n 这个第三方的包。\n关于国际化的实现原理大家可以参照 国际化实现原理 这一小节，这里我们就不再赘述了。\n而  i18n 的使用，整体来说就分为这么四步：\n\n创建 messages 数据源\n创建 locale 语言变量\n初始化 i18n 实例\n注册 i18n 实例\n\n核心的内容其实就是 数据源的部分，但是大家需要注意，如果你的项目中使用了 第三方组件库 ，那么不要忘记 第三方组件库的数据源 需要 单独 进行处理！\n接下来我们来处理 动态换肤 功能。\n关于 动态换肤 我们之前已经提到过了，在 layout/components/Sidebar/SidebarMenu.vue 中，我们实现 el-menu 的背景色时，说过：此处将来会实现换肤功能，所以我们不能直接写死，而需要通过一个动态的值，来进行指定\n&lt;el-menu\n    :default-active&#x3D;&quot;activeMenu&quot;\n    :collapse&#x3D;&quot;!$store.getters.sidebarOpened&quot;\n    :background-color&#x3D;&quot;$store.getters.cssVar.menuBg&quot;\n    :text-color&#x3D;&quot;$store.getters.cssVar.menuText&quot;\n    :active-text-color&#x3D;&quot;$store.getters.cssVar.menuActiveText&quot;\n    :unique-opened&#x3D;&quot;true&quot;\n    router\n  &gt;x&#39;z\n    ...\n  &lt;&#x2F;el-menu&gt;\n\n那么换句话而言，想要实现 动态换肤 的一个前置条件就是：色值不可以写死！\n那么为什么会有这个前置条件呢？动态换肤又是如何来去实现的呢？这一小节我们来看一下这个问题。\n首先我们先来说一下动态换肤的实现方式。\n在 scss 中，我们可以通过 $变量名:变量值 的方式定义  css 变量，然后通过该 css 变量 来去指定某一块 DOM 对应的颜色。\n那么大家可以想一下，如果我此时改变了该 css 变量 的值，那么所对应的 DOM 颜色是不是也会同步发生变化？\n当大量的 DOM 都依赖于这个 css 变量 设置颜色时，我们是不是只需要改变这个 css 变量，那么所有 DOM 的颜色是不是都会发生变化，所谓的 动态换肤 是不是就可以实现了！\n这个就是实现 动态换肤 的原理。\n而在我们的项目中想要实现动态换肤，需要同时处理两个方面的内容：\n\nelement-plus 主题\n非 element-plus 主题\n\n那么下面我们就分别来去处理这两块主题对应的内容\n5-11：动态换肤原理分析接下来我们来处理 动态换肤 功能\n关于 动态换肤 我们之前已经提到过了，在 layout/components/SidebarMenu.vue 中，我们实现 el-menu 的背景色时，说过 此处将来会实现换肤功能，所以我们不能直接写死，而需要通过一个动态的值进行指定\n&lt;el-menu\n   :default-active&#x3D;&quot;activeMenu&quot;\n   :collapse&#x3D;&quot;!$store.getters.sidebarOpened&quot;\n   :background-color&#x3D;&quot;$store.getters.cssVar.menuBg&quot;\n   :text-color&#x3D;&quot;$store.getters.cssVar.menuText&quot;\n   :active-text-color&#x3D;&quot;$store.getters.cssVar.menuActiveText&quot;\n   :unique-opened&#x3D;&quot;true&quot;\n   router\n &gt;\n\n那么换句话而言，想要实现 动态换肤 的一个前置条件就是：色值不可以写死！\n那么为什么会有这个前置条件呢？动态换肤又是如何去进行实现的呢？这一小节我们来看一下这个问题。\n首先我们先来说一下动态换肤的实现方式。\n在 scss 中，我们可以通过 $变量名:变量值 的方式定义 css 变量 ，然后通过该 css 来去指定某一块 DOM 对应的颜色。\n那么大家可以想一下，如果我此时改变了该 css 变量的值，那么对应的 DOM 颜色是不是也会同步发生变化。\n当大量的 DOM 都依赖这个 css 变量 设置颜色时，我们是不是只需要改变这个 css 变量 ，那么所有 DOM 的颜色是不是都会发生变化，所谓的 动态换肤 是不是就可以实现了！\n这个就是 动态换肤 的实现原理\n而在我们的项目中想要实现动态换肤，需要同时处理两个方面的内容：\n\nelement-plus 主题\n非 element-plus 主题\n\n那么下面我们就分别来去处理这两块主题对应的内容\n5-12：动态换肤实现方案分析明确好了原理之后，接下来我们就来理一下咱们的实现思路。\n从原理中我们可以得到以下两个关键信息：\n\n动态换肤的关键是修改 css 变量 的值\n换肤需要同时兼顾\nelement-plus \n非 element-plus\n\n\n\n那么根据以上关键信息，我们就可以得出对应的实现方案\n\n创建一个组件 ThemeSelect 用来处理修改之后的 css 变量 的值\n根据新值修改 element-plus  主题色\n根据新值修改非 element-plus  主题色\n\n5-13：方案落地：创建  ThemeSelect 组件查看完成之后的项目我们可以发现，ThemeSelect 组件将由两部分组成：\n\nnavbar 中的展示图标\n选择颜色的弹出层\n\n那么本小节我们就先来处理第一个 navbar 中的展示图标\n创建 components/ThemeSelect/index 组件\n&lt;template&gt;\n  &lt;!-- 主题图标  \n  v-bind：https:&#x2F;&#x2F;v3.cn.vuejs.org&#x2F;api&#x2F;instance-properties.html#attrs --&gt;\n  &lt;el-dropdown\n    v-bind&#x3D;&quot;$attrs&quot;\n    trigger&#x3D;&quot;click&quot;\n    class&#x3D;&quot;theme&quot;\n    @command&#x3D;&quot;handleSetTheme&quot;\n  &gt;\n    &lt;div&gt;\n      &lt;el-tooltip :content&#x3D;&quot;$t(&#39;msg.navBar.themeChange&#39;)&quot;&gt;\n        &lt;svg-icon icon&#x3D;&quot;change-theme&quot; &#x2F;&gt;\n      &lt;&#x2F;el-tooltip&gt;\n    &lt;&#x2F;div&gt;\n    &lt;template #dropdown&gt;\n      &lt;el-dropdown-menu&gt;\n        &lt;el-dropdown-item command&#x3D;&quot;color&quot;&gt;\n          &#123;&#123; $t(&#39;msg.theme.themeColorChange&#39;) &#125;&#125;\n        &lt;&#x2F;el-dropdown-item&gt;\n      &lt;&#x2F;el-dropdown-menu&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;el-dropdown&gt;\n  &lt;!-- 展示弹出层 --&gt;\n  &lt;div&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nconst handleSetTheme &#x3D; command &#x3D;&gt; &#123;&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;\n\n\n在 layout/components/navbar 中进行引用\n&lt;div class&#x3D;&quot;right-menu&quot;&gt;\n      &lt;theme-picker class&#x3D;&quot;right-menu-item hover-effect&quot;&gt;&lt;&#x2F;theme-picker&gt;\n      \nimport ThemePicker from &#39;@&#x2F;components&#x2F;ThemeSelect&#x2F;index&#39;\n\n5-14：方案落地：创建  SelectColor 组件在有了 ThemeSelect  之后，接下来我们来去处理颜色选择的组件 SelectColor，在这里我们会用到 element 中的 el-color-picker 组件\n对于 SelectColor 的处理，我们需要分成两步进行：\n\n完成 SelectColor 弹窗展示的双向数据绑定\n把选中的色值进行本地缓存\n\n那么下面咱们先来看第一步：完成 SelectColor 弹窗展示的双向数据绑定\n创建 components/ThemePicker/components/SelectColor.vue \n&lt;template&gt;\n  &lt;el-dialog title&#x3D;&quot;提示&quot; :model-value&#x3D;&quot;modelValue&quot; @close&#x3D;&quot;closed&quot; width&#x3D;&quot;22%&quot;&gt;\n    &lt;div class&#x3D;&quot;center&quot;&gt;\n      &lt;p class&#x3D;&quot;title&quot;&gt;&#123;&#123; $t(&#39;msg.theme.themeColorChange&#39;) &#125;&#125;&lt;&#x2F;p&gt;\n      &lt;el-color-picker\n        v-model&#x3D;&quot;mColor&quot;\n        :predefine&#x3D;&quot;predefineColors&quot;\n      &gt;&lt;&#x2F;el-color-picker&gt;\n    &lt;&#x2F;div&gt;\n    &lt;template #footer&gt;\n      &lt;span class&#x3D;&quot;dialog-footer&quot;&gt;\n        &lt;el-button @click&#x3D;&quot;closed&quot;&gt;&#123;&#123; $t(&#39;msg.universal.cancel&#39;) &#125;&#125;&lt;&#x2F;el-button&gt;\n        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;comfirm&quot;&gt;&#123;&#123;\n          $t(&#39;msg.universal.confirm&#39;)\n        &#125;&#125;&lt;&#x2F;el-button&gt;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; defineProps, defineEmits, ref &#125; from &#39;vue&#39;\ndefineProps(&#123;\n  modelValue: &#123;\n    type: Boolean,\n    required: true\n  &#125;\n&#125;)\nconst emits &#x3D; defineEmits([&#39;update:modelValue&#39;])\n\n&#x2F;&#x2F; 预定义色值\nconst predefineColors &#x3D; [\n  &#39;#ff4500&#39;,\n  &#39;#ff8c00&#39;,\n  &#39;#ffd700&#39;,\n  &#39;#90ee90&#39;,\n  &#39;#00ced1&#39;,\n  &#39;#1e90ff&#39;,\n  &#39;#c71585&#39;,\n  &#39;rgba(255, 69, 0, 0.68)&#39;,\n  &#39;rgb(255, 120, 0)&#39;,\n  &#39;hsv(51, 100, 98)&#39;,\n  &#39;hsva(120, 40, 94, 0.5)&#39;,\n  &#39;hsl(181, 100%, 37%)&#39;,\n  &#39;hsla(209, 100%, 56%, 0.73)&#39;,\n  &#39;#c7158577&#39;\n]\n&#x2F;&#x2F; 默认色值\nconst mColor &#x3D; ref(&#39;#00ff00&#39;)\n\n&#x2F;**\n * 关闭\n *&#x2F;\nconst closed &#x3D; () &#x3D;&gt; &#123;\n  emits(&#39;update:modelValue&#39;, false)\n&#125;\n&#x2F;**\n * 确定\n * 1. 修改主题色\n * 2. 保存最新的主题色\n * 3. 关闭 dialog\n *&#x2F;\nconst comfirm &#x3D; async () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 3. 关闭 dialog\n  closed()\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.center &#123;\n  text-align: center;\n  .title &#123;\n    margin-bottom: 12px;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n\n\n在 ThemePicker/index 中使用该组件\n&lt;template&gt;\n  ...\n  &lt;!-- 展示弹出层 --&gt;\n  &lt;div&gt;\n    &lt;select-color v-model&#x3D;&quot;selectColorVisible&quot;&gt;&lt;&#x2F;select-color&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport SelectColor from &#39;.&#x2F;components&#x2F;SelectColor.vue&#39;\nimport &#123; ref &#125; from &#39;vue&#39;\n\nconst selectColorVisible &#x3D; ref(false)\nconst handleSetTheme &#x3D; command &#x3D;&gt; &#123;\n  selectColorVisible.value &#x3D; true\n&#125;\n&lt;&#x2F;script&gt;\n\n\n 完成双向数据绑定之后，我们来处理第二步：把选中的色值进行本地缓存\n缓存的方式分为两种：\n\nvuex\n本地存储\n\n在 constants/index 下新建常量值\n&#x2F;&#x2F; 主题色保存的 key\nexport const MAIN_COLOR &#x3D; &#39;mainColor&#39;\n&#x2F;&#x2F; 默认色值\nexport const DEFAULT_COLOR &#x3D; &#39;#409eff&#39;\n\n创建 store/modules/theme 模块，用来处理 主题色 相关内容\nimport &#123; getItem, setItem &#125; from &#39;@&#x2F;utils&#x2F;storage&#39;\nimport &#123; MAIN_COLOR, DEFAULT_COLOR &#125; from &#39;@&#x2F;constant&#39;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;\n    mainColor: getItem(MAIN_COLOR) || DEFAULT_COLOR\n  &#125;),\n  mutations: &#123;\n    &#x2F;**\n     * 设置主题色\n     *&#x2F;\n    setMainColor(state, newColor) &#123;\n      state.mainColor &#x3D; newColor\n      setItem(MAIN_COLOR, newColor)\n    &#125;\n  &#125;\n&#125;\n\n在 store/getters 下指定快捷访问\nmainColor: state &#x3D;&gt; state.theme.mainColor\n\n在 store/index 中导入 theme\n...\nimport theme from &#39;.&#x2F;modules&#x2F;theme.js&#39;\n\nexport default createStore(&#123;\n  getters,\n  modules: &#123;\n    ...\n    theme\n  &#125;\n&#125;)\n\n在 selectColor 中，设置初始色值 和  缓存色值\n...\n\n&lt;script setup&gt;\nimport &#123; defineProps, defineEmits, ref &#125; from &#39;vue&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\n...\nconst store &#x3D; useStore()\n&#x2F;&#x2F; 默认色值\nconst mColor &#x3D; ref(store.getters.mainColor)\n...\n&#x2F;**\n * 确定\n * 1. 修改主题色\n * 2. 保存最新的主题色\n * 3. 关闭 dialog\n *&#x2F;\nconst comfirm &#x3D; async () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 2. 保存最新的主题色\n  store.commit(&#39;theme&#x2F;setMainColor&#39;, mColor.value)\n  &#x2F;&#x2F; 3. 关闭 dialog\n  closed()\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n5-15：方案落地：处理 element-plus 主题变更原理与步骤分析对于 element-plus 的主题变更，相对比较复杂，所以说整个过程我们会分为三部分：\n\n实现原理\n实现步骤\n实现过程\n\n实现原理：\n在之前我们分析主题变更的实现原理时，我们说过，核心的原理是：**通过修改 scss 变量 ** 的形式修改主题色完成主题变更\n但是对于 element-plus 而言，我们怎么去修改这样的主题色呢？\n其实整体的原理非常简单，分为三步：\n\n获取当前 element-plus 的所有样式\n找到我们想要替换的样式部分，通过正则完成替换\n把替换后的样式写入到 style 标签中，利用样式优先级的特性，替代固有样式\n\n实现步骤：\n那么明确了原理之后，我们的实现步骤也就呼之欲出了，对应原理总体可分为四步：\n\n获取当前 element-plus 的所有样式\n定义我们要替换之后的样式\n在原样式中，利用正则替换新样式\n把替换后的样式写入到 style 标签中\n\n5-16：方案落地：处理 element-plus 主题变更创建 utils/theme 工具类，写入两个方法\n&#x2F;**\n * 写入新样式到 style\n * @param &#123;*&#125; elNewStyle  element-plus 的新样式\n * @param &#123;*&#125; isNewStyleTag 是否生成新的 style 标签\n *&#x2F;\nexport const writeNewStyle &#x3D; elNewStyle &#x3D;&gt; &#123;\n  \n&#125;\n\n&#x2F;**\n * 根据主色值，生成最新的样式表\n *&#x2F;\nexport const generateNewStyle &#x3D;  primaryColor &#x3D;&gt; &#123;\n \n&#125;\n\n那么接下来我们先实现第一个方法 generateNewStyle，在实现的过程中，我们需要安装两个工具类：\n\nrgb-hex：转换RGB(A)颜色为十六进制\ncss-color-function：在CSS中提出的颜色函数的解析器和转换器\n\n然后还需要写入一个 颜色转化计算器  formula.json\n创建 constants/formula.json （https://gist.github.com/benfrain/7545629）\n&#123;\n  &quot;shade-1&quot;: &quot;color(primary shade(10%))&quot;,\n  &quot;light-1&quot;: &quot;color(primary tint(10%))&quot;,\n  &quot;light-2&quot;: &quot;color(primary tint(20%))&quot;,\n  &quot;light-3&quot;: &quot;color(primary tint(30%))&quot;,\n  &quot;light-4&quot;: &quot;color(primary tint(40%))&quot;,\n  &quot;light-5&quot;: &quot;color(primary tint(50%))&quot;,\n  &quot;light-6&quot;: &quot;color(primary tint(60%))&quot;,\n  &quot;light-7&quot;: &quot;color(primary tint(70%))&quot;,\n  &quot;light-8&quot;: &quot;color(primary tint(80%))&quot;,\n  &quot;light-9&quot;: &quot;color(primary tint(90%))&quot;,\n  &quot;subMenuHover&quot;: &quot;color(primary tint(70%))&quot;,\n  &quot;subMenuBg&quot;: &quot;color(primary tint(80%))&quot;,\n  &quot;menuHover&quot;: &quot;color(primary tint(90%))&quot;,\n  &quot;menuBg&quot;: &quot;color(primary)&quot;\n&#125;\n\n准备就绪后，我们来实现 generateNewStyle 方法：\nimport color from &#39;css-color-function&#39;\nimport rgbHex from &#39;rgb-hex&#39;\nimport formula from &#39;@&#x2F;constant&#x2F;formula.json&#39;\nimport axios from &#39;axios&#39;\n\n&#x2F;**\n * 根据主色值，生成最新的样式表\n *&#x2F;\nexport const generateNewStyle &#x3D; async primaryColor &#x3D;&gt; &#123;\n  const colors &#x3D; generateColors(primaryColor)\n  let cssText &#x3D; await getOriginalStyle()\n\n  &#x2F;&#x2F; 遍历生成的样式表，在 CSS 的原样式中进行全局替换\n  Object.keys(colors).forEach(key &#x3D;&gt; &#123;\n    cssText &#x3D; cssText.replace(\n      new RegExp(&#39;(:|\\\\s+)&#39; + key, &#39;g&#39;),\n      &#39;$1&#39; + colors[key]\n    )\n  &#125;)\n\n  return cssText\n&#125;\n\n&#x2F;**\n * 根据主色生成色值表\n *&#x2F;\nexport const generateColors &#x3D; primary &#x3D;&gt; &#123;\n  if (!primary) return\n  const colors &#x3D; &#123;\n    primary\n  &#125;\n  Object.keys(formula).forEach(key &#x3D;&gt; &#123;\n    const value &#x3D; formula[key].replace(&#x2F;primary&#x2F;g, primary)\n    colors[key] &#x3D; &#39;#&#39; + rgbHex(color.convert(value))\n  &#125;)\n  return colors\n&#125;\n\n&#x2F;**\n * 获取当前 element-plus 的默认样式表\n *&#x2F;\nconst getOriginalStyle &#x3D; async () &#x3D;&gt; &#123;\n  const version &#x3D; require(&#39;element-plus&#x2F;package.json&#39;).version\n  const url &#x3D; &#96;https:&#x2F;&#x2F;unpkg.com&#x2F;element-plus@$&#123;version&#125;&#x2F;dist&#x2F;index.css&#96;\n  const &#123; data &#125; &#x3D; await axios(url)\n  &#x2F;&#x2F; 把获取到的数据筛选为原样式模板\n  return getStyleTemplate(data)\n&#125;\n\n&#x2F;**\n * 返回 style 的 template\n *&#x2F;\nconst getStyleTemplate &#x3D; data &#x3D;&gt; &#123;\n  &#x2F;&#x2F; element-plus 默认色值\n  const colorMap &#x3D; &#123;\n    &#39;#3a8ee6&#39;: &#39;shade-1&#39;,\n    &#39;#409eff&#39;: &#39;primary&#39;,\n    &#39;#53a8ff&#39;: &#39;light-1&#39;,\n    &#39;#66b1ff&#39;: &#39;light-2&#39;,\n    &#39;#79bbff&#39;: &#39;light-3&#39;,\n    &#39;#8cc5ff&#39;: &#39;light-4&#39;,\n    &#39;#a0cfff&#39;: &#39;light-5&#39;,\n    &#39;#b3d8ff&#39;: &#39;light-6&#39;,\n    &#39;#c6e2ff&#39;: &#39;light-7&#39;,\n    &#39;#d9ecff&#39;: &#39;light-8&#39;,\n    &#39;#ecf5ff&#39;: &#39;light-9&#39;\n  &#125;\n  &#x2F;&#x2F; 根据默认色值为要替换的色值打上标记\n  Object.keys(colorMap).forEach(key &#x3D;&gt; &#123;\n    const value &#x3D; colorMap[key]\n    data &#x3D; data.replace(new RegExp(key, &#39;ig&#39;), value)\n  &#125;)\n  return data\n&#125;\n\n\n\n\n接下来处理 writeNewStyle 方法：\n&#x2F;**\n * 写入新样式到 style\n * @param &#123;*&#125; elNewStyle  element-plus 的新样式\n * @param &#123;*&#125; isNewStyleTag 是否生成新的 style 标签\n *&#x2F;\nexport const writeNewStyle &#x3D; elNewStyle &#x3D;&gt; &#123;\n  const style &#x3D; document.createElement(&#39;style&#39;)\n  style.innerText &#x3D; elNewStyle\n  document.head.appendChild(style)\n&#125;\n\n最后在 SelectColor.vue 中导入这两个方法：\n...\n\n&lt;script setup&gt;\n...\nimport &#123; generateNewStyle, writeNewStyle &#125; from &#39;@&#x2F;utils&#x2F;theme&#39;\n...\n&#x2F;**\n * 确定\n * 1. 修改主题色\n * 2. 保存最新的主题色\n * 3. 关闭 dialog\n *&#x2F;\n\nconst comfirm &#x3D; async () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 1.1 获取主题色\n  const newStyleText &#x3D; await generateNewStyle(mColor.value)\n  &#x2F;&#x2F; 1.2 写入最新主题色\n  writeNewStyle(newStyleText)\n  &#x2F;&#x2F; 2. 保存最新的主题色\n  store.commit(&#39;theme&#x2F;setMainColor&#39;, mColor.value)\n  &#x2F;&#x2F; 3. 关闭 dialog\n  closed()\n&#125;\n&lt;&#x2F;script&gt;\n\n\n一些处理完成之后，我们可以在 profile 中通过一些代码进行测试：\n&lt;el-row&gt;\n      &lt;el-button&gt;Default&lt;&#x2F;el-button&gt;\n      &lt;el-button type&#x3D;&quot;primary&quot;&gt;Primary&lt;&#x2F;el-button&gt;\n      &lt;el-button type&#x3D;&quot;success&quot;&gt;Success&lt;&#x2F;el-button&gt;\n      &lt;el-button type&#x3D;&quot;info&quot;&gt;Info&lt;&#x2F;el-button&gt;\n      &lt;el-button type&#x3D;&quot;warning&quot;&gt;Warning&lt;&#x2F;el-button&gt;\n      &lt;el-button type&#x3D;&quot;danger&quot;&gt;Danger&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;el-row&gt;\n\n\n\n5-17：方案落地：element-plus 新主题的立即生效到目前我们已经完成了 element-plus 的主题变更，但是当前的主题变更还有一个小问题，那就是：在刷新页面后，新主题会失效\n那么出现这个问题的原因，非常简单：因为没有写入新的 style\n所以我们只需要在 应用加载后，写入 style 即可\n那么写入的时机，我们可以放入到 app.vue 中\n&lt;script setup&gt;\nimport &#123; useStore &#125; from &#39;vuex&#39;\nimport &#123; generateNewStyle, writeNewStyle &#125; from &#39;@&#x2F;utils&#x2F;theme&#39;\n\nconst store &#x3D; useStore()\ngenerateNewStyle(store.getters.mainColor).then(newStyleText &#x3D;&gt; &#123;\n  writeNewStyle(newStyleText)\n&#125;)\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n5-18：方案落地：自定义主题变更自定义主题变更相对来说比较简单，因为 自己的代码更加可控。\n目前在我们的代码中，需要进行 自定义主题变更 为  menu 菜单背景色\n而目前指定 menu 菜单背景色的位置在 layout/components/sidebar/SidebarMenu.vue 中\n&lt;el-menu\n  :default-active&#x3D;&quot;activeMenu&quot;\n  :collapse&#x3D;&quot;!$store.getters.sidebarOpened&quot;\n  :background-color&#x3D;&quot;$store.getters.cssVar.menuBg&quot;\n  :text-color&#x3D;&quot;$store.getters.cssVar.menuText&quot;\n  :active-text-color&#x3D;&quot;$store.getters.cssVar.menuActiveText&quot;\n  :unique-opened&#x3D;&quot;true&quot;\n  router\n&gt;\n\n此处的 背景色是通过 getters 进行指定的，该 cssVar 的 getters 为：\ncssVar: state &#x3D;&gt; variables,\n\n所以，我们想要修改 自定义主题 ，只需要从这里入手即可。\n根据当前保存的 mainColor 覆盖原有的默认色值\nimport variables from &#39;@&#x2F;styles&#x2F;variables.scss&#39;\nimport &#123; MAIN_COLOR &#125; from &#39;@&#x2F;constant&#39;\nimport &#123; getItem &#125; from &#39;@&#x2F;utils&#x2F;storage&#39;\nimport &#123; generateColors &#125; from &#39;@&#x2F;utils&#x2F;theme&#39;\n\nconst getters &#x3D; &#123;\n  ...\n  cssVar: state &#x3D;&gt; &#123;\n    return &#123;\n      ...variables,\n      ...generateColors(getItem(MAIN_COLOR))\n    &#125;\n  &#125;,\n  ...\n&#125;\nexport default getters\n\n\n但是我们这样设定之后，整个自定义主题变更，还存在两个问题：\n\nmenuBg 背景颜色没有变化\n\n这个问题是因为咱们的 sidebar 的背景色未被替换，所以我们可以在 layout/index 中设置 sidebar 的 backgroundColor\n&lt;sidebar\n      id&#x3D;&quot;guide-sidebar&quot;\n      class&#x3D;&quot;sidebar-container&quot;\n      :style&#x3D;&quot;&#123; backgroundColor: $store.getters.cssVar.menuBg &#125;&quot;\n    &#x2F;&gt;\n\n\n\n\n主题色替换之后，需要刷新页面才可响应\n\n这个是因为 getters 中没有监听到 依赖值的响应变化，所以我们希望修改依赖值\n在 store/modules/theme 中\n...\nimport variables from &#39;@&#x2F;styles&#x2F;variables.scss&#39;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;\n    ...\n    variables\n  &#125;),\n  mutations: &#123;\n    &#x2F;**\n     * 设置主题色\n     *&#x2F;\n    setMainColor(state, newColor) &#123;\n      ...\n      state.variables.menuBg &#x3D; newColor\n      ...\n    &#125;\n  &#125;\n&#125;\n\n\n在 getters 中\n....\n\nconst getters &#x3D; &#123;\n ...\n  cssVar: state &#x3D;&gt; &#123;\n    return &#123;\n      ...state.theme.variables,\n      ...generateColors(getItem(MAIN_COLOR))\n    &#125;\n  &#125;,\n  ...\n&#125;\nexport default getters\n\n\n5-19：自定义主题方案总结那么到这里整个自定义主题我们就处理完成了。\n对于 自定义主题而言，核心的原理其实就是 修改scss变量来进行实现主题色变化 \n明确好了原理之后，对后续实现的步骤就具体情况具体分析了。\n\n对于 element-plus：因为 element-plus 是第三方的包，所以它 不是完全可控 的，那么对于这种最简单直白的方案，就是直接拿到它编译后的 css 进行色值替换，利用 style 内部样式表 优先级高于 外部样式表 的特性，来进行主题替换\n对于自定义主题：因为自定义主题是 完全可控 的，所以我们实现起来就轻松很多，只需要修改对应的 scss变量即可\n\n那么在之后大家遇到 自定义主题 的处理时，就可以按照我们所梳理的方案进行处理了。\n5-20：screenfull 原理及方案分析接下来我们来看 screenfull （全屏） 功能实现\n对于 screenfull  和之前一样 ，我们还是先分析它的原理，然后在制定对应的方案实现\n原理：\n对于 screenfull  而言，浏览器本身已经提供了对用的 API，点击这里即可查看，这个 API 中，主要提供了两个方法：\n\nDocument.exitFullscreen()：该方法用于请求从全屏模式切换到窗口模式\nElement.requestFullscreen()：该方法用于请求浏览器（user agent）将特定元素（甚至延伸到它的后代元素）置为全屏模式\n比如我们可以通过 document.getElementById(&#39;app&#39;).requestFullscreen() 在获取 id=app 的 DOM 之后，把该区域置为全屏\n\n\n\n但是该方法存在一定的小问题，比如：\n\nappmain 区域背景颜色为黑色\n\n所以通常情况下我们不会直接使用该 API 来去实现全屏效果，而是会使用它的包装库 screenfull\n方案：\n那么明确好了原理之后，接下来实现方案就比较容易了。\n整体的方案实现分为两步：\n\n封装 screenfull 组件\n展示切换按钮\n基于 screenfull 实现切换功能\n\n\n在 navbar 中引入该组件\n\n5-21：方案落地：screenfull明确好了方案之后，接下来我们就落地该方案\n封装 screenfull 组件：\n\n下来依赖包  screenfull \nnpm i screenfull@5.1.0\n\n创建 components/Screenfull/index\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;svg-icon\n      :icon&#x3D;&quot;isFullscreen ? &#39;exit-fullscreen&#39; : &#39;fullscreen&#39;&quot;\n      @click&#x3D;&quot;onToggle&quot;\n    &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref, onMounted, onUnmounted &#125; from &#39;vue&#39;\nimport screenfull from &#39;screenfull&#39;\n\n&#x2F;&#x2F; 是否全屏\nconst isFullscreen &#x3D; ref(false)\n\n&#x2F;&#x2F; 监听变化\nconst change &#x3D; () &#x3D;&gt; &#123;\n  isFullscreen.value &#x3D; screenfull.isFullscreen\n&#125;\n\n&#x2F;&#x2F; 切换事件\nconst onToggle &#x3D; () &#x3D;&gt; &#123;\n  screenfull.toggle()\n&#125;\n\n&#x2F;&#x2F; 设置侦听器\nonMounted(() &#x3D;&gt; &#123;\n  screenfull.on(&#39;change&#39;, change)\n&#125;)\n\n&#x2F;&#x2F; 删除侦听器\nonUnmounted(() &#x3D;&gt; &#123;\n  screenfull.off(&#39;change&#39;, change)\n&#125;)\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;\n\n\n在 navbar 中引入该组件：\n&lt;screenfull class&#x3D;&quot;right-menu-item hover-effect&quot; &#x2F;&gt;\nimport Screenfull from &#39;@&#x2F;components&#x2F;Screenfull&#39;\n\n\n\n5-22：headerSearch 原理及方案分析\n\n\n\n\n\n\n\n\n所谓 headerSearch 指 页面搜索\n原理：\nheaderSearch 是复杂后台系统中非常常见的一个功能，它可以：在指定搜索框中对当前应用中所有页面进行检索，以 select 的形式展示出被检索的页面，以达到快速进入的目的\n那么明确好了 headerSearch  的作用之后，接下来我们来看一下对应的实现原理\n根据前面的目的我们可以发现，整个 headerSearch 其实可以分为三个核心的功能点：\n\n根据指定内容对所有页面进行检索\n以 select 形式展示检索出的页面\n通过检索页面可快速进入对应页面\n\n那么围绕着这三个核心的功能点，我们想要分析它的原理就非常简单了：根据指定内容检索所有页面，把检索出的页面以 select 展示，点击对应 option 可进入\n方案：\n对照着三个核心功能点和原理，想要指定对应的实现方案是非常简单的一件事情了\n\n创建 headerSearch 组件，用作样式展示和用户输入内容获取\n获取所有的页面数据，用作被检索的数据源\n根据用户输入内容在数据源中进行 模糊搜索 \n把搜索到的内容以 select 进行展示\n监听 select 的 change 事件，完成对应跳转\n\n5-23：方案落地：创建 headerSearch 组件创建 components/headerSearch/index 组件：\n&lt;template&gt;\n  &lt;div :class&#x3D;&quot;&#123; show: isShow &#125;&quot; class&#x3D;&quot;header-search&quot;&gt;\n    &lt;svg-icon\n      class-name&#x3D;&quot;search-icon&quot;\n      icon&#x3D;&quot;search&quot;\n      @click.stop&#x3D;&quot;onShowClick&quot;\n    &#x2F;&gt;\n    &lt;el-select\n      ref&#x3D;&quot;headerSearchSelectRef&quot;\n      class&#x3D;&quot;header-search-select&quot;\n      v-model&#x3D;&quot;search&quot;\n      filterable\n      default-first-option\n      remote\n      placeholder&#x3D;&quot;Search&quot;\n      :remote-method&#x3D;&quot;querySearch&quot;\n      @change&#x3D;&quot;onSelectChange&quot;\n    &gt;\n      &lt;el-option\n        v-for&#x3D;&quot;option in 5&quot;\n        :key&#x3D;&quot;option&quot;\n        :label&#x3D;&quot;option&quot;\n        :value&#x3D;&quot;option&quot;\n      &gt;&lt;&#x2F;el-option&gt;\n    &lt;&#x2F;el-select&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\n\n&#x2F;&#x2F; 控制 search 显示\nconst isShow &#x3D; ref(false)\n&#x2F;&#x2F; el-select 实例\nconst headerSearchSelectRef &#x3D; ref(null)\nconst onShowClick &#x3D; () &#x3D;&gt; &#123;\n  isShow.value &#x3D; !isShow.value\n  headerSearchSelectRef.value.focus()\n&#125;\n\n&#x2F;&#x2F; search 相关\nconst search &#x3D; ref(&#39;&#39;)\n&#x2F;&#x2F; 搜索方法\nconst querySearch &#x3D; () &#x3D;&gt; &#123;\n  console.log(&#39;querySearch&#39;)\n&#125;\n&#x2F;&#x2F; 选中回调\nconst onSelectChange &#x3D; () &#x3D;&gt; &#123;\n  console.log(&#39;onSelectChange&#39;)\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.header-search &#123;\n  font-size: 0 !important;\n  .search-icon &#123;\n    cursor: pointer;\n    font-size: 18px;\n    vertical-align: middle;\n  &#125;\n  .header-search-select &#123;\n    font-size: 18px;\n    transition: width 0.2s;\n    width: 0;\n    overflow: hidden;\n    background: transparent;\n    border-radius: 0;\n    display: inline-block;\n    vertical-align: middle;\n\n    ::v-deep .el-input__inner &#123;\n      border-radius: 0;\n      border: 0;\n      padding-left: 0;\n      padding-right: 0;\n      box-shadow: none !important;\n      border-bottom: 1px solid #d9d9d9;\n      vertical-align: middle;\n    &#125;\n  &#125;\n  &amp;.show &#123;\n    .header-search-select &#123;\n      width: 210px;\n      margin-left: 10px;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n在 navbar 中导入该组件\n&lt;header-search class&#x3D;&quot;right-menu-item hover-effect&quot;&gt;&lt;&#x2F;header-search&gt;\nimport HeaderSearch from &#39;@&#x2F;components&#x2F;HeaderSearch&#39;\n\n在有了 headerSearch 之后，接下来就可以来处理对应的 检索数据源了\n检索数据源 表示：有哪些页面希望检索\n那么对于我们当前的业务而言，我们希望被检索的页面其实就是左侧菜单中的页面，那么我们检索数据源即为：左侧菜单对应的数据源\n根据以上原理，我们可以得出以下代码：\n&lt;script setup&gt;\nimport &#123; ref, computed &#125; from &#39;vue&#39;\nimport &#123; filterRouters, generateMenus &#125; from &#39;@&#x2F;utils&#x2F;route&#39;\nimport &#123; useRouter &#125; from &#39;vue-router&#39;\n...\n&#x2F;&#x2F; 检索数据源\nconst router &#x3D; useRouter()\nconst searchPool &#x3D; computed(() &#x3D;&gt; &#123;\n  const filterRoutes &#x3D; filterRouters(router.getRoutes())\n  console.log(generateMenus(filterRoutes))\n  return generateMenus(filterRoutes)\n&#125;)\nconsole.log(searchPool)\n&lt;&#x2F;script&gt;\n\n\n\n5-25：方案落地：对检索数据源进行模糊搜索如果我们想要进行  模糊搜索  的话，那么需要依赖一个第三方的库  fuse.js \n\n安装 fuse.js\nnpm install --save fuse.js@6.4.6\n\n初始化 Fuse，更多初始化配置项 可点击这里\nimport Fuse from &#39;fuse.js&#39;\n\n&#x2F;**\n * 搜索库相关\n *&#x2F;\nconst fuse &#x3D; new Fuse(list, &#123;\n    &#x2F;&#x2F; 是否按优先级进行排序\n    shouldSort: true,\n    &#x2F;&#x2F; 匹配长度超过这个值的才会被认为是匹配的\n    minMatchCharLength: 1,\n    &#x2F;&#x2F; 将被搜索的键列表。 这支持嵌套路径、加权搜索、在字符串和对象数组中搜索。\n    &#x2F;&#x2F; name：搜索的键\n    &#x2F;&#x2F; weight：对应的权重\n    keys: [\n      &#123;\n        name: &#39;title&#39;,\n        weight: 0.7\n      &#125;,\n      &#123;\n        name: &#39;path&#39;,\n        weight: 0.3\n      &#125;\n    ]\n  &#125;)\n\n\n参考 Fuse Demo 与 最终效果，可以得出，我们最终期望得到如下的检索数据源结构\n[\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;my&quot;,\n        &quot;title&quot;:[\n            &quot;个人中心&quot;\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;user&quot;,\n        &quot;title&quot;:[\n            &quot;用户&quot;\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;user&#x2F;manage&quot;,\n        &quot;title&quot;:[\n            &quot;用户&quot;,\n            &quot;用户管理&quot;\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;user&#x2F;info&quot;,\n        &quot;title&quot;:[\n            &quot;用户&quot;,\n            &quot;用户信息&quot;\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;article&quot;,\n        &quot;title&quot;:[\n            &quot;文章&quot;\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;article&#x2F;ranking&quot;,\n        &quot;title&quot;:[\n            &quot;文章&quot;,\n            &quot;文章排名&quot;\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;article&#x2F;create&quot;,\n        &quot;title&quot;:[\n            &quot;文章&quot;,\n            &quot;创建文章&quot;\n        ]\n    &#125;\n]\n\n所以我们之前处理了的数据源并不符合我们的需要，所以我们需要对数据源进行重新处理\n\n\n5-26：方案落地：数据源重处理，生成  searchPool在上一小节，我们明确了最终我们期望得到数据源结构，那么接下来我们就对重新计算数据源，生成对应的 searchPoll\n创建 compositions/HeaderSearch/FuseData.js\nimport path from &#39;path&#39;\nimport i18n from &#39;@&#x2F;i18n&#39;\n&#x2F;**\n * 筛选出可供搜索的路由对象\n * @param routes 路由表\n * @param basePath 基础路径，默认为 &#x2F;\n * @param prefixTitle\n *&#x2F;\nexport const generateRoutes &#x3D; (routes, basePath &#x3D; &#39;&#x2F;&#39;, prefixTitle &#x3D; []) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 创建 result 数据\n  let res &#x3D; []\n  &#x2F;&#x2F; 循环 routes 路由\n  for (const route of routes) &#123;\n    &#x2F;&#x2F; 创建包含 path 和 title 的 item\n    const data &#x3D; &#123;\n      path: path.resolve(basePath, route.path),\n      title: [...prefixTitle]\n    &#125;\n    &#x2F;&#x2F; 当前存在 meta 时，使用 i18n 解析国际化数据，组合成新的 title 内容\n    &#x2F;&#x2F; 动态路由不允许被搜索\n    &#x2F;&#x2F; 匹配动态路由的正则\n    const re &#x3D; &#x2F;.*\\&#x2F;:.*&#x2F;\n    if (route.meta &amp;&amp; route.meta.title &amp;&amp; !re.exec(route.path)) &#123;\n      const i18ntitle &#x3D; i18n.global.t(&#96;msg.route.$&#123;route.meta.title&#125;&#96;)\n      data.title &#x3D; [...data.title, i18ntitle]\n      res.push(data)\n    &#125;\n\n    &#x2F;&#x2F; 存在 children 时，迭代调用\n    if (route.children) &#123;\n      const tempRoutes &#x3D; generateRoutes(route.children, data.path, data.title)\n      if (tempRoutes.length &gt;&#x3D; 1) &#123;\n        res &#x3D; [...res, ...tempRoutes]\n      &#125;\n    &#125;\n  &#125;\n  return res\n&#125;\n\n\n在 headerSearch 中导入 generateRoutes\n&lt;script setup&gt;\nimport &#123; computed, ref &#125; from &#39;vue&#39;\nimport &#123; generateRoutes &#125; from &#39;.&#x2F;FuseData&#39;\nimport Fuse from &#39;fuse.js&#39;\nimport &#123; filterRouters &#125; from &#39;@&#x2F;utils&#x2F;route&#39;\nimport &#123; useRouter &#125; from &#39;vue-router&#39;\n\n...\n\n&#x2F;&#x2F; 检索数据源\nconst router &#x3D; useRouter()\nconst searchPool &#x3D; computed(() &#x3D;&gt; &#123;\n  const filterRoutes &#x3D; filterRouters(router.getRoutes())\n  return generateRoutes(filterRoutes)\n&#125;)\n&#x2F;**\n * 搜索库相关\n *&#x2F;\nconst fuse &#x3D; new Fuse(searchPool.value, &#123;\n  ...\n&#125;)\n&lt;&#x2F;script&gt;\n\n通过 querySearch 测试搜索结果\n&#x2F;&#x2F; 搜索方法\nconst querySearch &#x3D; query &#x3D;&gt; &#123;\n  console.log(fuse.search(query))\n&#125;\n\n5-27：方案落地：渲染检索数据数据源处理完成之后，最后我们就只需要完成:\n\n渲染检索出的数据\n完成对应跳转\n\n那么下面我们按照步骤进行实现：\n\n渲染检索出的数据\n&lt;template&gt;\n  &lt;el-option\n      v-for&#x3D;&quot;option in searchOptions&quot;\n      :key&#x3D;&quot;option.item.path&quot;\n      :label&#x3D;&quot;option.item.title.join(&#39; &gt; &#39;)&quot;\n      :value&#x3D;&quot;option.item&quot;\n  &gt;&lt;&#x2F;el-option&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\n...\n&#x2F;&#x2F; 搜索结果\nconst searchOptions &#x3D; ref([])\n&#x2F;&#x2F; 搜索方法\nconst querySearch &#x3D; query &#x3D;&gt; &#123;\n  if (query !&#x3D;&#x3D; &#39;&#39;) &#123;\n    searchOptions.value &#x3D; fuse.search(query)\n  &#125; else &#123;\n    searchOptions.value &#x3D; []\n  &#125;\n&#125;\n...\n&lt;&#x2F;script&gt;\n\n\n\n\n完成对应跳转\n&#x2F;&#x2F; 选中回调\nconst onSelectChange &#x3D; val &#x3D;&gt; &#123;\n  router.push(val.path)\n&#125;\n\n5-28：方案落地：剩余问题处理到这里我们的 headerSearch 功能基本上就已经处理完成了，但是还存在一些小 bug ，那么最后这一小节我们就处理下这些剩余的 bug\n\n在 search 打开时，点击 body 关闭 search\n在 search 关闭时，清理 searchOptions\nheaderSearch 应该具备国际化能力\n\n明确好问题之后，接下来我们进行处理\n首先我们先处理前前面两个问题：\n&#x2F;**\n * 关闭 search 的处理事件\n *&#x2F;\nconst onClose &#x3D; () &#x3D;&gt; &#123;\n  headerSearchSelectRef.value.blur()\n  isShow.value &#x3D; false\n  searchOptions.value &#x3D; []\n&#125;\n&#x2F;**\n * 监听 search 打开，处理 close 事件\n *&#x2F;\nwatch(isShow, val &#x3D;&gt; &#123;\n  if (val) &#123;\n    document.body.addEventListener(&#39;click&#39;, onClose)\n  &#125; else &#123;\n    document.body.removeEventListener(&#39;click&#39;, onClose)\n  &#125;\n&#125;)\n\n接下来是国际化的问题，想要处理这个问题非常简单，我们只需要：监听语言变化，重新计算数据源初始化 fuse 即可\n\n在 utils/i18n 下，新建方法 watchSwitchLang\nimport &#123; watch &#125; from &#39;vue&#39;\nimport store from &#39;@&#x2F;store&#39;\n\n&#x2F;**\n *\n * @param  &#123;...any&#125; cbs 所有的回调\n *&#x2F;\nexport function watchSwitchLang(...cbs) &#123;\n  watch(\n    () &#x3D;&gt; store.getters.language,\n    () &#x3D;&gt; &#123;\n      cbs.forEach(cb &#x3D;&gt; cb(store.getters.language))\n    &#125;\n  )\n&#125;\n\n在 headerSearch 监听变化，重新赋值\n&lt;script setup&gt;\n...\nimport &#123; watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n\n...\n\n&#x2F;&#x2F; 检索数据源\nconst router &#x3D; useRouter()\nlet searchPool &#x3D; computed(() &#x3D;&gt; &#123;\n  const filterRoutes &#x3D; filterRouters(router.getRoutes())\n  return generateRoutes(filterRoutes)\n&#125;)\n&#x2F;**\n * 搜索库相关\n *&#x2F;\nlet fuse\nconst initFuse &#x3D; searchPool &#x3D;&gt; &#123;\n  fuse &#x3D; new Fuse(searchPool, &#123;\n    ...\n&#125;\ninitFuse(searchPool.value)\n\n...\n\n&#x2F;&#x2F; 处理国际化\nwatchSwitchLang(() &#x3D;&gt; &#123;\n  searchPool &#x3D; computed(() &#x3D;&gt; &#123;\n    const filterRoutes &#x3D; filterRouters(router.getRoutes())\n    return generateRoutes(filterRoutes)\n  &#125;)\n  initFuse(searchPool.value)\n&#125;)\n&lt;&#x2F;script&gt;\n\n5-29：headerSearch 方案总结那么到这里整个的 headerSearch 我们就已经全部处理完成了，整个 headerSearch 我们只需要把握住三个核心的关键点\n\n根据指定内容对所有页面进行检索\n以 select 形式展示检索出的页面\n通过检索页面可快速进入对应页面\n\n保证大方向没有错误，那么具体的细节处理我们具体分析就可以了。\n关于细节的处理，可能比较复杂的地方有两个：\n\n模糊搜索\n检索数据源\n\n对于这两块，我们依赖于 fuse.js 进行了实现，大大简化了我们的业务处理流程。\n5-30：tagsView 原理及方案分析所谓 tagsView 可以分成两部分来去看：\n\ntags\nview\n\n好像和废话一样是吧。那怎么分开看呢？\n首先我们先来看 tags：\n所谓 tgas 指的是：位于 appmain 之上的标签\n那么现在我们忽略掉 view，现在只有一个要求：\n\n\n\n\n\n\n\n\n\n在 view 之上渲染这个 tag \n仅看这一个要求，很简单吧。\nviews：\n明确好了 tags 之后，我们来看 views。\n脱离了 tags 只看 views 就更简单了，所谓 views ：指的就是一个用来渲染组件的位置，就像我们之前的 Appmain 一样，只不过这里的 views 可能稍微复杂一点，因为它需要在渲染的基础上增加：\n\n动画\n缓存\n\n这两个额外的功能。\n加上这两个功能之后可能会略显复杂，但是 官网已经帮助我们处理了这个问题 \n所以 单看 views 也是一个很简单的功能。\n那么接下来我们需要做的就是把 tags 和 view 合并起来而已。\n那么明确好了原理之后，我们就来看 实现方案：\n\n创建 tagsView 组件：用来处理 tags 的展示\n处理基于路由的动态过渡，在 AppMain 中进行：用于处理 view 的部分\n\n整个的方案就是这么两大部，但是其中我们还需要处理一些细节相关的，完整的方案为：\n\n监听路由变化，组成用于渲染 tags 的数据源\n创建 tags 组件，根据数据源渲染 tag，渲染出来的 tags 需要同时具备\n国际化 title\n路由跳转\n\n\n处理鼠标右键效果，根据右键处理对应数据源\n处理基于路由的动态过渡\n\n那么明确好了方案之后，接下来我们根据方案进行处理即可。\n5-31：方案落地：创建 tags 数据源tags 的数据源分为两部分：\n\n保存数据：appmain 组件中进行\n展示数据：tags 组件中进行\n\n所以 tags 的数据我们最好把它保存到 vuex 中。\n\n在 constant 中新建常量\n&#x2F;&#x2F; tags\nexport const TAGS_VIEW &#x3D; &#39;tagsView&#39;\n\n在 store/app 中创建 tagsViewList\nimport &#123; LANG, TAGS_VIEW &#125; from &#39;@&#x2F;constant&#39;\nimport &#123; getItem, setItem &#125; from &#39;@&#x2F;utils&#x2F;storage&#39;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;\n    ...\n    tagsViewList: getItem(TAGS_VIEW) || []\n  &#125;),\n  mutations: &#123;\n    ...\n    &#x2F;**\n     * 添加 tags\n     *&#x2F;\n    addTagsViewList(state, tag) &#123;\n      const isFind &#x3D; state.tagsViewList.find(item &#x3D;&gt; &#123;\n        return item.path &#x3D;&#x3D;&#x3D; tag.path\n      &#125;)\n    &#x2F;&#x2F; 处理重复\n      if (!isFind) &#123;\n        state.tagsViewList.push(tag)\n        setItem(TAGS_VIEW, state.tagsViewList)\n      &#125;\n    &#125;\n  &#125;,\n  actions: &#123;&#125;\n&#125;\n\n\n在 appmain 中监听路由的变化\n&lt;script setup&gt;\nimport &#123; watch &#125; from &#39;vue&#39;\nimport &#123; isTags &#125; from &#39;@&#x2F;utils&#x2F;tags&#39;\nimport &#123; generateTitle &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\nimport &#123; useRoute &#125; from &#39;vue-router&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\n\nconst route &#x3D; useRoute()\n\n&#x2F;**\n * 生成 title\n *&#x2F;\nconst getTitle &#x3D; route &#x3D;&gt; &#123;\n  let title &#x3D; &#39;&#39;\n  if (!route.meta) &#123;\n    &#x2F;&#x2F; 处理无 meta 的路由\n    const pathArr &#x3D; route.path.split(&#39;&#x2F;&#39;)\n    title &#x3D; pathArr[pathArr.length - 1]\n  &#125; else &#123;\n    title &#x3D; generateTitle(route.meta.title)\n  &#125;\n  return title\n&#125;\n\n&#x2F;**\n * 监听路由变化\n *&#x2F;\nconst store &#x3D; useStore()\nwatch(\n  route,\n  (to, from) &#x3D;&gt; &#123;\n    if (!isTags(to.path)) return\n    const &#123; fullPath, meta, name, params, path, query &#125; &#x3D; to\n    store.commit(&#39;app&#x2F;addTagsViewList&#39;, &#123;\n      fullPath,\n      meta,\n      name,\n      params,\n      path,\n      query,\n      title: getTitle(to)\n    &#125;)\n  &#125;,\n  &#123;\n    immediate: true\n  &#125;\n)\n&lt;&#x2F;script&gt;\n\n\n\n创建 utils/tags\nconst whiteList &#x3D; [&#39;&#x2F;login&#39;, &#39;&#x2F;import&#39;, &#39;&#x2F;404&#39;, &#39;&#x2F;401&#39;]\n\n&#x2F;**\n * path 是否需要被缓存\n * @param &#123;*&#125; path\n * @returns\n *&#x2F;\nexport function isTags(path) &#123;\n  return !whiteList.includes(path)\n&#125;\n\n\n5-32：方案落地：生成 tagsView目前数据已经被保存到 store 中，那么接下来我们就依赖数据渲染 tags\n\n创建 store/app 中 tagsViewList 的快捷访问\ntagsViewList: state &#x3D;&gt; state.app.tagsViewList\n\n创建 components/tagsview\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;tags-view-container&quot;&gt;\n      &lt;router-link\n        class&#x3D;&quot;tags-view-item&quot;\n        :class&#x3D;&quot;isActive(tag) ? &#39;active&#39; : &#39;&#39;&quot;\n        :style&#x3D;&quot;&#123;\n          backgroundColor: isActive(tag) ? $store.getters.cssVar.menuBg : &#39;&#39;,\n          borderColor: isActive(tag) ? $store.getters.cssVar.menuBg : &#39;&#39;\n        &#125;&quot;\n        v-for&#x3D;&quot;(tag, index) in $store.getters.tagsViewList&quot;\n        :key&#x3D;&quot;tag.fullPath&quot;\n        :to&#x3D;&quot;&#123; path: tag.fullPath &#125;&quot;\n      &gt;\n        &#123;&#123; tag.title &#125;&#125;\n        &lt;i\n          v-show&#x3D;&quot;!isActive(tag)&quot;\n          class&#x3D;&quot;el-icon-close&quot;\n          @click.prevent.stop&#x3D;&quot;onCloseClick(index)&quot;\n        &#x2F;&gt;\n      &lt;&#x2F;router-link&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; useRoute &#125; from &#39;vue-router&#39;\nconst route &#x3D; useRoute()\n\n&#x2F;**\n * 是否被选中\n *&#x2F;\nconst isActive &#x3D; tag &#x3D;&gt; &#123;\n  return tag.path &#x3D;&#x3D;&#x3D; route.path\n&#125;\n\n&#x2F;**\n * 关闭 tag 的点击事件\n *&#x2F;\nconst onCloseClick &#x3D; index &#x3D;&gt; &#123;&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.tags-view-container &#123;\n  height: 34px;\n  width: 100%;\n  background: #fff;\n  border-bottom: 1px solid #d8dce5;\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.12), 0 0 3px 0 rgba(0, 0, 0, 0.04);\n    .tags-view-item &#123;\n      display: inline-block;\n      position: relative;\n      cursor: pointer;\n      height: 26px;\n      line-height: 26px;\n      border: 1px solid #d8dce5;\n      color: #495060;\n      background: #fff;\n      padding: 0 8px;\n      font-size: 12px;\n      margin-left: 5px;\n      margin-top: 4px;\n      &amp;:first-of-type &#123;\n        margin-left: 15px;\n      &#125;\n      &amp;:last-of-type &#123;\n        margin-right: 15px;\n      &#125;\n      &amp;.active &#123;\n        color: #fff;\n        &amp;::before &#123;\n          content: &#39;&#39;;\n          background: #fff;\n          display: inline-block;\n          width: 8px;\n          height: 8px;\n          border-radius: 50%;\n          position: relative;\n          margin-right: 4px;\n        &#125;\n      &#125;\n      &#x2F;&#x2F; close 按钮\n      .el-icon-close &#123;\n        width: 16px;\n        height: 16px;\n        line-height: 10px;\n        vertical-align: 2px;\n        border-radius: 50%;\n        text-align: center;\n        transition: all 0.3s cubic-bezier(0.645, 0.045, 0.355, 1);\n        transform-origin: 100% 50%;\n        &amp;:before &#123;\n          transform: scale(0.6);\n          display: inline-block;\n          vertical-align: -3px;\n        &#125;\n        &amp;:hover &#123;\n          background-color: #b4bccc;\n          color: #fff;\n        &#125;\n      &#125;\n    \n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n在 layout/index 中导入\n&lt;div class&#x3D;&quot;fixed-header&quot;&gt;\n    &lt;!-- 顶部的 navbar --&gt;\n    &lt;navbar &#x2F;&gt;\n    &lt;!-- tags --&gt;\n    &lt;tags-view&gt;&lt;&#x2F;tags-view&gt;\n&lt;&#x2F;div&gt;\n\nimport TagsView from &#39;@&#x2F;components&#x2F;TagsView&#39;\n\n\n5-33：方案落地：tagsView 国际化处理tagsView 的国际化处理可以理解为修改现有 tags 的 title。\n所以我们只需要：\n\n监听到语言变化\n国际化对应的 title 即可\n\n根据方案，可生成如下代码：\n\n在 store/app 中，创建修改 ttile 的 mutations\n&#x2F;**\n* 为指定的 tag 修改 title\n*&#x2F;\nchangeTagsView(state, &#123; index, tag &#125;) &#123;\n    state.tagsViewList[index] &#x3D; tag\n    setItem(TAGS_VIEW, state.tagsViewList)\n&#125;\n\n\n\n在 appmain 中监听语言变化\nimport &#123; generateTitle, watchSwitchLang &#125; from &#39;@&#x2F;utils&#x2F;i18n&#39;\n\n&#x2F;**\n * 国际化 tags\n *&#x2F;\nwatchSwitchLang(() &#x3D;&gt; &#123;\n  store.getters.tagsViewList.forEach((route, index) &#x3D;&gt; &#123;\n    store.commit(&#39;app&#x2F;changeTagsView&#39;, &#123;\n      index,\n      tag: &#123;\n        ...route,\n        title: getTitle(route)\n      &#125;\n    &#125;)\n  &#125;)\n&#125;)\n\n5-34：方案落地：contextMenu 展示处理\n\n\n\n\n\n\n\n\ncontextMenu 为 鼠标右键事件\ncontextMenu 事件的处理分为两部分：\n\ncontextMenu 的展示\n右键项对应逻辑处理\n\n那么这一小节我们先处理第一部分：contextMenu 的展示：\n\n创建 components/TagsView/ContextMenu 组件，作为右键展示部分\n&lt;template&gt;\n  &lt;ul class&#x3D;&quot;context-menu-container&quot;&gt;\n    &lt;li @click&#x3D;&quot;onRefreshClick&quot;&gt;\n      &#123;&#123; $t(&#39;msg.tagsView.refresh&#39;) &#125;&#125;\n    &lt;&#x2F;li&gt;\n    &lt;li @click&#x3D;&quot;onCloseRightClick&quot;&gt;\n      &#123;&#123; $t(&#39;msg.tagsView.closeRight&#39;) &#125;&#125;\n    &lt;&#x2F;li&gt;\n    &lt;li @click&#x3D;&quot;onCloseOtherClick&quot;&gt;\n      &#123;&#123; $t(&#39;msg.tagsView.closeOther&#39;) &#125;&#125;\n    &lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; defineProps &#125; from &#39;vue&#39;\ndefineProps(&#123;\n  index: &#123;\n    type: Number,\n    required: true\n  &#125;\n&#125;)\n\nconst onRefreshClick &#x3D; () &#x3D;&gt; &#123;&#125;\n\nconst onCloseRightClick &#x3D; () &#x3D;&gt; &#123;&#125;\n\nconst onCloseOtherClick &#x3D; () &#x3D;&gt; &#123;&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.context-menu-container &#123;\n  position: fixed;\n  background: #fff;\n  z-index: 3000;\n  list-style-type: none;\n  padding: 5px 0;\n  border-radius: 4px;\n  font-size: 12px;\n  font-weight: 400;\n  color: #333;\n  box-shadow: 2px 2px 3px 0 rgba(0, 0, 0, 0.3);\n  li &#123;\n    margin: 0;\n    padding: 7px 16px;\n    cursor: pointer;\n    &amp;:hover &#123;\n      background: #eee;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n在 tagsview  中控制 contextMenu 的展示\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;tags-view-container&quot;&gt;\n    &lt;el-scrollbar class&#x3D;&quot;tags-view-wrapper&quot;&gt;\n      &lt;router-link\n        ...\n        @contextmenu.prevent&#x3D;&quot;openMenu($event, index)&quot;\n      &gt;\n        ...\n    &lt;&#x2F;el-scrollbar&gt;\n    &lt;context-menu\n      v-show&#x3D;&quot;visible&quot;\n      :style&#x3D;&quot;menuStyle&quot;\n      :index&#x3D;&quot;selectIndex&quot;\n    &gt;&lt;&#x2F;context-menu&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport ContextMenu from &#39;.&#x2F;ContextMenu.vue&#39;\nimport &#123; ref, reactive, watch &#125; from &#39;vue&#39;\nimport &#123; useRoute &#125; from &#39;vue-router&#39;\n...\n\n&#x2F;&#x2F; contextMenu 相关\nconst selectIndex &#x3D; ref(0)\nconst visible &#x3D; ref(false)\nconst menuStyle &#x3D; reactive(&#123;\n  left: 0,\n  top: 0\n&#125;)\n&#x2F;**\n * 展示 menu\n *&#x2F;\nconst openMenu &#x3D; (e, index) &#x3D;&gt; &#123;\n  const &#123; x, y &#125; &#x3D; e\n  menuStyle.left &#x3D; x + &#39;px&#39;\n  menuStyle.top &#x3D; y + &#39;px&#39;\n  selectIndex.value &#x3D; index\n  visible.value &#x3D; true\n&#125;\n\n\n&lt;&#x2F;script&gt;\n\n5-35：方案落地：contextMenu 事件处理对于 contextMenu 的事件一共分为三个：\n\n刷新\n关闭右侧\n关闭所有\n\n但是不要忘记，我们之前 关闭单个 tags 的事件还没有进行处理，所以这一小节我们一共需要处理 4 个对应的事件\n\n刷新事件\nconst router &#x3D; useRouter()\nconst onRefreshClick &#x3D; () &#x3D;&gt; &#123;\n  router.go(0)\n&#125;\n\n在 store/app 中，创建删除 tags 的 mutations，该 mutations 需要同时具备以下三个能力：\n\n删除 “右侧”\n删除 “其他”\n删除 “当前”\n\n\n根据以上理论得出以下代码：\n&#x2F;**\n     * 删除 tag\n     * @param &#123;type: &#39;other&#39;||&#39;right&#39;||&#39;index&#39;, index: index&#125; payload\n     *&#x2F;\n    removeTagsView(state, payload) &#123;\n      if (payload.type &#x3D;&#x3D;&#x3D; &#39;index&#39;) &#123;\n        state.tagsViewList.splice(payload.index, 1)\n        return\n      &#125; else if (payload.type &#x3D;&#x3D;&#x3D; &#39;other&#39;) &#123;\n        state.tagsViewList.splice(\n          payload.index + 1,\n          state.tagsViewList.length - payload.index + 1\n        )\n        state.tagsViewList.splice(0, payload.index)\n      &#125; else if (payload.type &#x3D;&#x3D;&#x3D; &#39;right&#39;) &#123;\n        state.tagsViewList.splice(\n          payload.index + 1,\n          state.tagsViewList.length - payload.index + 1\n        )\n      &#125;\n      setItem(TAGS_VIEW, state.tagsViewList)\n    &#125;,\n\n关闭右侧事件\nconst store &#x3D; useStore()\nconst onCloseRightClick &#x3D; () &#x3D;&gt; &#123;\n  store.commit(&#39;app&#x2F;removeTagsView&#39;, &#123;\n    type: &#39;right&#39;,\n    index: props.index\n  &#125;)\n&#125;\n\n关闭其他\nconst onCloseOtherClick &#x3D; () &#x3D;&gt; &#123;\n  store.commit(&#39;app&#x2F;removeTagsView&#39;, &#123;\n    type: &#39;other&#39;,\n    index: props.index\n  &#125;)\n&#125;\n\n关闭当前（tagsview）\n&#x2F;**\n * 关闭 tag 的点击事件\n *&#x2F;\nconst store &#x3D; useStore()\nconst onCloseClick &#x3D; index &#x3D;&gt; &#123;\n  store.commit(&#39;app&#x2F;removeTagsView&#39;, &#123;\n    type: &#39;index&#39;,\n    index: index\n  &#125;)\n&#125;\n\n5-36：方案落地：处理 contextMenu 的关闭行为&#x2F;**\n * 关闭 menu\n *&#x2F;\nconst closeMenu &#x3D; () &#x3D;&gt; &#123;\n  visible.value &#x3D; false\n&#125;\n\n&#x2F;**\n * 监听变化\n *&#x2F;\nwatch(visible, val &#x3D;&gt; &#123;\n  if (val) &#123;\n    document.body.addEventListener(&#39;click&#39;, closeMenu)\n  &#125; else &#123;\n    document.body.removeEventListener(&#39;click&#39;, closeMenu)\n  &#125;\n&#125;)\n\n\n\n5-37：方案落地：处理基于路由的动态过渡处理基于路由的动态过渡  官方已经给出了示例代码，结合 router-view 和 transition 我们可以非常方便的实现这个功能\n\n在 appmain 中处理对应代码逻辑\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app-main&quot;&gt;\n    &lt;router-view v-slot&#x3D;&quot;&#123; Component, route &#125;&quot;&gt;\n      &lt;transition name&#x3D;&quot;fade-transform&quot; mode&#x3D;&quot;out-in&quot;&gt;\n        &lt;keep-alive&gt;\n          &lt;component :is&#x3D;&quot;Component&quot; :key&#x3D;&quot;route.path&quot; &#x2F;&gt;\n        &lt;&#x2F;keep-alive&gt;\n      &lt;&#x2F;transition&gt;\n    &lt;&#x2F;router-view&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n增加了 tags 之后，app-main 的位置需要进行以下处理\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.app-main &#123;\n  min-height: calc(100vh - 50px - 43px);\n  ...\n  padding: 104px 20px 20px 20px;\n  ...\n&#125;\n&lt;&#x2F;style&gt;\n\n在 styles/transition 中增加动画渲染\n&#x2F;* fade-transform *&#x2F;\n.fade-transform-leave-active,\n.fade-transform-enter-active &#123;\n  transition: all 0.5s;\n&#125;\n\n.fade-transform-enter-from &#123;\n  opacity: 0;\n  transform: translateX(-30px);\n&#125;\n\n.fade-transform-leave-to &#123;\n  opacity: 0;\n  transform: translateX(30px);\n&#125;\n\n5-38：tagsView 方案总结那么到这里关于 tagsView 的内容我们就已经处理完成了。\n整个 tagsView 就像我们之前说的，拆开来看之后，会显得明确很多。\n整个 tagsView 整体来看就是三块大的内容：\n\ntags：tagsView 组件\ncontextMenu：contextMenu 组件\nview：appmain 组件\n\n再加上一部分的数据处理即可。\n最后关于 tags 的国际化部分，其实处理的方案有非常多，大家也可以在后面的 讨论题 中探讨一下关于 此处国家化 的实现，相信会有很多新的思路被打开的。\n5-39：guide 原理及方案分析所谓 guide 指的就是 引导页\n引导页是软件中经常见到的一个功能，无论是在后台项目还是前台或者是移动端项目中。\n那么对于引导页而言，它是如何实现的呢？我们来分析一下。\n通常情况下引导页是通过 聚焦 的方式，高亮一块视图，然后通过文字解释的形式来告知用户该功能的作用。\n所以说对于引导页而言，它的实现其实就是：页面样式 的实现。\n我们只需要可以做到：\n\n高亮某一块指定的样式\n在高亮的样式处通过文本展示内容\n用户可以进行下一次高亮或者关闭事件\n\n那么就可以实现对应的引导功能。\n方案：\n对于引导页来说，市面上有很多现成的轮子，所以我们不需要手动的去进行以上内容的处理，我们这里可以直接使用 driver.js 进行引导页处理。\n基于 driver.js 我们的实现方案如下：\n\n创建 Guide 组件：用于处理 icon 展示\n初始化 driver.js \n指定 driver.js 的 steps\n\n5-40：方案落地：生成 Guide\n创建components/Guide\n\n   &lt;template&gt;\n  &lt;div&gt;\n    &lt;el-tooltip :content&#x3D;&quot;$t(&#39;msg.navBar.guide&#39;)&quot;&gt;\n      &lt;svg-icon icon&#x3D;&quot;guide&quot; &#x2F;&gt;\n    &lt;&#x2F;el-tooltip&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n\n\n在 navbar 中导入该组件\n&lt;guide class&#x3D;&quot;right-menu-item hover-effect&quot; &#x2F;&gt;\n\nimport Guide from &#39;@&#x2F;components&#x2F;Guide&#39;\n\n5-41：方案落地：Guide 业务逻辑处理\n导入 driver.js \nnpm i driver.js@0.9.8\n\n在 guide.vue 中初始化 driiver\n&lt;script setup&gt;\nimport Driver from &#39;driver.js&#39;\nimport &#39;driver.js&#x2F;dist&#x2F;driver.min.css&#39;\nimport &#123; onMounted &#125; from &#39;vue&#39;\nimport &#123; useI18n &#125; from &#39;vue-i18n&#39;\n\nconst i18n &#x3D; useI18n()\n\nlet driver &#x3D; null\nonMounted(() &#x3D;&gt; &#123;\n  driver &#x3D; new Driver(&#123;\n    &#x2F;&#x2F; 禁止点击蒙版关闭\n    allowClose: false,\n    closeBtnText: i18n.t(&#39;msg.guide.close&#39;),\n    nextBtnText: i18n.t(&#39;msg.guide.next&#39;),\n    prevBtnText: i18n.t(&#39;msg.guide.prev&#39;)\n  &#125;)\n&#125;)\n&lt;&#x2F;script&gt;\n\n创建 步骤 steps.js\n&#x2F;&#x2F; 此处不要导入 @&#x2F;i18n 使用 i18n.global ，因为我们在 router 中 layout 不是按需加载，所以会在 Guide 会在 I18n 初始化完成之前被直接调用。导致 i18n 为 undefined\nconst steps &#x3D; i18n &#x3D;&gt; &#123;\n  return [\n    &#123;\n      element: &#39;#guide-start&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.guideTitle&#39;),\n        description: i18n.t(&#39;msg.guide.guideDesc&#39;),\n        position: &#39;bottom-right&#39;\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-hamburger&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.hamburgerTitle&#39;),\n        description: i18n.t(&#39;msg.guide.hamburgerDesc&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-breadcrumb&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.breadcrumbTitle&#39;),\n        description: i18n.t(&#39;msg.guide.breadcrumbDesc&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-search&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.searchTitle&#39;),\n        description: i18n.t(&#39;msg.guide.searchDesc&#39;),\n        position: &#39;bottom-right&#39;\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-full&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.fullTitle&#39;),\n        description: i18n.t(&#39;msg.guide.fullDesc&#39;),\n        position: &#39;bottom-right&#39;\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-theme&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.themeTitle&#39;),\n        description: i18n.t(&#39;msg.guide.themeDesc&#39;),\n        position: &#39;bottom-right&#39;\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-lang&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.langTitle&#39;),\n        description: i18n.t(&#39;msg.guide.langDesc&#39;),\n        position: &#39;bottom-right&#39;\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-tags&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.tagTitle&#39;),\n        description: i18n.t(&#39;msg.guide.tagDesc&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-sidebar&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.sidebarTitle&#39;),\n        description: i18n.t(&#39;msg.guide.sidebarDesc&#39;),\n        position: &#39;right-center&#39;\n      &#125;\n    &#125;\n  ]\n&#125;\nexport default steps\n\n在 guide 中导入“步骤”\n&lt;template&gt;\n  ...\n  &lt;svg-icon icon&#x3D;&quot;guide&quot; @click&#x3D;&quot;onClick&quot; &#x2F;&gt;\n  ...\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\n...\nimport steps from &#39;.&#x2F;steps&#39;\n...\nconst onClick &#x3D; () &#x3D;&gt; &#123;\n  driver.defineSteps(steps(i18n))\n  driver.start()\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n\n为 引导高亮区域增加 ID\n\n在 components/Guide/index 中增加\n&lt;svg-icon id&#x3D;&quot;guide-start&quot; icon&#x3D;&quot;guide&quot; @click&#x3D;&quot;onClick&quot; &#x2F;&gt;\n\n在 components/Hamburger/index 增加\n&lt;svg-icon id&#x3D;&quot;guide-hamburger&quot; class&#x3D;&quot;hamburger&quot; :icon&#x3D;&quot;icon&quot;&gt;&lt;&#x2F;svg-icon&gt;\n\n在 src/layout/components 增加\n&lt;breadcrumb id&#x3D;&quot;guide-breadcrumb&quot; class&#x3D;&quot;breadcrumb-container&quot; &#x2F;&gt;\n\n在 components/HeaderSearch/index 增加\n&lt;svg-icon\n     id&#x3D;&quot;guide-search&quot;\n     class-name&#x3D;&quot;search-icon&quot;\n     icon&#x3D;&quot;search&quot;\n     @click.stop&#x3D;&quot;onShowClick&quot;\n   &#x2F;&gt;\n\n在 components/Screenfull/index 增加\n&lt;svg-icon\n      id&#x3D;&quot;guide-full&quot;\n      :icon&#x3D;&quot;isFullscreen ? &#39;exit-fullscreen&#39; : &#39;fullscreen&#39;&quot;\n      @click&#x3D;&quot;onToggle&quot;\n    &#x2F;&gt;\n\n在 components/ThemePicker/index 增加\n&lt;svg-icon id&#x3D;&quot;guide-theme&quot; icon&#x3D;&quot;change-theme&quot; &#x2F;&gt;\n\n在 components/LangSelect/index 增加\n&lt;svg-icon id&#x3D;&quot;guide-lang&quot; icon&#x3D;&quot;language&quot; &#x2F;&gt;\n\n在 layout/index 增加\n&lt;tags-view id&#x3D;&quot;guide-tags&quot;&gt;&lt;&#x2F;tags-view&gt;\n\n在 layout/index 增加\n&lt;sidebar\n      id&#x3D;&quot;guide-sidebar&quot;\n      class&#x3D;&quot;sidebar-container&quot;\n      :style&#x3D;&quot;&#123; backgroundColor: $store.getters.cssVar.menuBg &#125;&quot;\n    &#x2F;&gt;\n\n5-42：总结那么到这里我们整个的 后台项目前端综合解决方案之通用功能开发 这一章节就算是处理完成了。\n在本章中我们对以下通用功能进行了处理：\n\n国际化\n动态换肤\nscreenfull\nheaderSearch\ntagView\nguide\n\n其中除了 screenfull 和 guide 之外其他的功能都是具备一定的复杂度的。\n但是只要我们可以根据功能分析出对应原理，就可以根据原理实现对应方案，有了方案就可以制定出对应的实现步骤。\n只要大的步骤没有错误，那么具体的细节功能实现只需要具体情况具体分析即可。\n不过大家要注意，对于这些实现方案而言，并非 只有我们项目中的这一种实现方式。大家也可以针对这些实现方案在咱们的 群里 或者 讨论区 中，和我们一起多多发言或者讨论。\n","slug":"vue3.2后台管理系统/05通用功能开发","date":"2022-08-22T15:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"ded06061bffb24de88f886e4a5616cce","title":"04搭建Layout架构","content":"第四章：搭建Layout架构4-01：前言在上一章中我们处理完成登录之后，从这一章开始，我们就需要处理项目的 Layout 架构了。那么什么叫做 Layout 架构呢？\n我们来看这张图：\n\n\n在这张图中，我们把页面分为了三个部分，分别是：\n\n左侧的 Menu 菜单\n顶部的 NavBar\n中间的内容区 Main\n\n可能有人看到这里就说了，你这不就是个基本的页面布局吗？ 还弄个这么洋气的名字干嘛？\n外行看热闹，内行看门道对不对。\n本章中我们将会实现以下的核心解决方案：\n\n用户退出方案\n动态侧边栏方案\n动态面包屑方案\n\n除了这些核心内容之外，还有一些其他的小功能，比如：\n\n退出的通用逻辑封装\n伸缩侧边栏动画\nvue3 动画\n组件状态驱动的动态 CSS 值等等\n\n等等\n换句话而言，掌握了本章中的内容之后，后台项目的通用 Layout 处理，对于来说将变得小菜一碟！\n4-02：创建基于 Layout 的基础架构在本小节我们需要创建基于 Layout 的基本架构布局，所以说会涉及到大量的 CSS 内容，这些 CSS 大部分都是比较基础的可复用的 CSS 样式，又因为量比较大，所以说我们不会在视频中把这些所有的 CSS 全部手敲一遍，而是从中间挑出一些比较重要的 Css 内容去进行手写和介绍。这是本小节中一个比较特殊的地方，先和大家进行一下明确。\n那么明确好了之后，我们再来看一下我们 Layout 的基本布局结构：\n\n\n我们知道，当登录完成之后，那么我们会进入到 Layout 页面，这个 Layout 页面组件位于 Layout/index.vue 中，所以说想要实现这样的结构，那么我们就需要到对应的 layout 组件中进行。\n\n整个页面分为三部分，所以我们需要先去创建对应的三个组件：\n\nlayout/components/Sidebar/index.vue\nlayout/components/Navbar.vue\nlayout/components/AppMain.vue\n\n\n然后在 layout/index.vue 中引入这三个组件\n&lt;script setup&gt;\n    import Navbar from &#39;.&#x2F;components&#x2F;Navbar&#39;\n    import Sidebar from &#39;.&#x2F;components&#x2F;Sidebar&#39;\n    import AppMain from &#39;.&#x2F;components&#x2F;AppMain&#39;\n&lt;&#x2F;script&gt;\n\n完成对应的布局结构\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app-wrapper&quot;&gt;\n    &lt;!-- 左侧 menu --&gt;\n    &lt;sidebar\n      id&#x3D;&quot;guide-sidebar&quot;\n      class&#x3D;&quot;sidebar-container&quot;\n    &#x2F;&gt;\n    &lt;div class&#x3D;&quot;main-container&quot;&gt;\n      &lt;div class&#x3D;&quot;fixed-header&quot;&gt;\n        &lt;!-- 顶部的 navbar --&gt;\n        &lt;navbar &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n      &lt;!-- 内容区 --&gt;\n      &lt;app-main &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n在 styles 中创建如下 css 文件：\n\nvariables.scss ： 定义常量\nmixin.scss ：定义通用的 css\nsidebar.scss：处理 menu 菜单的样式\n\n\n为 variables.scss ，定义如下常量并进行导出（ :export 可见 scss 与 js 共享变量）：\n&#x2F;&#x2F; sidebar\n$menuText: #bfcbd9;\n$menuActiveText: #ffffff;\n$subMenuActiveText: #f4f4f5;\n\n$menuBg: #304156;\n$menuHover: #263445;\n\n$subMenuBg: #1f2d3d;\n$subMenuHover: #001528;\n\n$sideBarWidth: 210px;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.bluematador.com&#x2F;blog&#x2F;how-to-share-variables-between-js-and-sass\n&#x2F;&#x2F; JS 与 scss 共享变量，在 scss 中通过 :export 进行导出，在 js 中可通过 ESM 进行导入\n:export &#123;\n  menuText: $menuText;\n  menuActiveText: $menuActiveText;\n  subMenuActiveText: $subMenuActiveText;\n  menuBg: $menuBg;\n  menuHover: $menuHover;\n  subMenuBg: $subMenuBg;\n  subMenuHover: $subMenuHover;\n  sideBarWidth: $sideBarWidth;\n&#125;\n\n\n为 mixin.scss 定义如下样式：\n@mixin clearfix &#123;\n  &amp;:after &#123;\n    content: &#39;&#39;;\n    display: table;\n    clear: both;\n  &#125;\n&#125;\n\n@mixin scrollBar &#123;\n  &amp;::-webkit-scrollbar-track-piece &#123;\n    background: #d3dce6;\n  &#125;\n\n  &amp;::-webkit-scrollbar &#123;\n    width: 6px;\n  &#125;\n\n  &amp;::-webkit-scrollbar-thumb &#123;\n    background: #99a9bf;\n    border-radius: 20px;\n  &#125;\n&#125;\n\n@mixin relative &#123;\n  position: relative;\n  width: 100%;\n  height: 100%;\n&#125;\n\n\n为 sidebar.scss 定义如下样式：\n#app &#123;\n  .main-container &#123;\n    min-height: 100%;\n    transition: margin-left 0.28s;\n    margin-left: $sideBarWidth;\n    position: relative;\n  &#125;\n\n  .sidebar-container &#123;\n    transition: width 0.28s;\n    width: $sideBarWidth !important;\n    height: 100%;\n    position: fixed;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 1001;\n    overflow: hidden;\n\n    &#x2F;&#x2F; 重置 element-plus 的css\n    .horizontal-collapse-transition &#123;\n      transition: 0s width ease-in-out, 0s padding-left ease-in-out,\n        0s padding-right ease-in-out;\n    &#125;\n\n    .scrollbar-wrapper &#123;\n      overflow-x: hidden !important;\n    &#125;\n\n    .el-scrollbar__bar.is-vertical &#123;\n      right: 0px;\n    &#125;\n\n    .el-scrollbar &#123;\n      height: 100%;\n    &#125;\n\n    &amp;.has-logo &#123;\n      .el-scrollbar &#123;\n        height: calc(100% - 50px);\n      &#125;\n    &#125;\n\n    .is-horizontal &#123;\n      display: none;\n    &#125;\n\n    a &#123;\n      display: inline-block;\n      width: 100%;\n      overflow: hidden;\n    &#125;\n\n    .svg-icon &#123;\n      margin-right: 16px;\n    &#125;\n\n    .sub-el-icon &#123;\n      margin-right: 12px;\n      margin-left: -2px;\n    &#125;\n\n    .el-menu &#123;\n      border: none;\n      height: 100%;\n      width: 100% !important;\n    &#125;\n\n    .is-active &gt; .el-submenu__title &#123;\n      color: $subMenuActiveText !important;\n    &#125;\n\n    &amp; .nest-menu .el-submenu &gt; .el-submenu__title,\n    &amp; .el-submenu .el-menu-item &#123;\n      min-width: $sideBarWidth !important;\n    &#125;\n  &#125;\n\n  .hideSidebar &#123;\n    .sidebar-container &#123;\n      width: 54px !important;\n    &#125;\n\n    .main-container &#123;\n      margin-left: 54px;\n    &#125;\n\n    .submenu-title-noDropdown &#123;\n      padding: 0 !important;\n      position: relative;\n\n      .el-tooltip &#123;\n        padding: 0 !important;\n\n        .svg-icon &#123;\n          margin-left: 20px;\n        &#125;\n\n        .sub-el-icon &#123;\n          margin-left: 19px;\n        &#125;\n      &#125;\n    &#125;\n\n    .el-submenu &#123;\n      overflow: hidden;\n\n      &amp; &gt; .el-submenu__title &#123;\n        padding: 0 !important;\n\n        .svg-icon &#123;\n          margin-left: 20px;\n        &#125;\n\n        .sub-el-icon &#123;\n          margin-left: 19px;\n        &#125;\n\n        .el-submenu__icon-arrow &#123;\n          display: none;\n        &#125;\n      &#125;\n    &#125;\n\n    .el-menu--collapse &#123;\n      .el-submenu &#123;\n        &amp; &gt; .el-submenu__title &#123;\n          &amp; &gt; span &#123;\n            height: 0;\n            width: 0;\n            overflow: hidden;\n            visibility: hidden;\n            display: inline-block;\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n\n  .el-menu--collapse .el-menu .el-submenu &#123;\n    min-width: $sideBarWidth !important;\n  &#125;\n\n  .withoutAnimation &#123;\n    .main-container,\n    .sidebar-container &#123;\n      transition: none;\n    &#125;\n  &#125;\n&#125;\n\n.el-menu--vertical &#123;\n  &amp; &gt; .el-menu &#123;\n    .svg-icon &#123;\n      margin-right: 16px;\n    &#125;\n    .sub-el-icon &#123;\n      margin-right: 12px;\n      margin-left: -2px;\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 菜单项过长时\n  &gt; .el-menu--popup &#123;\n    max-height: 100vh;\n    overflow-y: auto;\n\n    &amp;::-webkit-scrollbar-track-piece &#123;\n      background: #d3dce6;\n    &#125;\n\n    &amp;::-webkit-scrollbar &#123;\n      width: 6px;\n    &#125;\n\n    &amp;::-webkit-scrollbar-thumb &#123;\n      background: #99a9bf;\n      border-radius: 20px;\n    &#125;\n  &#125;\n&#125;\n\n\n在 index.scss 中按照顺序导入以上样式文件\n@import &#39;.&#x2F;variables.scss&#39;;\n@import &#39;.&#x2F;mixin.scss&#39;;\n@import &#39;.&#x2F;sidebar.scss&#39;;\n\n在 layout/index.vue 中写入如下样式\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n@import &#39;~@&#x2F;styles&#x2F;mixin.scss&#39;;\n@import &#39;~@&#x2F;styles&#x2F;variables.scss&#39;;\n\n.app-wrapper &#123;\n  @include clearfix;\n  position: relative;\n  height: 100%;\n  width: 100%;\n&#125;\n\n.fixed-header &#123;\n  position: fixed;\n  top: 0;\n  right: 0;\n  z-index: 9;\n  width: calc(100% - #&#123;$sideBarWidth&#125;);\n&#125;\n&lt;&#x2F;style&gt;\n\n因为将来要实现 主题更换，所以为 sidebar 赋值动态的背景颜色\n&lt;template&gt;\n...\n    &lt;!-- 左侧 menu --&gt;\n    &lt;sidebar\n      class&#x3D;&quot;sidebar-container&quot;\n      :style&#x3D;&quot;&#123; backgroundColor: variables.menuBg &#125;&quot;\n    &#x2F;&gt;\n...\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport variables from &#39;@&#x2F;styles&#x2F;variables.scss&#39;\n&lt;&#x2F;script&gt;\n\n为 Navbar、Sidebar、AppMain 组件进行初始化代码\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;&#123;组件名&#125;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;\n\n\n至此查看效果为\n\n\n可见 Navbar 与 AppMain 重叠\n\n为 AppMain 进行样式处理\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app-main&quot;&gt;AppMain&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.app-main &#123;\n  min-height: calc(100vh - 50px);\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  padding: 61px 20px 20px 20px;\n  box-sizing: border-box;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n查看效果\n\n\n在本章节中，我们写入了大量的代码，其中以 css 代码为主，因为其中的大量 css 都是可服用的，比如 sidebar.scss ，所以我们这里并没有进行手写。那么对于大家来说，这里的 css 代码也没有手写的必要，毕竟这些重复的体力活，是没有必要所有的事情都亲历亲为的。\n那么下一章节中，我们就去实现一下 navbar 中的功能操作。\n4-03：获取用户基本信息处理完了基本的 Layout 架构之后，接下来我们实现一下 navbar 中的 头像菜单 功能\n这样的一个功能主要分为三个部分：\n\n获取并展示用户信息\nelement-plus 中的 dropdown 组件使用\n退出登录的方案实现\n\n那么接下来我们就去实现第一部分的功能 获取并展示用户信息\n获取并展示用户信息 我们把它分为三部分进行实现：\n\n定义接口请求方法\n定义调用接口的动作\n在权限拦截时触发动作\n\n那么接下来我们就根据这三个步骤，分别来进行实现：\n定义接口请求方法：\n在 api/sys.js 中定义如下方法：\n&#x2F;**\n * 获取用户信息\n *&#x2F;\nexport const getUserInfo &#x3D; () &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;sys&#x2F;profile&#39;\n  &#125;)\n&#125;\n\n因为获取用户信息需要对应的 token ，所以我们可以利用 axios 的 请求拦截器 对 token 进行统一注入，在 utils/request.js 中写入如下代码：\nimport store from &#39;@&#x2F;store&#39;\n&#x2F;&#x2F; 请求拦截器\nservice.interceptors.request.use(\n  config &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 在这个位置需要统一的去注入token\n    if (store.getters.token) &#123;\n      &#x2F;&#x2F; 如果token存在 注入token\n      config.headers.Authorization &#x3D; &#96;Bearer $&#123;store.getters.token&#125;&#96;\n    &#125;\n    return config &#x2F;&#x2F; 必须返回配置\n  &#125;,\n  error &#x3D;&gt; &#123;\n    return Promise.reject(error)\n  &#125;\n)\n\n定义调用接口的动作：\n在 store/modules/user 中写入以下代码：\nimport &#123; login, getUserInfo &#125; from &#39;@&#x2F;api&#x2F;sys&#39;\n...\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;\n    ...\n    userInfo: &#123;&#125;\n  &#125;),\n  mutations: &#123;\n    ...\n    setUserInfo(state, userInfo) &#123;\n      state.userInfo &#x3D; userInfo\n    &#125;\n  &#125;,\n  actions: &#123;\n    ...\n    async getUserInfo(context) &#123;\n      const res &#x3D; await getUserInfo()\n      this.commit(&#39;user&#x2F;setUserInfo&#39;, res)\n      return res\n    &#125;\n  &#125;\n&#125;\n\n\n在权限拦截时触发动作：\n在 permission.js 中写入以下代码：\n  if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n    ...\n  &#125; else &#123;\n    &#x2F;&#x2F; 判断用户资料是否获取\n    &#x2F;&#x2F; 若不存在用户信息，则需要获取用户信息\n    if (!store.getters.hasUserInfo) &#123;\n      &#x2F;&#x2F; 触发获取用户信息的 action\n      await store.dispatch(&#39;user&#x2F;getUserInfo&#39;)\n    &#125;\n    next()\n  &#125;\n&#125;\n\n\n在 store/getters.js 中写入判断用户信息代码：\nconst getters &#x3D; &#123;\n  ...\n  userInfo: state &#x3D;&gt; state.user.userInfo,\n  &#x2F;**\n   * @returns true 表示已存在用户信息\n   *&#x2F;\n  hasUserInfo: state &#x3D;&gt; &#123;\n    return JSON.stringify(state.user.userInfo) !&#x3D;&#x3D; &#39;&#123;&#125;&#39;\n  &#125;\n&#125;\n...\n\n\n注意：出现 401 错误表示登录超时：\n\n\n如遇到此错误，可 手动到控制到 Application 中，删除 LocalStorage 中的 token\n\n\n删除后，重新刷新页面，重新进行登录操作（该问题如何解决，会在后续进行讲解）\n至此，即可获取用户信息数据\n\n\n4-04：渲染用户头像菜单到现在我们已经拿到了 用户数据，并且在 getters 中做了对应的快捷访问 ，那么接下来我们就可以根据数据渲染出 用户头像内容\n渲染用户头像，我们将使用到 element-plus 的两个组件：\n\navatar\nDropdown\n\n在 layout/components/navbar.js 中实现以下代码：\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;navbar&quot;&gt;\n    &lt;div class&#x3D;&quot;right-menu&quot;&gt;\n      &lt;!-- 头像 --&gt;\n      &lt;el-dropdown class&#x3D;&quot;avatar-container&quot; trigger&#x3D;&quot;click&quot;&gt;\n        &lt;div class&#x3D;&quot;avatar-wrapper&quot;&gt;\n          &lt;el-avatar\n            shape&#x3D;&quot;square&quot;\n            :size&#x3D;&quot;40&quot;\n            :src&#x3D;&quot;$store.getters.userInfo.avatar&quot;\n          &gt;&lt;&#x2F;el-avatar&gt;\n          &lt;i class&#x3D;&quot;el-icon-s-tools&quot;&gt;&lt;&#x2F;i&gt;\n        &lt;&#x2F;div&gt;\n        &lt;template #dropdown&gt;\n          &lt;el-dropdown-menu class&#x3D;&quot;user-dropdown&quot;&gt;\n            &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;\n              &lt;el-dropdown-item&gt; 首页 &lt;&#x2F;el-dropdown-item&gt;\n            &lt;&#x2F;router-link&gt;\n            &lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;&quot;&gt;\n              &lt;el-dropdown-item&gt;项目主页&lt;&#x2F;el-dropdown-item&gt;\n            &lt;&#x2F;a&gt;\n            &lt;el-dropdown-item divided&gt;\n              退出登录\n            &lt;&#x2F;el-dropdown-item&gt;\n          &lt;&#x2F;el-dropdown-menu&gt;\n        &lt;&#x2F;template&gt;\n      &lt;&#x2F;el-dropdown&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.navbar &#123;\n  height: 50px;\n  overflow: hidden;\n  position: relative;\n  background: #fff;\n  box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);\n\n  .right-menu &#123;\n    display: flex;\n    align-items: center;\n    float: right;\n    padding-right: 16px;\n\n    ::v-deep .avatar-container &#123;\n      cursor: pointer;\n      .avatar-wrapper &#123;\n        margin-top: 5px;\n        position: relative;\n        .el-avatar &#123;\n          --el-avatar-background-color: none;\n          margin-right: 12px;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n那么至此，用户头像和对应的下拉菜单就已经实现完成了，那么下一小节我们就可以在此基础上实现对应的 退出登录 功能\n4-05：退出登录方案实现退出登录 一直是一个通用的前端实现方案，对于退出登录而言，它的触发时机一般有两种：\n\n用户主动退出\n用户被动退出\n\n其中：\n\n主动退出指：用户点击登录按钮之后退出\n被动退出指：token 过期或被  其他人”顶下来“ 时退出\n\n那么无论是什么退出方式，在用户退出时，所需要执行的操作都是固定的：\n\n清理掉当前用户缓存数据\n清理掉权限相关配置\n返回到登录页\n\n那么明确好了对应的方案之后，接下来咱们就先来实现 用户主动退出的对应策略\n在 store/modules/user.js 中，添加对应 action\nimport router from &#39;@&#x2F;router&#39;\n\nlogout() &#123;\n    this.commit(&#39;user&#x2F;setToken&#39;, &#39;&#39;)\n    this.commit(&#39;user&#x2F;setUserInfo&#39;, &#123;&#125;)\n    removeAllItem()\n    router.push(&#39;&#x2F;login&#39;)\n&#125;\n\n为退出登录按钮添加点击事件，触发 logout 的 action\nimport &#123; useStore &#125; from &#39;vuex&#39;\n\nconst store &#x3D; useStore()\nconst logout &#x3D; () &#x3D;&gt; &#123;\n  store.dispatch(&#39;user&#x2F;logout&#39;)\n&#125;\n\n那么至此，我们就完成了 用户主动退出 对应的实现。\n4-06：用户被动退出方案解析在上一节我们实现了 用户主动退出 场景，同时也提到 用户被动退出 的场景主要有两个：\n\ntoken 失效\n单用户登录：其他人登录该账号被 “顶下来”\n\n那么这两种场景下，在前端对应的处理方案一共也分为两种，共分为 主动处理 、被动处理 两种 ：\n\n主动处理：主要应对 token 失效\n被动处理：同时应对 token 失效 与 单用户登录\n\n那么这两种方案基本上就覆盖了用户被动推出时的主要业务场景了\n那么这一小节内容比较少，但是东西还是挺重要的。因为我们主要分析了 用户被动退出 的场景，那么从下一小节开始，我们分别来实现这两种处理方案。\n4-07：用户被动退出解决方案之主动处理想要搞明白 主动处理 方案，那么首先我们得先去搞明白对应的 背景 以及 业务逻辑 。\n那么首先我们先明确一下对应的 背景：\n\n\n\n\n\n\n\n\n\n我们知道 token 表示了一个用户的身份令牌，对 服务端 而言，它是只认令牌不认人的。所以说一旦其他人获取到了你的 token ，那么就可以伪装成你，来获取对应的敏感数据。\n所以为了保证用户的信息安全，那么对于 token 而言就被制定了很多的安全策略，比如：\n\n动态 token（可变 token）\n刷新 token\n时效 token\n…\n\n这些方案各有利弊，没有绝对的完美的策略。\n而我们此时所选择的方案就是 时效 token\n对于 token 本身是拥有时效的，这个大家都知道。但是通常情况下，这个时效都是在服务端进行处理。而此时我们要在 服务端处理 token 时效的同时，在前端主动介入 token 时效的处理中。 从而保证用户信息的更加安全性。\n那么对应到我们代码中的实现方案为：\n\n在用户登陆时，记录当前 登录时间\n制定一个 失效时长\n在接口调用时，根据 当前时间 对比 登录时间 ，看是否超过了 时效时长\n如果未超过，则正常进行后续操作\n如果超过，则进行 退出登录 操作\n\n\n\n那么明确好了对应的方案之后，接下来我们就去实现对应代码\n创建 utils/auth.js 文件，并写入以下代码：\nimport &#123; TIME_STAMP, TOKEN_TIMEOUT_VALUE &#125; from &#39;@&#x2F;constant&#39;\nimport &#123; setItem, getItem &#125; from &#39;@&#x2F;utils&#x2F;storage&#39;\n&#x2F;**\n * 获取时间戳\n *&#x2F;\nexport function getTimeStamp() &#123;\n  return getItem(TIME_STAMP)\n&#125;\n&#x2F;**\n * 设置时间戳\n *&#x2F;\nexport function setTimeStamp() &#123;\n  setItem(TIME_STAMP, Date.now())\n&#125;\n&#x2F;**\n * 是否超时\n *&#x2F;\nexport function isCheckTimeout() &#123;\n  &#x2F;&#x2F; 当前时间戳\n  var currentTime &#x3D; Date.now()\n  &#x2F;&#x2F; 缓存时间戳\n  var timeStamp &#x3D; getTimeStamp()\n  return currentTime - timeStamp &gt; TOKEN_TIMEOUT_VALUE\n&#125;\n\n在 constant 中声明对应常量：\n&#x2F;&#x2F; token 时间戳\nexport const TIME_STAMP &#x3D; &#39;timeStamp&#39;\n&#x2F;&#x2F; 超时时长(毫秒) 两小时\nexport const TOKEN_TIMEOUT_VALUE &#x3D; 2 * 3600 * 1000\n\n在用户登录成功之后去设置时间，到 store/user.js 的 login 中：\nimport &#123; setTimeStamp &#125; from &#39;@&#x2F;utils&#x2F;auth&#39;\n\nlogin(context, userInfo) &#123;\n      ...\n      return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        ...\n          .then(data &#x3D;&gt; &#123;\n            ...\n            &#x2F;&#x2F; 保存登录时间\n            setTimeStamp()\n            resolve()\n          &#125;)\n      &#125;)\n    &#125;,\n\n 在 utils/request 对应的请求拦截器中进行 主动介入\nimport &#123; isCheckTimeout &#125; from &#39;@&#x2F;utils&#x2F;auth&#39;\n\nif (store.getters.token) &#123;\n      if (isCheckTimeout()) &#123;\n        &#x2F;&#x2F; 登出操作\n        store.dispatch(&#39;user&#x2F;logout&#39;)\n        return Promise.reject(new Error(&#39;token 失效&#39;))\n      &#125;\n      ...\n    &#125;\n\n那么至此我们就完成了 主动处理 对应的业务逻辑\n4-08：用户被动退出解决方案之被动处理上一节我们处理了 用户被动退出时的主动处理 ，那么在这一小节我们去处理 用户被动退出时的被动处理 。\n还是和上一小节一样，我们还是先明确背景，然后再来明确业务逻辑。\n背景：\n首先我们需要先明确 被动处理 需要应对两种业务场景：\n\ntoken 过期\n单用户登录\n\n然后我们一个一个来去看，首先是 token 过期\n\n\n\n\n\n\n\n\n\n我们知道对于 token 而言，本身就是具备时效的，这个是在服务端生成 token 时就已经确定的。\n而此时我们所谓的 token 过期指的就是：\n服务端生成的 token 超过 服务端指定时效 的过程\n而对于 单用户登录 而言，指的是： \n\n\n\n\n\n\n\n\n\n当用户 A 登录之后，token 过期之前。\n 用户 A 的账号在其他的设备中进行了二次登录，导致第一次登录的 A 账号被 “顶下来” 的过程。\n即：同一账户仅可以在一个设备中保持在线状态\n那么明确好了对应的背景之后，接下来我们来看对应的业务处理场景：\n从背景中我们知道，以上的两种情况，都是在 服务端进行判断的，而对于前端而言其实是 服务端通知前端的一个过程。\n所以说对于其业务处理，将遵循以下逻辑：\n\n服务端返回数据时，会通过特定的状态码通知前端\n当前端接收到特定状态码时，表示遇到了特定状态：**token 时效** 或 单用户登录\n此时进行 退出登录 处理\n\n但是这里大家需要注意，因为咱们项目的特性，同一个账号需要在多个设备中使用，所以说此时将不会指定 单用户登录 的状态码，仅有 token 失效 状态码。之后当大家需要到 单用户登录 时，只需要增加一个状态码判断即可。\n那么明确好了业务之后，接下来我们来实现对应代码：\n在 utils/request 的响应拦截器中，增加以下逻辑：\n&#x2F;&#x2F; 响应拦截器\nservice.interceptors.response.use(\n  response &#x3D;&gt; &#123;\n    ...\n  &#125;,\n  error &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理 token 超时问题\n    if (\n      error.response &amp;&amp;\n      error.response.data &amp;&amp;\n      error.response.data.code &#x3D;&#x3D;&#x3D; 401\n    ) &#123;\n      &#x2F;&#x2F; token超时\n      store.dispatch(&#39;user&#x2F;logout&#39;)\n    &#125;\n    ElMessage.error(error.message) &#x2F;&#x2F; 提示错误信息\n    return Promise.reject(error)\n  &#125;\n)\n\n那么至此，我们就已经完成了 整个用户退出 方案。\n4-09：创建页面组件，使用临时 menu 菜单处理完了 退出登录 之后，接下来我们来处理 动态menu菜单。\n只不过为了方便大家理解，这里我们先不去直接处理动态菜单，我们先生成一个临时的 menu 菜单。\n创建 layout/Sidebar/SidebarMenu 文件\n&lt;template&gt;\n  &lt;!-- 一级 menu 菜单 --&gt;\n  &lt;el-menu\n    :uniqueOpened&#x3D;&quot;true&quot;\n    default-active&#x3D;&quot;2&quot;\n    background-color&#x3D;&quot;#545c64&quot;\n    text-color&#x3D;&quot;#fff&quot;\n    active-text-color&#x3D;&quot;#ffd04b&quot;\n  &gt;\n    &lt;!-- 子集 menu 菜单 --&gt;\n    &lt;el-submenu index&#x3D;&quot;1&quot;&gt;\n      &lt;template #title&gt;\n        &lt;i class&#x3D;&quot;el-icon-location&quot;&gt;&lt;&#x2F;i&gt;\n        &lt;span&gt;导航一&lt;&#x2F;span&gt;\n      &lt;&#x2F;template&gt;\n      &lt;el-menu-item index&#x3D;&quot;1-1&quot;&gt;选项1&lt;&#x2F;el-menu-item&gt;\n      &lt;el-menu-item index&#x3D;&quot;1-2&quot;&gt;选项2&lt;&#x2F;el-menu-item&gt;\n    &lt;&#x2F;el-submenu&gt;\n    &lt;!-- 具体菜单项 --&gt;\n    &lt;el-menu-item index&#x3D;&quot;4&quot;&gt;\n      &lt;i class&#x3D;&quot;el-icon-setting&quot;&gt;&lt;&#x2F;i&gt;\n      &lt;template #title&gt;导航四&lt;&#x2F;template&gt;\n    &lt;&#x2F;el-menu-item&gt;\n  &lt;&#x2F;el-menu&gt;\n&lt;&#x2F;template&gt;\n\n在 layout/Sidebar/index 中导入该组件\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;\n    &lt;h1&gt;占位&lt;&#x2F;h1&gt;\n    &lt;el-scrollbar&gt;\n      &lt;sidebar-menu&gt;&lt;&#x2F;sidebar-menu&gt;\n    &lt;&#x2F;el-scrollbar&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport SidebarMenu from &#39;.&#x2F;SidebarMenu&#39;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n那么至此我们生成了一个临时的 menu 菜单，从这个临时的 menu 菜单出可以看到，el-menu 其实分成了三个部分：\n\nel-menu：整个 menu 菜单\nel-submenu：子集 menu 菜单\nel-menu-item：具体菜单项\n\n那么明确好了这些内容之后，接下来我们就可以来去分析一下 动态 menu 菜单如何生成了\n4-10：动态menu菜单处理方案解析上一小节我们处理了 **静态 menu**，那么接下来我们来去处理 动态 menu 菜单\n其实 动态menu菜单 其实主要是和 动态路由表  配合来去实现 用户权限 的。\n但是 用户权限处理 需要等到后面的章节中才可以接触到，因为咱们想要处理 用户权限 还需要先去处理很多的业务场景，所以在这里我们就先只处理 动态menu菜单 这一个概念。\n那么 动态menu菜单 指的到底是什么意思呢？\n所谓 动态menu菜单 指的是：\n\n\n\n\n\n\n\n\n\n根据路由表的配置，自动生成对应的 menu 菜单。\n当路由表发生变化时，menu 菜单自动发生变化\n那么明确了 动态menu菜单 的含义之后，接下来咱们就需要来明确以下 动态menu菜单 的实现方案：\n\n定义 路由表 对应 menu 菜单规则\n根据规则制定 路由表\n根据规则，依据 路由表 ，生成 menu 菜单\n\n那么根据我们的实现方案可以发现，实现 动态menu菜单 最核心的关键点其实就在步骤一，也就是 \n\n\n\n\n\n\n\n\n\n定义 路由表 对应 menu 菜单规则\n那么下面我们就来看一下，这个规则如何制定：\n\n对于单个路由规则而言（循环）：\n如果meta &amp;&amp; meta.title &amp;&amp; meta.icon ：则显示在 menu 菜单中，其中 title 为显示的内容，icon 为显示的图标\n如果存在 children ：则以 el-sub-menu（子菜单） 展示\n否则：则以 el-menu-item（菜单项） 展示\n\n\n否则：不显示在 menu 菜单中\n\n\n\n那么明确好了对应的规则之后，接下来我们就可以来去看一下如何进行实现啦\n4-11：业务落地：生成项目页面组件明确了对应的方案之后，那么下面咱们就来实现对应的代码逻辑。\n根据我们的分析，想要完成动态的 menu，那么我们需要按照以下的步骤来去实现：\n\n创建页面组件\n生成路由表\n解析路由表\n生成 menu 菜单\n\n那么明确好了步骤之后，接下来我们就先来实现第一步\n创建页面组件\n在 views 文件夹下，创建如下页面：\n\n创建文章：article-create\n文章详情：article-detail\n文章排名：article-ranking\n错误页面：error-page\n404\n401\n\n\n导入：import\n权限列表：permission-list\n个人中心：profile\n角色列表：role-list\n用户信息：user-info\n用户管理：user-manage\n\n大家也可以从 项目资料 中直接复制 views（不含 login） 的内容到项目的 views 文件夹下\n4-12：业务落地：创建结构路由表想要实现结构路由表，那么我们需要先知道最终我们要实现的结构是什么样子的，大家来看下面的截图：\n\n\n这是我们最终要实现的 menu 截图\n根据此截图，我们可以知道两点内容：\n\n我们创建的页面并没有全部进行展示\n\n根据该方案\n即不显示页面 不满足 该条件 meta &amp;&amp; meta.title &amp;&amp; meta.icon\n\n\nmenu 菜单将具备父子级的结构\n\n按照此结构规划数据，则数据应为\n[\n    &#123;\n        &quot;title&quot;: &quot;个人中心&quot;,\n        &quot;path&quot;: &quot;&quot;\n    &#125;,\n    &#123;\n        &quot;title&quot;: &quot;用户&quot;,\n        &quot;children&quot;: [\n            &#123;\n                &quot;title&quot;: &quot;员工管理&quot;,\n                &quot;path&quot;: &quot;&quot;\n            &#125;,\n            &#123;\n                &quot;title&quot;: &quot;角色列表&quot;,\n                &quot;path&quot;: &quot;&quot;\n            &#125;,\n            &#123;\n                &quot;title&quot;: &quot;权限列表&quot;,\n                &quot;path&quot;: &quot;&quot;\n            &#125;\n        ]\n    &#125;,\n    &#123;\n        &quot;title&quot;: &quot;文章&quot;,\n        &quot;children&quot;: [\n            &#123;\n                &quot;title&quot;: &quot;文章排名&quot;,\n                &quot;path&quot;: &quot;&quot;\n            &#125;,\n            &#123;\n                &quot;title&quot;: &quot;创建文章&quot;,\n                &quot;path&quot;: &quot;&quot;\n            &#125;\n        ]\n    &#125;\n]\n\n\n\n又因为将来我们需要进行 用户权限处理，所以此时我们需要先对路由表进行一个划分：\n\n私有路由表 privateRoutes ：权限路由\n\n公有路由表 publicRoutes：无权限路由\n\n\n\n根据以上理论，生成以下路由表结构：\n&#x2F;**\n * 私有路由表\n *&#x2F;\nconst privateRoutes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;user&#39;,\n    component: layout,\n    redirect: &#39;&#x2F;user&#x2F;manage&#39;,\n    meta: &#123;\n      title: &#39;user&#39;,\n      icon: &#39;personnel&#39;\n    &#125;,\n    children: [\n      &#123;\n        path: &#39;&#x2F;user&#x2F;manage&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;user-manage&#x2F;index&#39;),\n        meta: &#123;\n          title: &#39;userManage&#39;,\n          icon: &#39;personnel-manage&#39;\n        &#125;\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;user&#x2F;role&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;role-list&#x2F;index&#39;),\n        meta: &#123;\n          title: &#39;roleList&#39;,\n          icon: &#39;role&#39;\n        &#125;\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;user&#x2F;permission&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;permission-list&#x2F;index&#39;),\n        meta: &#123;\n          title: &#39;permissionList&#39;,\n          icon: &#39;permission&#39;\n        &#125;\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;user&#x2F;info&#x2F;:id&#39;,\n        name: &#39;userInfo&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;user-info&#x2F;index&#39;),\n        meta: &#123;\n          title: &#39;userInfo&#39;\n        &#125;\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;user&#x2F;import&#39;,\n        name: &#39;import&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;import&#x2F;index&#39;),\n        meta: &#123;\n          title: &#39;excelImport&#39;\n        &#125;\n      &#125;\n    ]\n  &#125;,\n  &#123;\n    path: &#39;&#x2F;article&#39;,\n    component: layout,\n    redirect: &#39;&#x2F;article&#x2F;ranking&#39;,\n    meta: &#123;\n      title: &#39;article&#39;,\n      icon: &#39;article&#39;\n    &#125;,\n    children: [\n      &#123;\n        path: &#39;&#x2F;article&#x2F;ranking&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;article-ranking&#x2F;index&#39;),\n        meta: &#123;\n          title: &#39;articleRanking&#39;,\n          icon: &#39;article-ranking&#39;\n        &#125;\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;article&#x2F;:id&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;article-detail&#x2F;index&#39;),\n        meta: &#123;\n          title: &#39;articleDetail&#39;\n        &#125;\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;article&#x2F;create&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;article-create&#x2F;index&#39;),\n        meta: &#123;\n          title: &#39;articleCreate&#39;,\n          icon: &#39;article-create&#39;\n        &#125;\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;article&#x2F;editor&#x2F;:id&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;article-create&#x2F;index&#39;),\n        meta: &#123;\n          title: &#39;articleEditor&#39;\n        &#125;\n      &#125;\n    ]\n  &#125;\n]\n\n&#x2F;**\n * 公开路由表\n *&#x2F;\nconst publicRoutes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;login&#39;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;login&#x2F;index&#39;)\n  &#125;,\n  &#123;\n    path: &#39;&#x2F;&#39;,\n    &#x2F;&#x2F; 注意：带有路径“&#x2F;”的记录中的组件“默认”是一个不返回 Promise 的函数\n    component: layout,\n    redirect: &#39;&#x2F;profile&#39;,\n    children: [\n      &#123;\n        path: &#39;&#x2F;profile&#39;,\n        name: &#39;profile&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;profile&#x2F;index&#39;),\n        meta: &#123;\n          title: &#39;profile&#39;,\n          icon: &#39;el-icon-user&#39;\n        &#125;\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;404&#39;,\n        name: &#39;404&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;error-page&#x2F;404&#39;)\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;401&#39;,\n        name: &#39;401&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;error-page&#x2F;401&#39;)\n      &#125;\n    ]\n  &#125;\n]\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHashHistory(),\n  routes: [...publicRoutes, ...privateRoutes]\n&#125;)\n\n最后不要忘记在 layout/appMain 下设置路由出口\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app-main&quot;&gt;\n    &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n\n\n4-13：业务落地：解析路由表，获取结构化数据本小节的目标只有一点，那就是获取到之前明确的结构化数据：\n[\n    &#123;\n        &quot;title&quot;: &quot;个人中心&quot;,\n        &quot;path&quot;: &quot;&quot;\n    &#125;,\n    &#123;\n        &quot;title&quot;: &quot;用户&quot;,\n        &quot;children&quot;: [\n            &#123;\n                &quot;title&quot;: &quot;员工管理&quot;,\n                &quot;path&quot;: &quot;&quot;\n            &#125;,\n            &#123;\n                &quot;title&quot;: &quot;角色列表&quot;,\n                &quot;path&quot;: &quot;&quot;\n            &#125;,\n            &#123;\n                &quot;title&quot;: &quot;权限列表&quot;,\n                &quot;path&quot;: &quot;&quot;\n            &#125;\n        ]\n    &#125;,\n    &#123;\n        &quot;title&quot;: &quot;文章&quot;,\n        &quot;children&quot;: [\n            &#123;\n                &quot;title&quot;: &quot;文章排名&quot;,\n                &quot;path&quot;: &quot;&quot;\n            &#125;,\n            &#123;\n                &quot;title&quot;: &quot;创建文章&quot;,\n                &quot;path&quot;: &quot;&quot;\n            &#125;\n        ]\n    &#125;\n]\n\n那么想要完成本小节的目标，我们就需要先来看一下，现在的路由表结构是什么样子的。\n想要获取路由表数据，那么有两种方式：\n\nrouter.options.routes：初始路由列表（新增的路由 无法获取到）\nrouter.getRoutes()：获取所有 路由记录 的完整列表\n\n所以，我们此时使用 router.getRoutes() \n在 layout/components/Sidebar/SidebarMenu 下写入以下代码：\n&lt;script setup&gt;\nimport &#123; useRouter &#125; from &#39;vue-router&#39;\n\nconst router &#x3D; useRouter()\nconsole.log(router.getRoutes())\n&lt;&#x2F;script&gt;\n\n得到返回的数据：\n[\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;user&#x2F;info&#x2F;:id&quot;,\n        &quot;name&quot;:&quot;userInfo&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;userInfo&quot;\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;article&#x2F;editor&#x2F;:id&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;articleEditor&quot;\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;user&#x2F;manage&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;userManage&quot;,\n            &quot;icon&quot;:&quot;personnel-manage&quot;\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;user&#x2F;role&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;roleList&quot;,\n            &quot;icon&quot;:&quot;role&quot;\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;user&#x2F;permission&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;permissionList&quot;,\n            &quot;icon&quot;:&quot;permission&quot;\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;user&#x2F;import&quot;,\n        &quot;name&quot;:&quot;import&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;excelImport&quot;\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;article&#x2F;ranking&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;articleRanking&quot;,\n            &quot;icon&quot;:&quot;article-ranking&quot;\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;article&#x2F;create&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;articleCreate&quot;,\n            &quot;icon&quot;:&quot;article-create&quot;\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;article&#x2F;:id&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;articleDetail&quot;\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;login&quot;,\n        &quot;meta&quot;:&#123;\n\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;profile&quot;,\n        &quot;name&quot;:&quot;profile&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;profile&quot;,\n            &quot;icon&quot;:&quot;el-icon-user&quot;\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;404&quot;,\n        &quot;name&quot;:&quot;404&quot;,\n        &quot;meta&quot;:&#123;\n\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;401&quot;,\n        &quot;name&quot;:&quot;401&quot;,\n        &quot;meta&quot;:&#123;\n\n        &#125;,\n        &quot;children&quot;:[\n\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;&quot;,\n        &quot;redirect&quot;:&quot;&#x2F;profile&quot;,\n        &quot;meta&quot;:&#123;\n\n        &#125;,\n        &quot;children&quot;:[\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;profile&quot;,\n                &quot;name&quot;:&quot;profile&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;profile&quot;,\n                    &quot;icon&quot;:&quot;el-icon-user&quot;\n                &#125;\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;404&quot;,\n                &quot;name&quot;:&quot;404&quot;\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;401&quot;,\n                &quot;name&quot;:&quot;401&quot;\n            &#125;\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;user&quot;,\n        &quot;redirect&quot;:&quot;&#x2F;user&#x2F;manage&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;user&quot;,\n            &quot;icon&quot;:&quot;personnel&quot;\n        &#125;,\n        &quot;children&quot;:[\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;user&#x2F;manage&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;userManage&quot;,\n                    &quot;icon&quot;:&quot;personnel-manage&quot;\n                &#125;\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;user&#x2F;role&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;roleList&quot;,\n                    &quot;icon&quot;:&quot;role&quot;\n                &#125;\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;user&#x2F;permission&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;permissionList&quot;,\n                    &quot;icon&quot;:&quot;permission&quot;\n                &#125;\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;user&#x2F;info&#x2F;:id&quot;,\n                &quot;name&quot;:&quot;userInfo&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;userInfo&quot;\n                &#125;\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;user&#x2F;import&quot;,\n                &quot;name&quot;:&quot;import&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;excelImport&quot;\n                &#125;\n            &#125;\n        ]\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;article&quot;,\n        &quot;redirect&quot;:&quot;&#x2F;article&#x2F;ranking&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;article&quot;,\n            &quot;icon&quot;:&quot;article&quot;\n        &#125;,\n        &quot;children&quot;:[\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;article&#x2F;ranking&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;articleRanking&quot;,\n                    &quot;icon&quot;:&quot;article-ranking&quot;\n                &#125;\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;article&#x2F;:id&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;articleDetail&quot;\n                &#125;\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;article&#x2F;create&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;articleCreate&quot;,\n                    &quot;icon&quot;:&quot;article-create&quot;\n                &#125;\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;article&#x2F;editor&#x2F;:id&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;articleEditor&quot;\n                &#125;\n            &#125;\n        ]\n    &#125;\n]\n\n从返回的数据来看，它与我们想要的数据结构相去甚远。\n出现这个问题的原因，是因为它返回的是一个 完整的路由表\n这个路由表距离我们想要的存在两个问题：\n\n存在重复的路由数据\n不满足该条件 meta &amp;&amp; meta.title &amp;&amp; meta.icon 的数据不应该存在\n\n那么接下来我们就应该来处理这两个问题\n创建 utils/route 文件，创建两个方法分别处理对应的两个问题：\n\nfilterRouters\ngenerateMenus\n\n写入以下代码：\nimport path from &#39;path&#39;\n\n&#x2F;**\n * 返回所有子路由\n *&#x2F;\nconst getChildrenRoutes &#x3D; routes &#x3D;&gt; &#123;\n  const result &#x3D; []\n  routes.forEach(route &#x3D;&gt; &#123;\n    if (route.children &amp;&amp; route.children.length &gt; 0) &#123;\n      result.push(...route.children)\n    &#125;\n  &#125;)\n  return result\n&#125;\n&#x2F;**\n * 处理脱离层级的路由：某个一级路由为其他子路由，则剔除该一级路由，保留路由层级\n * @param &#123;*&#125; routes router.getRoutes()\n *&#x2F;\nexport const filterRouters &#x3D; routes &#x3D;&gt; &#123;\n  const childrenRoutes &#x3D; getChildrenRoutes(routes)\n  return routes.filter(route &#x3D;&gt; &#123;\n    return !childrenRoutes.find(childrenRoute &#x3D;&gt; &#123;\n      return childrenRoute.path &#x3D;&#x3D;&#x3D; route.path\n    &#125;)\n  &#125;)\n&#125;\n\n&#x2F;**\n * 判断数据是否为空值\n *&#x2F;\nfunction isNull(data) &#123;\n  if (!data) return true\n  if (JSON.stringify(data) &#x3D;&#x3D;&#x3D; &#39;&#123;&#125;&#39;) return true\n  if (JSON.stringify(data) &#x3D;&#x3D;&#x3D; &#39;[]&#39;) return true\n  return false\n&#125;\n&#x2F;**\n * 根据 routes 数据，返回对应 menu 规则数组\n *&#x2F;\nexport function generateMenus(routes, basePath &#x3D; &#39;&#39;) &#123;\n  const result &#x3D; []\n  &#x2F;&#x2F; 遍历路由表\n  routes.forEach(item &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 不存在 children &amp;&amp; 不存在 meta 直接 return\n    if (isNull(item.meta) &amp;&amp; isNull(item.children)) return\n    &#x2F;&#x2F; 存在 children 不存在 meta，进入迭代\n    if (isNull(item.meta) &amp;&amp; !isNull(item.children)) &#123;\n      result.push(...generateMenus(item.children))\n      return\n    &#125;\n    &#x2F;&#x2F; 合并 path 作为跳转路径\n    const routePath &#x3D; path.resolve(basePath, item.path)\n    &#x2F;&#x2F; 路由分离之后，存在同名父路由的情况，需要单独处理\n    let route &#x3D; result.find(item &#x3D;&gt; item.path &#x3D;&#x3D;&#x3D; routePath)\n    if (!route) &#123;\n      route &#x3D; &#123;\n        ...item,\n        path: routePath,\n        children: []\n      &#125;\n\n      &#x2F;&#x2F; icon 与 title 必须全部存在\n      if (route.meta.icon &amp;&amp; route.meta.title) &#123;\n        &#x2F;&#x2F; meta 存在生成 route 对象，放入 arr\n        result.push(route)\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 存在 children 进入迭代到children\n    if (item.children) &#123;\n      route.children.push(...generateMenus(item.children, route.path))\n    &#125;\n  &#125;)\n  return result\n&#125;\n\n\n在 SidebarMenu 中调用该方法\n&lt;script setup&gt;\nimport &#123; computed &#125; from &#39;vue&#39;\nimport &#123; useRouter &#125; from &#39;vue-router&#39;\nimport &#123; filterRouters, generateMenus &#125; from &#39;@&#x2F;utils&#x2F;route&#39;\n\nconst router &#x3D; useRouter()\nconst routes &#x3D; computed(() &#x3D;&gt; &#123;\n  const filterRoutes &#x3D; filterRouters(router.getRoutes())\n  return generateMenus(filterRoutes)\n&#125;)\nconsole.log(JSON.stringify(routes.value))\n&lt;&#x2F;script&gt;\n\n得到该数据结构\n[\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;profile&quot;,\n        &quot;name&quot;:&quot;profile&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;profile&quot;,\n            &quot;icon&quot;:&quot;el-icon-user&quot;\n        &#125;,\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;user&quot;,\n        &quot;redirect&quot;:&quot;&#x2F;user&#x2F;manage&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;user&quot;,\n            &quot;icon&quot;:&quot;personnel&quot;\n        &#125;,\n        &quot;props&quot;:&#123;\n            &quot;default&quot;:false\n        &#125;,\n        &quot;children&quot;:[\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;user&#x2F;manage&quot;,\n                &quot;name&quot;:&quot;userManage&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;userManage&quot;,\n                    &quot;icon&quot;:&quot;personnel-manage&quot;\n                &#125;,\n                &quot;children&quot;:[\n\n                ]\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;user&#x2F;role&quot;,\n                &quot;name&quot;:&quot;userRole&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;roleList&quot;,\n                    &quot;icon&quot;:&quot;role&quot;\n                &#125;,\n                &quot;children&quot;:[\n\n                ]\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;user&#x2F;permission&quot;,\n                &quot;name&quot;:&quot;userPermission&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;permissionList&quot;,\n                    &quot;icon&quot;:&quot;permission&quot;\n                &#125;,\n                &quot;children&quot;:[\n\n                ]\n            &#125;\n        ],\n    &#125;,\n    &#123;\n        &quot;path&quot;:&quot;&#x2F;article&quot;,\n        &quot;redirect&quot;:&quot;&#x2F;article&#x2F;ranking&quot;,\n        &quot;meta&quot;:&#123;\n            &quot;title&quot;:&quot;article&quot;,\n            &quot;icon&quot;:&quot;article&quot;\n        &#125;,\n        &quot;props&quot;:&#123;\n            &quot;default&quot;:false\n        &#125;,\n        &quot;children&quot;:[\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;article&#x2F;ranking&quot;,\n                &quot;name&quot;:&quot;articleRanking&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;articleRanking&quot;,\n                    &quot;icon&quot;:&quot;article-ranking&quot;\n                &#125;,\n                &quot;children&quot;:[\n\n                ]\n            &#125;,\n            &#123;\n                &quot;path&quot;:&quot;&#x2F;article&#x2F;create&quot;,\n                &quot;name&quot;:&quot;articleCreate&quot;,\n                &quot;meta&quot;:&#123;\n                    &quot;title&quot;:&quot;articleCreate&quot;,\n                    &quot;icon&quot;:&quot;article-create&quot;\n                &#125;,\n                &quot;children&quot;:[\n\n                ]\n            &#125;\n        ],\n    &#125;\n]\n\n\n\n4-14: 业务落地：生成动态 menu 菜单有了数据结构之后，最后的步骤就水到渠成了\n整个 menu 菜单，我们将分成三个组件来进行处理\n\nSidebarMenu：处理数据，作为最顶层 menu 载体\nSidebarItem：根据数据处理 当前项为 el-submenu || el-menu-item \nMenuItem：处理 el-menu-item 样式\n\n那么下面我们一个个来处理\n首先是 SidebarMenu \n&lt;template&gt;\n  &lt;!-- 一级 menu 菜单 --&gt;\n  &lt;el-menu\n    ...\n  &gt;\n    &lt;sidebar-item\n      v-for&#x3D;&quot;item in routes&quot;\n      :key&#x3D;&quot;item.path&quot;\n      :route&#x3D;&quot;item&quot;\n    &gt;&lt;&#x2F;sidebar-item&gt;\n  &lt;&#x2F;el-menu&gt;\n&lt;&#x2F;template&gt;\n\n\n\n\n创建 SidebarItem 组件，用来根据数据处理 当前项为 el-submenu || el-menu-item \n&lt;template&gt;\n  &lt;!-- 支持渲染多级 menu 菜单 --&gt;\n  &lt;el-submenu v-if&#x3D;&quot;route.children.length &gt; 0&quot; :index&#x3D;&quot;route.path&quot;&gt;\n    &lt;template #title&gt;\n      &lt;menu-item :title&#x3D;&quot;route.meta.title&quot; :icon&#x3D;&quot;route.meta.icon&quot;&gt;&lt;&#x2F;menu-item&gt;\n    &lt;&#x2F;template&gt;\n    &lt;!-- 循环渲染 --&gt;\n    &lt;sidebar-item\n      v-for&#x3D;&quot;item in route.children&quot;\n      :key&#x3D;&quot;item.path&quot;\n      :route&#x3D;&quot;item&quot;\n    &gt;&lt;&#x2F;sidebar-item&gt;\n  &lt;&#x2F;el-submenu&gt;\n  &lt;!-- 渲染 item 项 --&gt;\n  &lt;el-menu-item v-else :index&#x3D;&quot;route.path&quot;&gt;\n    &lt;menu-item :title&#x3D;&quot;route.meta.title&quot; :icon&#x3D;&quot;route.meta.icon&quot;&gt;&lt;&#x2F;menu-item&gt;\n  &lt;&#x2F;el-menu-item&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport MenuItem from &#39;.&#x2F;MenuItem&#39;\nimport &#123; defineProps &#125; from &#39;vue&#39;\n&#x2F;&#x2F; 定义 props\ndefineProps(&#123;\n  route: &#123;\n    type: Object,\n    required: true\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n创建 MenuItem 用来处理 el-menu-item 样式\n&lt;template&gt;\n  &lt;i v-if&#x3D;&quot;icon.includes(&#39;el-icon&#39;)&quot; class&#x3D;&quot;sub-el-icon&quot; :class&#x3D;&quot;icon&quot;&gt;&lt;&#x2F;i&gt;\n  &lt;svg-icon v-else :icon&#x3D;&quot;icon&quot;&gt;&lt;&#x2F;svg-icon&gt;\n  &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; defineProps &#125; from &#39;vue&#39;\ndefineProps(&#123;\n  title: &#123;\n    type: String,\n    required: true\n  &#125;,\n  icon: &#123;\n    type: String,\n    required: true\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n&lt;&#x2F;style&gt;\n\n至此，整个的 menu 菜单结构就已经完成了\n但是此时我们的 menu 菜单还存在三个小的问题：\n\n样式问题\n路由跳转问题\n默认激活项\n\n那么下一小节，我们来修复这些残余的问题\n4-15：业务落地：修复最后残余问题目前 menu 菜单存在三个问题\n\n样式问题\n路由跳转问题\n默认激活项\n\n样式问题：\n首先处理样式，因为后面我们需要处理 主题替换 ，所以此处我们不能把样式写死\n在 store/getters 中创建一个新的 快捷访问\nimport variables from &#39;@&#x2F;styles&#x2F;variables.scss&#39;\nconst getters &#x3D; &#123;\n  ...\n  cssVar: state &#x3D;&gt; variables\n&#125;\nexport default getters\n\n在 SidebarMenu 中写入如下样式\n&lt;el-menu\n    :background-color&#x3D;&quot;$store.getters.cssVar.menuBg&quot;\n    :text-color&#x3D;&quot;$store.getters.cssVar.menuText&quot;\n    :active-text-color&#x3D;&quot;$store.getters.cssVar.menuActiveText&quot;\n    :unique-opened&#x3D;&quot;true&quot;\n  &gt;\n\n路由跳转问题：\n为 el-menu 指定 router\n&lt;el-menu\n   ...\n   router\n &gt;\n\n\n\n默认激活项：\n根据当前 url 进行判断即可\n\n  &lt;el-menu\n    :default-active&#x3D;&quot;activeMenu&quot;\n    ...\n  &gt;\n\n&lt;script setup&gt;\n...\n\n&#x2F;&#x2F; 计算高亮 menu 的方法\nconst route &#x3D; useRoute()\nconst activeMenu &#x3D; computed(() &#x3D;&gt; &#123;\n  const &#123; path &#125; &#x3D; route\n  return path\n&#125;)\n&lt;&#x2F;script&gt;\n\n\n至此整个 动态menu完成\n4-16：动画逻辑，左侧菜单伸缩功能实现下面我们来实现一个标准化功能 左侧菜单伸缩 ，对于这个功能核心的点在于动画处理\n样式的改变总是由数据进行驱动，所以首先我们去创建对应的数据\n创建 store/app 模块，写入如下代码\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;\n    sidebarOpened: true\n  &#125;),\n  mutations: &#123;\n    triggerSidebarOpened(state) &#123;\n      state.sidebarOpened &#x3D; !state.sidebarOpened\n    &#125;\n  &#125;,\n  actions: &#123;&#125;\n&#125;\n\n\n在 store/index 中进行导入\n...\nimport app from &#39;.&#x2F;modules&#x2F;app&#39;\nexport default createStore(&#123;\n  getters,\n  modules: &#123;\n    ...\n    app\n  &#125;\n&#125;)\n\n在 store/getters 中创建快捷访问\nsidebarOpened: state &#x3D;&gt; state.app.sidebarOpened\n\n创建 components/hamburger 组件，用来控制数据\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;hamburger-container&quot; @click&#x3D;&quot;toggleClick&quot;&gt;\n    &lt;svg-icon class&#x3D;&quot;hamburger&quot; :icon&#x3D;&quot;icon&quot;&gt;&lt;&#x2F;svg-icon&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; computed &#125; from &#39;vue&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\n\nconst store &#x3D; useStore()\nconst toggleClick &#x3D; () &#x3D;&gt; &#123;\n  store.commit(&#39;app&#x2F;triggerSidebarOpened&#39;)\n&#125;\n\nconst icon &#x3D; computed(() &#x3D;&gt;\n  store.getters.sidebarOpened ? &#39;hamburger-opened&#39; : &#39;hamburger-closed&#39;\n)\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.hamburger-container &#123;\n  padding: 0 16px;\n  .hamburger &#123;\n    display: inline-block;\n    vertical-align: middle;\n    width: 20px;\n    height: 20px;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n在 navbar 中使用该组件\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;navbar&quot;&gt;\n    &lt;hamburger class&#x3D;&quot;hamburger-container&quot; &#x2F;&gt;\n    ...\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport Hamburger from &#39;@&#x2F;components&#x2F;Hamburger&#39;\n...\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.navbar &#123;\n  ...\n\n  .hamburger-container &#123;\n    line-height: 46px;\n    height: 100%;\n    float: left;\n    cursor: pointer;\n    &#x2F;&#x2F; hover 动画\n    transition: background 0.5s;\n\n    &amp;:hover &#123;\n      background: rgba(0, 0, 0, 0.1);\n    &#125;\n  &#125;\n\n ...\n&#125;\n&lt;&#x2F;style&gt;\n\n\n在 SidebarMenu 中，控制 el-menu 的 collapse 属性\n&lt;el-menu\n    :collapse&#x3D;&quot;!$store.getters.sidebarOpened&quot;\n    ...\n\n在 layout/index 中指定 整个侧边栏的宽度和缩放动画\n&lt;div\n    class&#x3D;&quot;app-wrapper&quot;\n    :class&#x3D;&quot;[$store.getters.sidebarOpened ? &#39;openSidebar&#39; : &#39;hideSidebar&#39;]&quot;\n  &gt;\n  ...\n\n在 layout/index 中 处理 navbar 的宽度\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n...\n\n.fixed-header &#123;\n  position: fixed;\n  top: 0;\n  right: 0;\n  z-index: 9;\n  width: calc(100% - #&#123;$sideBarWidth&#125;);\n  transition: width 0.28s;\n&#125;\n\n.hideSidebar .fixed-header &#123;\n  width: calc(100% - #&#123;$hideSideBarWidth&#125;);\n&#125;\n&lt;&#x2F;style&gt;\n\n在 styles/variables.scss 中指定 hideSideBarWidth\n$hideSideBarWidth: 54px;\n\n\n\n4-17： SidebarHeader 处理整个左侧的 menu 菜单，到现在咱们还剩下最后一个 header 没有进行处理\n在 sidebar/index 中写入如下代码\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;\n    &lt;div class&#x3D;&quot;logo-container&quot;&gt;\n      &lt;el-avatar\n        size&#x3D;&quot;44&quot;\n        shape&#x3D;&quot;square&quot;\n        src&#x3D;&quot;https:&#x2F;&#x2F;m.imooc.com&#x2F;static&#x2F;wap&#x2F;static&#x2F;common&#x2F;img&#x2F;logo-small@2x.png&quot;\n      &#x2F;&gt;\n      &lt;h1 class&#x3D;&quot;logo-title&quot; v-if&#x3D;&quot;$store.getters.sidebarOpened&quot;&gt;\n       imooc-admin\n      &lt;&#x2F;h1&gt;\n    &lt;&#x2F;div&gt;\n    ...\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.logo-container &#123;\n  height: 44px;\n  padding: 10px 0 22px 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  .logo-title &#123;\n    margin-left: 10px;\n    color: #fff;\n    font-weight: 600;\n    line-height: 50px;\n    font-size: 16px;\n    white-space: nowrap;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n创建 styles/element.scss 文件，统一处理 el-avatar 的背景问题\n.el-avatar &#123;\n  --el-avatar-background-color: none;\n&#125;\n\n在 styles/index.scss 中导入\n...\n@import &#39;.&#x2F;element.scss&#39;;\n\n统一处理下动画时长的问题，在 styles/variables.scss 中，加入以下变量\n$sideBarDuration: 0.28s;\n\n为 styles/sidebar.scss 修改时长\n.main-container &#123;\n  transition: margin-left #&#123;$sideBarDuration&#125;;\n ...\n&#125;\n\n.sidebar-container &#123;\n  transition: width #&#123;$sideBarDuration&#125;;\n\t...\n&#125;\n\n为 layout/index 修改样式\n.fixed-header &#123;\n  ...\n  transition: width #&#123;$sideBarDuration&#125;;\n&#125;\n\n4-18：全新 vue 能力：组件状态驱动的动态 CSS 值在 vue 3.2 最新更新中，除了之前我们介绍的 响应式变化 之外，还有另外一个很重要的更新，那就是 组件状态驱动的动态 CSS 值 ，对应的文档也已经公布，大家可以 点击这里 查看\n那么下面我们就使用下最新的特性，来为 logo-container 指定下高度：\n&lt;template&gt;\n ...\n &lt;el-avatar\n \t:size&#x3D;&quot;logoHeight&quot;\n ...\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\n...\nconst logoHeight &#x3D; 44\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.logo-container &#123;\n  height: v-bind(logoHeight) + &#39;px&#39;;\n...\n&#125;\n&lt;&#x2F;style&gt;\n\n\n4-19：动态面包屑方案分析到目前位置，本章中还剩下最后一个功能就是 面包屑导航，分为：\n\n静态面包屑\n动态面包屑\n\n静态面包屑：\n指的是：在每个页面中写死对应的面包屑菜单，缺点也很明显：\n\n每个页面都得写一遍\n页面路径结构变化了，得手动更改\n\n简单来说就是 不好维护，不好扩展 。\n动态面包屑：\n根据当前的 url 自动生成面包屑导航菜单\n无论之后路径发生了什么变化，动态面包屑 都会正确的进行计算\n那么在后面的实现过程中，我们将会分成三大步来实现\n\n创建、渲染基本的面包屑组件\n计算面包屑结构数据\n根据数据渲染动态面包屑内容\n\n4-20：业务落地：渲染基本的面包屑组件完成第一步，先去创建并渲染出基本的 面包屑 组件\n创建 components/Breadcrumb/index，并写入如下代码：\n&lt;template&gt;\n  &lt;el-breadcrumb class&#x3D;&quot;breadcrumb&quot; separator&#x3D;&quot;&#x2F;&quot;&gt;\n    &lt;el-breadcrumb-item :to&#x3D;&quot;&#123; path: &#39;&#x2F;&#39; &#125;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;\n    &lt;el-breadcrumb-item&gt;&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;活动管理&lt;&#x2F;a&gt;&lt;&#x2F;el-breadcrumb-item&gt;\n    &lt;el-breadcrumb-item&gt;活动列表&lt;&#x2F;el-breadcrumb-item&gt;\n    &lt;!-- 面包屑的最后一项 --&gt;\n    &lt;el-breadcrumb-item&gt;\n      &lt;span class&#x3D;&quot;no-redirect&quot;&gt;活动详情&lt;&#x2F;span&gt;\n    &lt;&#x2F;el-breadcrumb-item&gt;\n  &lt;&#x2F;el-breadcrumb&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.breadcrumb &#123;\n  display: inline-block;\n  font-size: 14px;\n  line-height: 50px;\n  margin-left: 8px;\n\n  ::v-deep .no-redirect &#123;\n    color: #97a8be;\n    cursor: text;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n在 layout/components/Navbar 组件下导入\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;navbar&quot;&gt;\n    &lt;hamburger class&#x3D;&quot;hamburger-container&quot; &#x2F;&gt;\n    &lt;breadcrumb class&#x3D;&quot;breadcrumb-container&quot; &#x2F;&gt;\n\t...\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n...\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.navbar &#123;\n ...\n\n  .breadcrumb-container &#123;\n    float: left;\n  &#125;\n   ...\n&#125;\n&lt;&#x2F;style&gt;\n\n\n\n\n4-21：业务落地：动态计算面包屑结构数据现在我们是完成了一个静态的 面包屑，接下来咱们就需要依托这个静态的菜单来完成动态的。\n对于现在的静态面包屑来说，他分成了两个组件：\n\nel-breadcrumb：包裹性质的容器\nel-breadcrumb-item：每个单独项\n\n如果我们想要完成动态的，那么就需要 **依据动态数据，渲染 el-breadcrumb-item **\n所以说接下来我们需要做的事情就很简单了\n\n动态数据\n渲染 el-breadcrumb-item\n\n那么这一小节咱们先来看 动态数据如何制作\n我们希望可以制作出一个 数组，数组中每个 item 都表示一个 路由信息：\n创建一个方法，用来生成数组数据，在这里我们要使用到 route.match 属性来：获取与给定路由地址匹配的标准化的路由记录数组\n&lt;script setup&gt;\nimport &#123; ref, watch &#125; from &#39;vue&#39;\nimport &#123; useRoute &#125; from &#39;vue-router&#39;\n\nconst route &#x3D; useRoute()\n&#x2F;&#x2F; 生成数组数据\nconst breadcrumbData &#x3D; ref([])\nconst getBreadcrumbData &#x3D; () &#x3D;&gt; &#123;\n  breadcrumbData.value &#x3D; route.matched.filter(\n    item &#x3D;&gt; item.meta &amp;&amp; item.meta.title\n  )\n  console.log(breadcrumbData.value)\n&#125;\n&#x2F;&#x2F; 监听路由变化时触发\nwatch(\n  route,\n  () &#x3D;&gt; &#123;\n    getBreadcrumbData()\n  &#125;,\n  &#123;\n    immediate: true\n  &#125;\n)\n&lt;&#x2F;script&gt;\n\n\n\n4-22：业务落地：依据动态数据，渲染面包屑有了数据之后，根据数据来去渲染面包屑就比较简单了。\n&lt;template&gt;\n  &lt;el-breadcrumb class&#x3D;&quot;breadcrumb&quot; separator&#x3D;&quot;&#x2F;&quot;&gt;\n    &lt;el-breadcrumb-item\n      v-for&#x3D;&quot;(item, index) in breadcrumbData&quot;\n      :key&#x3D;&quot;item.path&quot;\n    &gt;\n      &lt;!-- 不可点击项 --&gt;\n      &lt;span v-if&#x3D;&quot;index &#x3D;&#x3D;&#x3D; breadcrumbData.length - 1&quot; class&#x3D;&quot;no-redirect&quot;&gt;&#123;&#123;\n        item.meta.title\n      &#125;&#125;&lt;&#x2F;span&gt;\n      &lt;!-- 可点击项 --&gt;\n      &lt;a v-else class&#x3D;&quot;redirect&quot; @click.prevent&#x3D;&quot;onLinkClick(item)&quot;&gt;&#123;&#123;\n        item.meta.title\n      &#125;&#125;&lt;&#x2F;a&gt;\n    &lt;&#x2F;el-breadcrumb-item&gt;\n  &lt;&#x2F;el-breadcrumb&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\n...\n\n&#x2F;&#x2F; 处理点击事件\nconst router &#x3D; useRouter()\nconst onLinkClick &#x3D; item &#x3D;&gt; &#123;\n  console.log(item)\n  router.push(item.path)\n&#125;\n\n&#x2F;&#x2F; 将来需要进行主题替换，所以这里获取下动态样式\nconst store &#x3D; useStore()\n&#x2F;&#x2F; eslint-disable-next-line\nconst linkHoverColor &#x3D; ref(store.getters.cssVar.menuBg)\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.breadcrumb &#123;\n ...\n\n  .redirect &#123;\n    color: #666;\n    font-weight: 600;\n  &#125;\n\n  .redirect:hover &#123;\n    &#x2F;&#x2F; 将来需要进行主题替换，所以这里不去写死样式\n    color: v-bind(linkHoverColor);\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n4-23：vue3 动画处理vue3对 动画 进行了一些修改（vue 动画迁移文档）\n主要的修改其实只有两个：\n\n过渡类名 v-enter 修改为 v-enter-from\n过渡类名 v-leave 修改为 v-leave-from\n\n那么依据修改之后的动画，我们来为面包屑增加一些动画样式：\n\n在 Breadcrumb/index 中增加 transition-group\n&lt;template&gt;\n  &lt;el-breadcrumb class&#x3D;&quot;breadcrumb&quot; separator&#x3D;&quot;&#x2F;&quot;&gt;\n    &lt;transition-group name&#x3D;&quot;breadcrumb&quot;&gt;\n      ...\n    &lt;&#x2F;transition-group&gt;\n  &lt;&#x2F;el-breadcrumb&gt;\n&lt;&#x2F;template&gt;\n\n新建 styles/transition 样式文件\n.breadcrumb-enter-active,\n.breadcrumb-leave-active &#123;\n  transition: all 0.5s;\n&#125;\n\n.breadcrumb-enter-from,\n.breadcrumb-leave-active &#123;\n  opacity: 0;\n  transform: translateX(20px);\n&#125;\n\n.breadcrumb-leave-active &#123;\n  position: absolute;\n&#125;\n\n在 styles/index 中导入\n@import &#39;.&#x2F;transition.scss&#39;;\n\n4-24：总结到这里我们本章的内容就算是完成了，本章围绕着layout 为核心，主要实现了三个大的业务方案：\n\n用户退出方案\n动态侧边栏方案\n动态面包屑方案\n\n除了这三块大的方案之后，还有一些小的功能，比如：\n\n退出的通用逻辑封装\n伸缩侧边栏动画\nvue3 动画\n组件状态驱动的动态 CSS 值等等\n\n那么这些方案的实现逻辑，就不在这里在跟大家重复了。\n这些方案在企业后台项目开发中，整体的覆盖率还是很高的\n那么在下一章节中，我们会去讲解一些通用的功能方案，相信这些功能方案大家一定都或多或少的遇到过，并且给大家带来过一定的麻烦。\n那么具体这样方案都有什么呢？我们一起期待吧！\n","slug":"vue3.2后台管理系统/04搭建Layout架构","date":"2022-08-22T14:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"d2e69685384ff9d5134e8cda74cb22b8","title":"03搭建登录架构","content":"03搭建登录架构01：前言在上一章中，我们处理了基本的编码规范，那么接下来我们就可以实现对应的项目开发了。\n那么在之后的项目开发中，我们将会使用最新的 vue3 script setup 语法。\n所以说在本章节中我们需要做两件事情：\n\nvue3 最新特性及最新语法\n\n登录功能开发\n\n\n\n不过大家放心，我们不会把大量的时间花费到 枯燥的语法学习之中，而是会在实际的项目开发中和大家一起逐渐深入学习  script setup 语法，毕竟 学以致用 才是我们遵循的唯一目标。\n那么明确好了我们接下来要做的事情之后，咱们就开始新的篇章吧！\n02：vue3 项目结构解析想要进行项目的开发，那么首先我们需要先去了解一下 vue3 项目的初始结构\n在这里我们把它和 vue2 的项目进行对比来去说明\n\nmain.js\n通过 按需导入的 createApp 方法来来构建 vue 实例\n通过 vue实例.use 方法来挂载插件（router、vuex）\n没有了 Vue 构造方法，无法再挂载原型\n\n\nApp.vue\n组件内部结构无变化，依然是\ntempalte\nscript\nstyle\n\n\n&lt;template&gt; 标签中支持多个根标签\n\n\nstore/index.js\n通过 按需导入的 createStore 方法来来构建 store 实例\n无需再通过 Vue.use(Vuex) 的形式进行挂载\n\n\nrouter/index.js\n通过 按需导入的 createRouter 方法来构建 router 实例\n通过 按需导入的 createWebHashHistory 方法来创建 hash 模式对象，进行路由模式指定\n无需再通过 Vue.use(VueRouter) 的形式进行挂载\nroutes 路由表的定义无差别\n\n\n\n综上所述，在 vue3 的初始化项目中，与 vue2 对比的最大差异其实就是两点：\n\nvue3 使用 按需导入的形式 进行初始化操作\n&lt;template&gt; 标签中支持多个根标签\n\n那么这一小节我们主要了解了 vue3 项目的初始结构，通过了解我们也可以发现现在的项目中，存在很多的 无用代码，那么下一小节我们就需要 删除掉这些无用的默认代码，也就是进行  初始化项目 操作。\n03：初始化项目结构@vue/cli 在帮助我们创建项目的同时，也生成了很多无用的代码，那么这一小节我们需要去除掉这些无用的代码。\n去除的方式如下所示：\n\nApp.vue 初始化代码如下：\n&lt;template&gt;\n  &lt;router-view &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot;&gt;&lt;&#x2F;style&gt;\n\n删除 views 文件夹下的所有 .vue 文件\n\n删除 components 文件夹下的所有 .vue 文件\n\nrouter/index.js 中初始化代码如下：\nimport &#123; createRouter, createWebHashHistory &#125; from &#39;vue-router&#39;\n\nconst routes &#x3D; []\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHashHistory(),\n  routes\n&#125;)\n\nexport default router\n\n\n浏览器中重新访问你的应用，得到如下页面即可：\n\n\n04：vue3 新特性介绍在开始本小节的内容之前，我必须要先声明一点：\n我们不会在课程中专门开辟出一段内容讲解 vue3 的知识。而是会在项目开发的过程中，通过实际场景逐步解锁对应的知识点，以达到学以致用的目的！\n所以说本小节的 vue3 新特性介绍 ，我们只会概述性的来介绍一下 vue3 中新增的主要内容。\n那么明确好了我们的目标之后，vue3 中到底新增了哪些比较核心的东西呢？：\n\ncomposition API\n使用了 Proxy 代替 Object.defineProperty() 实现响应式\n全新的全家桶\n全新的 TS 支持\nvite\n\nComposition API：组合式 API想要了解 组合式 API，那么首先我们需要先了解 options API，也就是 vue2 中的开发形式。\nvue2 中的开发形式被称为 options API，options API 存在\n\n方便\n易学\n清晰\n\n等一些特点，但是也存在着一些问题。\n而其中最主要的一个问题就是：当你的组件变得越来越复杂时，组件的可读性会变得越来越差。\n不知道大家有没有遇到过一种情况，那就是：你在完成一个组件代码时，总是需要不停的上下滚动滚轮，来查看 data 、methods、computed 之间的配合使用，就像下面一样\n![](.&#x2F;03搭建登录架构&#x2F;options api.gif)\n这个截图中的代码大家不需要深究。\n在这个动图中我们定义的两个数据 optionsData 和 selectOption，然后我们在多个方法中都使用到了它们，但是大家可以发现，我们在使用或查看的过程中，得一直不停的翻动页面！\n因为我们的整体组件代码结构是这样的：\n\n\n定义数据与使用数据被分割在组件的各个位置，导致我们需要不断地翻滚页面来查看具体的业务逻辑！\n并且这种现象随着组件越来越复杂，这种情况会变得越来越严重！\n而这个就是 options API 所存在的问题：当你的组件变得越来越复杂时，组件的可读性会变得越来越差。\n而 Composition API 所期望解决的就是这么一个问题\n\n\n把定义数据与使用数据的逻辑放在一起进行处理，以达到更加易读，更加方便扩展的目的！\n那么具体怎么去做的，我们会在后面的课程中通过最新的 RFC -&gt; script setup 语法为大家进行解读。 \n使用了 Proxy 代替 Object.defineProperty() 实现响应式在 vue 2 的文档中 有这么一段话：\n\n\n\n\n\n\n\n\n\n由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。\n这里所谓的 JavaScript 的限制，所指的就是 Object.defineProperty() 的限制。\n因为 Object.defineProperty() 是通过：为对象属性指定描述符 的方式来监听 **对象中某个属性的 get 和 set**。\n所以在以下两种情况下，新的属性是 非响应式的：\n\n对于对象：\nvar vm &#x3D; new Vue(&#123;\n  data:&#123;\n    a:1\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; &#96;vm.a&#96; 是响应式的\n\nvm.b &#x3D; 2\n&#x2F;&#x2F; &#96;vm.b&#96; 是非响应式的\n\n\n\n对于数组：\nvar vm &#x3D; new Vue(&#123;\n  data: &#123;\n    items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n  &#125;\n&#125;)\nvm.items[1] &#x3D; &#39;x&#39; &#x2F;&#x2F; 不是响应性的\nvm.items.length &#x3D; 2 &#x2F;&#x2F; 不是响应性的\n\n这也是为什么会存在 Vue.set 这个 API 的原因。\n但是，这样的一种情况其实一直都是不合理的，因为这只是无意义的增加了复杂度而已，但是一直以来因为  Object.defineProperty() 这个 API 本身的限制，所以一直无法处理。\n直到 Proxy 被广泛支持，这种情况才发生了变化。\nProxy 用于：为对象创建一个代理，从而实现基本操作的拦截。 那么这样就从根本上解决了 Object.defineProperty() 所面临的那么两个问题。这也是为什么 vue3 中不再有 Vue.set 方法的原因。\n关于 proxy 的详细介绍，大家可以查看这一篇博客 Vue 3 深入响应式原理 - 聊一聊响应式构建的那些经历，在视频中，我们就不过多赘述了\n全新的全家桶vue 被称为是 渐进式框架，就是因为，对于 vue 而言，它不仅仅只有 vue.js 这一个核心库，还有其他的比如 vue-router，vuex 等一些周边库。这些周边库和 vue.js 一起共同组成了 vue 。\n所以说当 vue3 发布之后，vue-router、vuex 等全家桶也迎来了一波更新。在前面的 vue3 项目结构解析 这一小节，大家应该也能看到对应的代码变化。\n那么关于全家桶的更新内容，我们会在后面的课程中进行详细的讲解，所以就不在这里进行赘述了。\n全新的 TS 支持vue 3 使用 TypeScript 进行了重构，其目的是 为了防止随着应用的增长，而产生的许多潜在的运行时静态类型的错误 。同时这也意味着以后在 vue 中使用 TypeScript 不再需要其他的任何工具。\n但是有一点我需要提醒大家，虽然 vue 对 TypeScript 进行全面支持，这并不代表我们应该在任何情况下都无条件的使用 TypeScript（后面我们简称 TypeScript 为 TS）。\nTS 的优势主要在于 静态类型检查和环境声明，但同时它也会为你的项目增加复杂度。如果你的项目需要使用到以上两点，那么我推荐你使用 TS 。否则只是增加了无谓的复杂度而已。\n决定我们应该使用哪种技术的唯一条件，就是我们的目标。 我们需要做的是在可以 完成目标 的基础上，寻找最简单的实现方案。\n所以，基于以上原因，我们项目中并没有使用 TS 进行项目的开发。如果在后续的过程中，发现大家有这方面的需要，那么我会考虑专门针对 TS 的特性来开发一个对应的项目。\nvite最后就是一个新的打包工具 vite，vite 严格来说不能算是 vue3 的内容，只不过它跟随 vue3 进行了发布所以我们这里就把它算到了新特性里面。\nvite 的作用其实和 webpack 是一样的，都是一个 前端构建工具。它区别于 webpack 的地方在于它完全使用了 ES Module 的特性，可以无需预先打包，而是采用实时编译的方式。这样让它具备了远高于 webpack 的启动速度和热更新速度。\n但是 成也萧何，败也萧何 因为 vite 完全依赖 ES Module 就导致了 它无法直接对 commonJS 的模块化方式进行支持，必须得采用 依赖预构建 的形式。\n目前 vite 还不够稳定到足够支持商用，所以如果大家只是想要尝鲜，那么没有问题。如果大家希望创建一个商用的大型项目，那么个人还是推荐更加成熟的 webpack 方案。\n而我们当前的项目旨在构建一个 后台前端解决方案系统，所以我们这里依然选择了 webpack ，而不是 vite。\n05：全新的提案语法：script setup如果大家使用过 早期的 composition API ，那么应该会对 setup 函数 感触颇深，它的语法是反人类的。\n所以在  vue3 正式发布 40天 之后， 也就是 2020年10月28日 （vue3 正式发布日期为 2020年9月18日）提出了新的 script  setup 提案，该提案的目的只有一个：那就是让大家可以更爽的使用 composition API 语法！\n该提案在 2021年8月9日 正式定稿，并伴随着最新的 vue3 版本进行了发布，这也是为什么前面我们需要升级到最新的 vue 版本的原因。\n下面两张截图为对比 原setup函数  与   script setup：\n\n原 setup函数\nscript setup\n\n从截图中可以看出 script setup 语法更加符合我们开发者书写 JS 代码的习惯，它让我们书写 vue 就像再写普通的 js 一样。\n所以以后的 composition API 将是 script setup 语法的时代，原setup函数 将会逐渐退出历史舞台。\n而我们的项目也将会全部使用最新的 script setup 语法，让大家紧抓时代脉搏！\n06：导入 element-plus在开发我们的项目之前，我们需要先去导入 element-ui 的 vue3 支持版本，也就是 element-plus\nelement-plus 提供了快捷导入的方式，即：vue-cli-plugin-element-plus，大家可以通过以下方式来快捷导入 element-plus （注意：此种方式会自动修改 App.vue 文件）：\n\n在通过 vue-cli 创建的项目中，执行 \nvue add element-plus\n\n选择全局导入\n\n\n暂不生成覆盖变量的 scss 文件\n\n\n选择简体中文即可\n\n\n出现该提示表示安装完成\n\n\n此时运行项目，则会得到如下错误\n\n\n出现该错误的原因是因为 vue-cli-plugin-element-plus 默认修改了 APP.vue 文件，导入了 HelloWorld\n\n所以我们需要到 APP.vue 中，初始化如下代码：\n&lt;template&gt;\n  &lt;router-view &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;&lt;&#x2F;style&gt;\n\n\n那么至此，element-plus 导入成功，下一小节我们就正式开始项目的开发工作吧！\n07：构建登录页面 UI 结构\n在 views 中 login 文件夹，创建 index.vue 文件\n\n\n在 router/index.js 中增加以下路由配置\n&#x2F;**\n * 公开路由表\n *&#x2F;\nconst publicRoutes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;login&#39;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;login&#x2F;index&#39;)\n  &#125;\n]\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHashHistory(),\n  routes: publicRoutes\n&#125;)\n\n在 login/index.vue 中，生成基本页面结构\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;\n\n创建登录页面基本结构\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    &lt;el-form class&#x3D;&quot;login-form&quot; &gt;\n      &lt;div class&#x3D;&quot;title-container&quot;&gt;\n        &lt;h3 class&#x3D;&quot;title&quot;&gt;用户登录&lt;&#x2F;h3&gt;\n      &lt;&#x2F;div&gt;\n\n      &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;\n        &lt;span class&#x3D;&quot;svg-container&quot;&gt;\n          &lt;el-icon&gt;\n            &lt;avatar &#x2F;&gt;\n          &lt;&#x2F;el-icon&gt;\n        &lt;&#x2F;span&gt;\n        &lt;el-input\n          placeholder&#x3D;&quot;username&quot;\n          name&#x3D;&quot;username&quot;\n          type&#x3D;&quot;text&quot;\n        &#x2F;&gt;\n      &lt;&#x2F;el-form-item&gt;\n\n      &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;\n        &lt;span class&#x3D;&quot;svg-container&quot;&gt;\n          &lt;el-icon&gt;\n            &lt;avatar &#x2F;&gt;\n          &lt;&#x2F;el-icon&gt;\n        &lt;&#x2F;span&gt;\n        &lt;el-input\n          placeholder&#x3D;&quot;password&quot;\n          name&#x3D;&quot;password&quot;\n        &#x2F;&gt;\n        &lt;span class&#x3D;&quot;show-pwd&quot;&gt;\n          &lt;el-icon&gt;\n            &lt;avatar &#x2F;&gt;\n          &lt;&#x2F;el-icon&gt;\n        &lt;&#x2F;span&gt;\n      &lt;&#x2F;el-form-item&gt;\n\n      &lt;el-button type&#x3D;&quot;primary&quot; style&#x3D;&quot;width: 100%; margin-bottom: 30px&quot;\n        &gt;登录&lt;&#x2F;el-button\n      &gt;\n    &lt;&#x2F;el-form&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\n&#x2F;&#x2F; 导入组件之后无需注册可直接使用\nimport &#123; Avatar &#125; from &#39;@element-plus&#x2F;icons&#39;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n08：美化登录页面样式\n创建全局的 style \n\n在 src 下创建 styles/index.scss 文件，并写入以下内容：\nhtml,\nbody &#123;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB,\n    Microsoft YaHei, Arial, sans-serif;\n&#125;\n\n#app &#123;\n  height: 100%;\n&#125;\n\n*,\n*:before,\n*:after &#123;\n  box-sizing: inherit;\n  margin: 0;\n  padding: 0;\n&#125;\n\na:focus,\na:active &#123;\n  outline: none;\n&#125;\n\na,\na:focus,\na:hover &#123;\n  cursor: pointer;\n  color: inherit;\n  text-decoration: none;\n&#125;\n\ndiv:focus &#123;\n  outline: none;\n&#125;\n\n.clearfix &#123;\n  &amp;:after &#123;\n    visibility: hidden;\n    display: block;\n    font-size: 0;\n    content: &#39; &#39;;\n    clear: both;\n    height: 0;\n  &#125;\n&#125;\n\n\n在 main.js 中导入全局样式\n...\n&#x2F;&#x2F; 导入全局样式\nimport &#39;.&#x2F;styles&#x2F;index.scss&#39;\n...\n\n\n\n在 views/login/index.vue 中写入以下样式\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n$bg: #2d3a4b;\n$dark_gray: #889aa4;\n$light_gray: #eee;\n$cursor: #fff;\n\n.login-container &#123;\n  min-height: 100%;\n  width: 100%;\n  background-color: $bg;\n  overflow: hidden;\n\n  .login-form &#123;\n    position: relative;\n    width: 520px;\n    max-width: 100%;\n    padding: 160px 35px 0;\n    margin: 0 auto;\n    overflow: hidden;\n\n    ::v-deep .el-form-item &#123;\n      border: 1px solid rgba(255, 255, 255, 0.1);\n      background: rgba(0, 0, 0, 0.1);\n      border-radius: 5px;\n      color: #454545;\n    &#125;\n\n    ::v-deep .el-input &#123;\n      display: inline-block;\n      height: 47px;\n      width: 85%;\n\n      input &#123;\n        background: transparent;\n        border: 0px;\n        -webkit-appearance: none;\n        border-radius: 0px;\n        padding: 12px 5px 12px 15px;\n        color: $light_gray;\n        height: 47px;\n        caret-color: $cursor;\n      &#125;\n    &#125;\n  &#125;\n\n\n  .svg-container &#123;\n    padding: 6px 5px 6px 15px;\n    color: $dark_gray;\n    vertical-align: middle;\n    display: inline-block;\n  &#125;\n\n  .title-container &#123;\n    position: relative;\n\n    .title &#123;\n      font-size: 26px;\n      color: $light_gray;\n      margin: 0px auto 40px auto;\n      text-align: center;\n      font-weight: bold;\n    &#125;\n  &#125;\n\n  .show-pwd &#123;\n    position: absolute;\n    right: 10px;\n    top: 7px;\n    font-size: 16px;\n    color: $dark_gray;\n    cursor: pointer;\n    user-select: none;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n\n09：Icon 图标处理方案：SvgIcon在上一小节中我们完成了登陆页面的基本样式 。但是现在在登录页面中，还存在着最后一个样式问题，那就是 icon 图标。\n在我们的项目中所使用的 icon 图标，一共分为两类：\n\nelement-plus 的图标\n自定义的 svg 图标\n\n这也是通常情况下企业级项目开发时，所遇到的一种常见情况。\n对于 element-plus 的图标我们可以直接通过 el-icon 来进行显示，但是自定义图标的话，我们暂时还缺少显示的方式，所以说我们需要一个自定义的组件，来显示我们自定义的 svg 图标。\n那么这种自定义组件处理 自定义 svg 图标的形式，就是我们在面临这种问题时的通用解决方案。\n那么对于这个组件的话，它就需要拥有两种能力：\n\n显示外部 svg 图标\n显示项目内的 svg 图标\n\n基于以上概念，我们可以创建出以下对应代码：\n创建 components/SvgIcon/index.vue：\n&lt;template&gt;\n  &lt;div\n    v-if&#x3D;&quot;isExternal&quot;\n    :style&#x3D;&quot;styleExternalIcon&quot;\n    class&#x3D;&quot;svg-external-icon svg-icon&quot;\n    :class&#x3D;&quot;className&quot;\n  &#x2F;&gt;\n  &lt;svg v-else class&#x3D;&quot;svg-icon&quot; :class&#x3D;&quot;className&quot; aria-hidden&#x3D;&quot;true&quot;&gt;\n    &lt;use :xlink:href&#x3D;&quot;iconName&quot; &#x2F;&gt;\n  &lt;&#x2F;svg&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; isExternal as external &#125; from &#39;@&#x2F;utils&#x2F;validate&#39;\nimport &#123; defineProps, computed &#125; from &#39;vue&#39;\nconst props &#x3D; defineProps(&#123;\n  &#x2F;&#x2F; icon 图标\n  icon: &#123;\n    type: String,\n    required: true\n  &#125;,\n  &#x2F;&#x2F; 图标类名\n  className: &#123;\n    type: String,\n    default: &#39;&#39;\n  &#125;\n&#125;)\n\n&#x2F;**\n * 判断是否为外部图标\n *&#x2F;\nconst isExternal &#x3D; computed(() &#x3D;&gt; external(props.icon))\n&#x2F;**\n * 外部图标样式\n *&#x2F;\nconst styleExternalIcon &#x3D; computed(() &#x3D;&gt; (&#123;\n  mask: &#96;url($&#123;props.icon&#125;) no-repeat 50% 50%&#96;,\n  &#39;-webkit-mask&#39;: &#96;url($&#123;props.icon&#125;) no-repeat 50% 50%&#96;\n&#125;))\n&#x2F;**\n * 项目内图标\n *&#x2F;\nconst iconName &#x3D; computed(() &#x3D;&gt; &#96;#icon-$&#123;props.icon&#125;&#96;)\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n.svg-icon &#123;\n  width: 1em;\n  height: 1em;\n  vertical-align: -0.15em;\n  fill: currentColor;\n  overflow: hidden;\n&#125;\n\n.svg-external-icon &#123;\n  background-color: currentColor;\n  mask-size: cover !important;\n  display: inline-block;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n创建 utils/validate.js：\n\n&#x2F;**\n * 判断是否为外部资源\n *&#x2F;\nexport function isExternal(path) &#123;\n  return &#x2F;^(https?:|mailto:|tel:)&#x2F;.test(path)\n&#125;\n\n\n在 views/login/index.vue 中使用 外部 svg （https://res.lgdsunday.club/user.svg）：\n&lt;span class&#x3D;&quot;svg-container&quot;&gt;\n\t&lt;svg-icon icon&#x3D;&quot;https:&#x2F;&#x2F;res.lgdsunday.club&#x2F;user.svg&quot;&gt;&lt;&#x2F;svg-icon&gt;\n&lt;&#x2F;span&gt;\n\n外部图标可正常展示。\n那么在本小节中，我们创建了 SvgIcon 组件，用来处理了 外部图标 的展示，但是对于内部图标而言，我们此时依然无法进行展示。所以在下一小节中，我们就需要看一下，如何处理内部的 svg 图标。\n10：处理内部 svg 图标显示在上一章中，我们创建了 SvgIcon 组件用于显示 非 Element-ui 的图标。但是目前我们只处理了 外部 svg 的图标展示，内部的图标还无法展示。\n所以这一小节，我们就需要处理 内部的 svg 图标展示。\n\n首先导入所有的 svg 图标（大家可以从 讲师源代码 -&gt; src -&gt; icons -&gt; svg 处，获取所有 svg 图标），导入到 src -&gt; icons -&gt; svg 处\n\n在 icons 下创建 index.js 文件，该文件中需要完成两件事情：\n\n导入所有的 svg 图标\n完成 SvgIcon 的全局注册\n\n\n得出以下代码：\nimport SvgIcon from &#39;@&#x2F;components&#x2F;SvgIcon&#39;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;webpack.docschina.org&#x2F;guides&#x2F;dependency-management&#x2F;#requirecontext\n&#x2F;&#x2F; 通过 require.context() 函数来创建自己的 context\nconst svgRequire &#x3D; require.context(&#39;.&#x2F;svg&#39;, false, &#x2F;\\.svg$&#x2F;)\n&#x2F;&#x2F; 此时返回一个 require 的函数，可以接受一个 request 的参数，用于 require 的导入。\n&#x2F;&#x2F; 该函数提供了三个属性，可以通过 require.keys() 获取到所有的 svg 图标\n&#x2F;&#x2F; 遍历图标，把图标作为 request 传入到 require 导入函数中，完成本地 svg 图标的导入\nsvgRequire.keys().forEach(svgIcon &#x3D;&gt; svgRequire(svgIcon))\n\nexport default app &#x3D;&gt; &#123;\n  app.component(&#39;svg-icon&#39;, SvgIcon)\n&#125;\n\n\n在 main.js 中引入该文件\n...\n&#x2F;&#x2F; 导入 svgIcon\nimport installIcons from &#39;@&#x2F;icons&#39;\n...\ninstallIcons(app)\n...\n\n\n删除 views/login 下 局部导入 SvgIcon 的代码\n\n在 login/index.vue 中使用 SvgIcon 引入本地 svg\n&#x2F;&#x2F; 用户名   \n   &lt;svg-icon icon&#x3D;&quot;user&quot; &#x2F;&gt;\n   &#x2F;&#x2F; 密码\n   &lt;svg-icon icon&#x3D;&quot;password&quot; &#x2F;&gt;\n   &#x2F;&#x2F; 眼睛\n&lt;svg-icon icon&#x3D;&quot;eye&quot; &#x2F;&gt;\n\n此时 处理内容 svg 图标的代码 已经完成\n\n\n打开浏览器，我们发现 图标依然无法展示！ 这又是因为什么原因呢？\n来看下一节 《使用 svg-sprite-loader 处理 svg 图标》\n11：使用 svg-sprite-loader 处理 svg 图标svg-sprite-loader 是 webpack 中专门用来处理 svg 图标的一个 loader ，在上一节中我们的图标之所有没有展示，就是因为我们缺少该 loader。\n那么想要使用该 loader 我们需要做两件事情：\n\n下载该 laoder，执行：npm i --save-dev svg-sprite-loader@6.0.9\n\n创建 vue.config.js 文件，新增如下配置：\nconst path &#x3D; require(&#39;path&#39;)\nfunction resolve(dir) &#123;\n  return path.join(__dirname, dir)\n&#125;\n&#x2F;&#x2F; https:&#x2F;&#x2F;cli.vuejs.org&#x2F;zh&#x2F;guide&#x2F;webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F\nmodule.exports &#x3D; &#123;\n  chainWebpack(config) &#123;\n    &#x2F;&#x2F; 设置 svg-sprite-loader\n    config.module\n      .rule(&#39;svg&#39;)\n      .exclude.add(resolve(&#39;src&#x2F;icons&#39;))\n      .end()\n    config.module\n      .rule(&#39;icons&#39;)\n      .test(&#x2F;\\.svg$&#x2F;)\n      .include.add(resolve(&#39;src&#x2F;icons&#39;))\n      .end()\n      .use(&#39;svg-sprite-loader&#39;)\n      .loader(&#39;svg-sprite-loader&#39;)\n      .options(&#123;\n        symbolId: &#39;icon-[name]&#39;\n      &#125;)\n      .end()\n  &#125;\n&#125;\n\n\n处理完以上配置之后，重新启动项目，图标即可显示！\n12：Vue3.2 响应式优化对应用层的改变在处理好了 SvgIcon 图标之后，接下来我们就需要处理登陆页面的逻辑问题了。不过在处理这个逻辑之前，我们需要先来明确一点 vue3 新的更新内容。\n如果大家之前有过了解 Vue3 代码的话，那么会知道 Vue3 中声明响应式数据的方式有两种：\n\nref\nreactive\n\n对于这两种使用方式而言，它们在应用层上并没有明确的界限，也就是说我们可能很难仅通过官网的介绍来判断我应该在什么情况下使用什么。\n但是这种情况在现在已经不存在了。\n2020年10月29日，社区大佬 basvanmeurs 提出了一个新的 PR，大概的意思是说：他重构了响应式的部分内容，大大增加了性能。\n详细的介绍如下：\n\n\n\n\n\n\n\n\n\n\nBig runtime performance improvement for ref, computed, watch and watchEffect (30%-80% depending on the amount of dependencies)\nMemory usage decreased by about 30% when creating ref, computed, watch and watchEffect\nCreation time performance improvement, most notably for watchers and watchEffects\n\n\nref、calculated、watch 和 watchEffect 的运行时性能大幅提升（30%-80% 取决于依赖项的数量）创建 ref、calculated、watch 和 watchEffect 时内存使用量减少了约 30%创建时间性能改进，最显著的是 watchers 和 watchEffects\n这是一个非常强大的变化，同时又因为这个变化过于庞大，所以一直等待到 2021年8月5日 伴随着  vue 3.2发布，尤大才合并对应的代码，并在这次变化中对该性能改进进行了如下的介绍：\n\n\n\n\n\n\n\n\n\n\nMore efficient ref implementation (~260% faster read &#x2F; ~50% faster write)\n~40% faster dependency tracking\n~17% less memory usage\n\n\n更高效的 ref 实现（约 260% 的读取速度&#x2F;约 50% 的写入速度）依赖项跟踪速度提高约 40%内存使用量减少约 17%\n毫无疑问，这绝对是一个伟大的变化。\n那么针对于这个变化，在应用层中最大的体现就是 ref 这个 API ，性能得到了大幅度的提升。\n所以说，拥抱新的变化吧！\n在之后能使用 ref 的地方就使用 ref 吧。毕竟现在它的性能得到了大幅的提升！\n那么在咱们之后的代码中，我们同样也会全部使用 ref 来作为响应式数据构建的方式，无论是 基本数据类型 或者是 复杂数据类型， 毕竟这样做本身并没有什么问题，对不对？\n13：完善登录表单校验表单校验是表单使用的一个通用能力，在 element-plus 中想要为表单进行表单校验那么我们需要关注以下三点：\n\n为 el-form 绑定 model 属性\n为 el-form 绑定 rules 属性\n为 el-form-item 绑定 prop 属性\n\n保证以上三点即可为 el-from 添加表单校验功能。\n因为这一块是比较简单的功能，只要有过 element-ui 使用经验的人，应该对这里都不陌生，所以这里就不对这块内容进行过多赘述了。对这里不是很了解的人可以参考下 element-plus 中 from 表单部分\n以下为对应的代码实现：\nviews&#x2F;login\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    &lt;el-form class&#x3D;&quot;login-form&quot; :model&#x3D;&quot;loginForm&quot; :rules&#x3D;&quot;loginRules&quot;&gt;\n      ...\n      &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;\n        ...\n        &lt;el-input\n         ...\n          v-model&#x3D;&quot;loginForm.username&quot;\n        &#x2F;&gt;\n      &lt;&#x2F;el-form-item&gt;\n\n      &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;\n        ...\n        &lt;el-input\n          ...\n          v-model&#x3D;&quot;loginForm.password&quot;\n        &#x2F;&gt;\n        ...\n      &lt;&#x2F;el-form-item&gt;\n\t\t...\n    &lt;&#x2F;el-form&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nimport &#123; validatePassword &#125; from &#39;.&#x2F;rules&#39;\n\n&#x2F;&#x2F; 数据源\nconst loginForm &#x3D; ref(&#123;\n  username: &#39;super-admin&#39;,\n  password: &#39;123456&#39;\n&#125;)\n&#x2F;&#x2F; 验证规则\nconst loginRules &#x3D; ref(&#123;\n  username: [\n    &#123;\n      required: true,\n      trigger: &#39;blur&#39;,\n      message: &#39;用户名为必填项&#39;\n    &#125;\n  ],\n  password: [\n    &#123;\n      required: true,\n      trigger: &#39;blur&#39;,\n      validator: validatePassword()\n    &#125;\n  ]\n&#125;)\n&lt;&#x2F;script&gt;\n\n\nviews&#x2F;login&#x2F;rules.js\nexport const validatePassword &#x3D; () &#x3D;&gt; &#123;\n  return (rule, value, callback) &#x3D;&gt; &#123;\n    if (value.length &lt; 6) &#123;\n      callback(new Error(&#39;密码不能少于6位&#39;))\n    &#125; else &#123;\n      callback()\n    &#125;\n  &#125;\n&#125;\n\n14：密码框状态通用处理对于密码框存在两种状态：\n\n密文状态\n明文状态\n\n点击 眼睛 可以进行切换。\n该功能实现为通用的处理方案，只需要动态修改 input 的 type 类型即可，其中：\n\npassword 为密文显示\ntext 为明文显示\n\n根据以上理论，即可得出以下代码：\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    &lt;el-form class&#x3D;&quot;login-form&quot; :model&#x3D;&quot;loginForm&quot; :rules&#x3D;&quot;loginRules&quot;&gt;\n      ...\n        &lt;el-input\n          ...\n          :type&#x3D;&quot;passwordType&quot;\n        &#x2F;&gt;\n        &lt;span class&#x3D;&quot;show-pwd&quot;&gt;\n          &lt;svg-icon\n            :icon&#x3D;&quot;passwordType &#x3D;&#x3D;&#x3D; &#39;password&#39; ? &#39;eye&#39; : &#39;eye-open&#39;&quot;\n            @click&#x3D;&quot;onChangePwdType&quot;\n          &#x2F;&gt;\n        &lt;&#x2F;span&gt;\n      ...\n    &lt;&#x2F;el-form&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\n...\n\n&#x2F;&#x2F; 处理密码框文本显示状态\nconst passwordType &#x3D; ref(&#39;password&#39;)\nconst onChangePwdType &#x3D; () &#x3D;&gt; &#123;\n  if (passwordType.value &#x3D;&#x3D;&#x3D; &#39;password&#39;) &#123;\n    passwordType.value &#x3D; &#39;text&#39;\n  &#125; else &#123;\n    passwordType.value &#x3D; &#39;password&#39;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n15：通用后台登录方案解析处理完了表单的基本操作之后，接下来就是登录操作的实现了。\n对于登录操作在后台项目中是一个通用的解决方案，具体可以分为以下几点：\n\n封装 axios 模块\n封装 接口请求 模块\n封装登录请求动作\n保存服务端返回的 token\n登录鉴权\n\n这些内容就共同的组成了一套 后台登录解决方案 。那么在后面的章节中，我们就分别来去处理这些内容。\n16：配置环境变量封装 axios 模块首先我们先去完成第一步：封装 axios 模块。\n在当前这个场景下，我们希望封装出来的 axios 模块，至少需要具备一种能力，那就是：根据当前模式的不同，设定不同的 BaseUrl ，因为通常情况下企业级项目在 开发状态 和 生产状态 下它的 baseUrl 是不同的。\n对于 @vue/cli 来说，它具备三种不同的模式：\n\ndevelopment\ntest\nproduction\n\n具体可以点击 这里 进行参考。\n根据我们前面所提到的 开发状态和生产状态 那么此时我们的 axios 必须要满足：在 开发 || 生产 状态下，可以设定不同 BaseUrl 的能力\n那么想要解决这个问题，就必须要使用到 @vue/cli 所提供的 环境变量 来去进行实现。\n我们可以在项目中创建两个文件：\n\n.env.development\n.env.production\n\n它们分别对应 开发状态 和 生产状态。\n我们可以在上面两个文件中分别写入以下代码：\n**.env.development**：\n# 标志\nENV &#x3D; &#39;development&#39;\n\n# base api\nVUE_APP_BASE_API &#x3D; &#39;&#x2F;api&#39;\n\n.env.production：\n# 标志\nENV &#x3D; &#39;production&#39;\n\n# base api\nVUE_APP_BASE_API &#x3D; &#39;&#x2F;prod-api&#39;\n\n有了这两个文件之后，我们就可以创建对应的 axios 模块\n创建 utils/request.js ，写入如下代码：\nimport axios from &#39;axios&#39;\n\nconst service &#x3D; axios.create(&#123;\n  baseURL: process.env.VUE_APP_BASE_API,\n  timeout: 5000\n&#125;)\n\nexport default service\n\n17：封装请求动作有了 axios 模块之后，接下来我们就可以\n\n封装接口请求模块\n封装登录请求动作\n\n封装接口请求模块：\n创建 api 文件夹，创建 sys.js：\nimport request from &#39;@&#x2F;utils&#x2F;request&#39;\n\n&#x2F;**\n * 登录\n *&#x2F;\nexport const login &#x3D; data &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;sys&#x2F;login&#39;,\n    method: &#39;POST&#39;,\n    data\n  &#125;)\n&#125;\n\n封装登录请求动作：\n该动作我们期望把它封装到 vuex 的 action 中\n在 store 下创建 modules 文件夹，创建 user.js 模块，用于处理所有和 用户相关 的内容（此处需要使用第三方包 md5 ）：\nimport &#123; login &#125; from &#39;@&#x2F;api&#x2F;sys&#39;\nimport md5 from &#39;md5&#39;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;&#125;),\n  mutations: &#123;&#125;,\n  actions: &#123;\n    login(context, userInfo) &#123;\n      const &#123; username, password &#125; &#x3D; userInfo\n      return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        login(&#123;\n          username,\n          password: md5(password)\n        &#125;)\n          .then(data &#x3D;&gt; &#123;\n            resolve()\n          &#125;)\n          .catch(err &#x3D;&gt; &#123;\n            reject(err)\n          &#125;)\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n\n在 store/index 中完成注册：\nimport &#123; createStore &#125; from &#39;vuex&#39;\nimport user from &#39;.&#x2F;modules&#x2F;user.js&#39;\nexport default createStore(&#123;\n  modules: &#123;\n    user\n  &#125;\n&#125;)\n\n\n\n18：登录触发动作在 login 中，触发定义的 action\n&lt;template&gt;\n\t&lt;el-button\n        type&#x3D;&quot;primary&quot;\n        style&#x3D;&quot;width: 100%; margin-bottom: 30px&quot;\n        :loading&#x3D;&quot;loading&quot;\n        @click&#x3D;&quot;handleLogin&quot;\n        &gt;登录&lt;&#x2F;el-button\n      &gt;\n&lt;&#x2F;template&gt;\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nimport &#123; validatePassword &#125; from &#39;.&#x2F;rules&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\n...\n\n&#x2F;&#x2F; 登录动作处理\nconst loading &#x3D; ref(false)\nconst loginFromRef &#x3D; ref(null)\nconst store &#x3D; useStore()\nconst handleLogin &#x3D; () &#x3D;&gt; &#123;\n  loginFromRef.value.validate(valid &#x3D;&gt; &#123;\n    if (!valid) return\n\n    loading.value &#x3D; true\n    store\n      .dispatch(&#39;user&#x2F;login&#39;, loginForm.value)\n      .then(() &#x3D;&gt; &#123;\n        loading.value &#x3D; false\n        &#x2F;&#x2F; TODO: 登录后操作\n      &#125;)\n      .catch(err &#x3D;&gt; &#123;\n        console.log(err)\n        loading.value &#x3D; false\n      &#125;)\n  &#125;)\n&#125;\n&lt;&#x2F;script&gt;\n\n触发之后会得到以下错误：\n\n\n该错误表示，我们当前请求的接口不存在。\n出现这个问题的原因，是因为我们在前面配置环境变量时指定了 开发环境下，请求的 BaseUrl 为 /api ，所以我们真实发出的请求为：/api/sys/login 。\n这样的一个请求会被自动键入到当前前端所在的服务中，所以我们最终就得到了 http://192.168.18.42:8081/api/sys/login 这样的一个请求路径。\n而想要处理这个问题，那么可以通过指定 webpack DevServer 代理 的形式，代理当前的 url 请求。\n而指定这个代理非常简单，是一种近乎固定的配置方案。\n在 vue.config.js 中，加入以下代码：\nmodule.exports &#x3D; &#123;\n  devServer: &#123;\n    &#x2F;&#x2F; 配置反向代理\n    proxy: &#123;\n      &#x2F;&#x2F; 当地址中有&#x2F;api的时候会触发代理机制\n      &#39;&#x2F;api&#39;: &#123;\n        &#x2F;&#x2F; 要代理的服务器地址  这里不用写 api\n        target: &#39;https:&#x2F;&#x2F;api.imooc-admin.lgdsunday.club&#x2F;&#39;,\n        changeOrigin: true &#x2F;&#x2F; 是否跨域\n      &#125;\n    &#125;\n  &#125;,\n  ...\n&#125;\n\n\n重新启动服务，再次进行请求，即可得到返回数据\n\n\n\n\n19：本地缓存处理方案通常情况下，在获取到 token 之后，我们会把 token 进行缓存，而缓存的方式将会分为两种：\n\n本地缓存：LocalStorage \n全局状态管理：Vuex\n\n保存在 LocalStorage 是为了方便实现 自动登录功能\n保存在 vuex 中是为了后面在其他位置进行使用\n那么下面我们就分别来实现对应的缓存方案：\nLocalStorage：\n\n创建 utils/storage.js 文件，封装三个对应方法：\n&#x2F;**\n * 存储数据\n *&#x2F;\nexport const setItem &#x3D; (key, value) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 将数组、对象类型的数据转化为 JSON 字符串进行存储\n  if (typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n    value &#x3D; JSON.stringify(value)\n  &#125;\n  window.localStorage.setItem(key, value)\n&#125;\n\n&#x2F;**\n * 获取数据\n *&#x2F;\nexport const getItem &#x3D; key &#x3D;&gt; &#123;\n  const data &#x3D; window.localStorage.getItem(key)\n  try &#123;\n    return JSON.parse(data)\n  &#125; catch (err) &#123;\n    return data\n  &#125;\n&#125;\n\n&#x2F;**\n * 删除数据\n *&#x2F;\nexport const removeItem &#x3D; key &#x3D;&gt; &#123;\n  window.localStorage.removeItem(key)\n&#125;\n\n&#x2F;**\n * 删除所有数据\n *&#x2F;\nexport const removeAllItem &#x3D; key &#x3D;&gt; &#123;\n  window.localStorage.clear()\n&#125;\n\n在 vuex 的 user 模块下，处理 token 的保存\nimport &#123; login &#125; from &#39;@&#x2F;api&#x2F;sys&#39;\nimport md5 from &#39;md5&#39;\nimport &#123; setItem, getItem &#125; from &#39;@&#x2F;utils&#x2F;storage&#39;\nimport &#123; TOKEN &#125; from &#39;@&#x2F;constant&#39;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;\n    token: getItem(TOKEN) || &#39;&#39;\n  &#125;),\n  mutations: &#123;\n    setToken(state, token) &#123;\n      state.token &#x3D; token\n      setItem(TOKEN, token)\n    &#125;\n  &#125;,\n  actions: &#123;\n    login(context, userInfo) &#123;\n      ...\n          .then(data &#x3D;&gt; &#123;\n            this.commit(&#39;user&#x2F;setToken&#39;, data.data.data.token)\n            resolve()\n          &#125;)\n          ...\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n\n\n处理保存的过程中，需要创建 constant 常量目录 constant/index.js\nexport const TOKEN &#x3D; &#39;token&#39;\n\n此时，当点击登陆时，即可把 token 保存至 vuex 与  localStorage 中\n20：响应数据的统一处理在上一小节中，我们保存了服务端返回的 token 。但是有一个地方比较难受，那就是在 vuex 的 user 模块 中，我们获取数据端的 token 数据，通过 data.data.data.token 的形式进行获取。\n一路的 data. 确实让人比较难受，如果有过 axios 拦截器处理经验的人应该知道，对于这种问题，我们可以通过 axios 响应拦截器 进行处理。\n在 utils/request.js 中实现以下代码：\nimport axios from &#39;axios&#39;\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\n\n...\n&#x2F;&#x2F; 响应拦截器\nservice.interceptors.response.use(\n  response &#x3D;&gt; &#123;\n    const &#123; success, message, data &#125; &#x3D; response.data\n    &#x2F;&#x2F;   要根据success的成功与否决定下面的操作\n    if (success) &#123;\n      return data\n    &#125; else &#123;\n      &#x2F;&#x2F; 业务错误\n      ElMessage.error(message) &#x2F;&#x2F; 提示错误消息\n      return Promise.reject(new Error(message))\n    &#125;\n  &#125;,\n  error &#x3D;&gt; &#123;\n    &#x2F;&#x2F; TODO: 将来处理 token 超时问题\n    ElMessage.error(error.message) &#x2F;&#x2F; 提示错误信息\n    return Promise.reject(error)\n  &#125;\n)\n\nexport default service\n\n\n此时，对于 vuex 中的 user 模块 就可以进行以下修改了：\nthis.commit(&#39;user&#x2F;setToken&#39;, data.token)\n\n21：登录后操作那么截止到此时，我们距离登录操作还差最后一个功能就是 登录鉴权 。\n只不过在进行 登录鉴权 之前我们得先去创建一个登录后的页面，也就是我们所说的登录后操作。\n\n创建 layout/index.vue ，写入以下代码：\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;Layout 页面&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;\n\n\n在 router/index 中，指定对应路由表：\nconst publicRoutes &#x3D; [\n ...\n  &#123;\n    path: &#39;&#x2F;&#39;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;layout&#x2F;index&#39;)\n  &#125;\n]\n\n在登录成功后，完成跳转\n&#x2F;&#x2F; 登录后操作\nrouter.push(&#39;&#x2F;&#39;)\n\n22：登录鉴权解决方案在处理了登陆后操作之后，接下来我们就来看一下最后的一个功能，也就是 登录鉴权\n首先我们先去对 登录鉴权 进行一个定义，什么是  登录鉴权 呢？\n\n\n\n\n\n\n\n\n\n当用户未登陆时，不允许进入除 login 之外的其他页面。\n用户登录后，token 未过期之前，不允许进入 login 页面\n而想要实现这个功能，那么最好的方式就是通过 路由守卫 来进行实现。\n那么明确好了 登录鉴权 的概念之后，接下来就可以去实现一下\n在 main.js 平级，创建 permission 文件\nimport router from &#39;.&#x2F;router&#39;\nimport store from &#39;.&#x2F;store&#39;\n\n&#x2F;&#x2F; 白名单\nconst whiteList &#x3D; [&#39;&#x2F;login&#39;]\n&#x2F;**\n * 路由前置守卫\n *&#x2F;\nrouter.beforeEach(async (to, from, next) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 存在 token ，进入主页\n  &#x2F;&#x2F; if (store.state.user.token) &#123;\n  &#x2F;&#x2F; 快捷访问\n  if (store.getters.token) &#123;\n    if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n      next(&#39;&#x2F;&#39;)\n    &#125; else &#123;\n      next()\n    &#125;\n  &#125; else &#123;\n    &#x2F;&#x2F; 没有token的情况下，可以进入白名单\n    if (whiteList.indexOf(to.path) &gt; -1) &#123;\n      next()\n    &#125; else &#123;\n      next(&#39;&#x2F;login&#39;)\n    &#125;\n  &#125;\n&#125;)\n\n\n在此处我们使用到了 vuex 中的 getters ，此时的 getters 被当作 快捷访问 的形式进行访问\n所以我们需要声明对应的模块，创建 store/getters\nconst getters &#x3D; &#123;\n  token: state &#x3D;&gt; state.user.token\n&#125;\nexport default getters\n\n\n在 store/index 中进行导入：\nimport getters from &#39;.&#x2F;getters&#39;\nexport default createStore(&#123;\n  getters,\n  ...\n&#125;)\n\n\n23：总结那么到这里我们整个的第三章就算是全部讲解完成了。\n整个第三章讲解了两个大部分：\n\nvue3 的一些基本概念\nvue3 的新特性\n全新的 script setup 语法\n最新的 ref 优化\n\n\n登录方案相关的业务代码\nelement-plus 相关\nel-form 表单\n密码框状态处理\n\n\n后台登录解决方案\n封装 axios 模块\n封装 接口请求 模块\n封装登录请求动作\n保存服务端返回的 token\n登录鉴权\n\n\n\n\n\n那么从下一章开始，我们就会进入到项目内部业务的处理过程。在项目内部的业务处理中，我们又会遇到什么样的业务需求，以及提出什么样的对应解决方案呢？\n敬请期待吧！\n","slug":"vue3.2后台管理系统/03搭建登录架构","date":"2022-08-22T13:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"5b3c8e28480b900c4a5086ace466bf73","title":"02ESLint + Git Hooks","content":"02ESLint + Git Hooks01：为什么需要编程规范？工欲善其事，必先利其器 \n对于一些大型的企业级项目而言，通常情况下我们都是需要一个团队来进行开发的。而又因为团队人员对技术理解上的参差不齐，所以就会导致出现一种情况，那就是《一个项目无法具备统一的编程规范，导致项目的代码像多个不同材质的补丁拼接起来一样》\n设想一下，下面的这段代码有一个团队进行开发，因为没有具备统一的代码标准，所以生成了下面的代码：\n\n\n这段代码可以正常运行没有问题，但是整体的代码结构却非常的难看。\n\n\n\n\n\n\n\n\n\n有的地方有空格进行分割，有的地方却没有\n有的地方是单引号，有的地方却是双引号\n有的地方有分号，有的地方没有分号\n….\n这样的项目虽然可以正常运行，但是如果把它放到大厂的项目中，确实 不及格 的，它会被认为是 不可维护、不可扩展的代码内容\n那么所谓的大厂标准的代码结构应该是什么样子的呢？\n我们把上面的代码进行一下修正，做一个对比：\n\n\n修改之后的代码具备了统一的规范之后，是不是看起来就舒服多了！\n并且以上所列举出来的只是《编程规范》中的一小部分内容！\n那么有些人可能就会说了，你列举出来这些编程规范有什么用啊！\n哪怕你写上一部书，我们一个团队这么多人，总不能指望所有人都看一遍，并且严格的遵守你所说的规范吧！\n说的没错！指望人主动的遵守这些规范不太现实\n那怎么办呢？\n那么我们可不可以另辟蹊径，让程序自动处理规范化的内容呢？\n答案是：可以的！\n这些也是我们本章节所需要讲解的重点内容！\n本章节中我们会为大家讲解，如何自动化的对代码进行规范，其中主要包括：\n\n编码规范\ngit 规范\n\n两大类\n那么明确好了我们的范围之后，接下来就让我们创建一个项目，开始我们的代码规范之旅吧！\n02：使用 vue-cli 创建项目这一小节我们需要创建一个 vue3 的项目，而创建项目的方式依然是通过 vue-cli 进行创建。\n不过这里有一点大家需要注意，因为我们需要使用最新的模板，所以请保证你的 vue-cli 的版本在 4.5.13 以上，你可以通过以下的方式来查看你的 vue-cli 版本：\nvue -V\n------\n@vue&#x2F;cli 4.5.13 &#x2F;&#x2F; 输出版本号\n\n如果你需要升级版本，那么可以通过以下指令进行升级：\nnpm update -g @vue&#x2F;cli\n\n具体的方式也可以点击 这里 进行参考。\n升级之后，即可通过以下方式创建最新的 vue3 项目，终端输入 vue create 项目名称 ，即可进入 模板选择\n&#x2F;&#x2F; 利用 vue-cli 创建项目\nvue create imooc-admin\n&#x2F;&#x2F; 进入模板选择\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint) \n&gt; Manually select features  &#x2F;&#x2F; 选择手动配置\n&#x2F;&#x2F; ----------------------------------------------------------\n? Check the features needed for your project: \n (*) Choose Vue version &#x2F;&#x2F; 选择 vue 版本\n (*) Babel &#x2F;&#x2F; 使用 babel\n ( ) TypeScript &#x2F;&#x2F; 不使用 ts\n ( ) Progressive Web App (PWA) Support &#x2F;&#x2F; 不使用 PWA\n (*) Router &#x2F;&#x2F; 添加 vue-router\n (*) Vuex &#x2F;&#x2F; 添加 vuex\n&gt;(*) CSS Pre-processors &#x2F;&#x2F; 使用 css 预处理器\n (*) Linter &#x2F; Formatter &#x2F;&#x2F; 代码格式化\n ( ) Unit Testing &#x2F;&#x2F; 不配置测试\n ( ) E2E Testing  &#x2F;&#x2F; &#x2F;&#x2F; 不配置测试\n&#x2F;&#x2F; ----------------------------------------------------------\n Choose a version of Vue.js that you want to start the project with \n  2.x\n&gt; 3.x &#x2F;&#x2F; 选择 vue 3.0 版本\n&#x2F;&#x2F; ----------------------------------------------------------\n Use history mode for router? (Requires proper server setup for index fallback in production) (Y&#x2F;n) n &#x2F;&#x2F; 不使用 history模式 的路由\n&#x2F;&#x2F; ----------------------------------------------------------\n ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): \n&gt; Sass&#x2F;SCSS (with dart-sass) &#x2F;&#x2F; 使用基于 dart-sass 的 scss 预处理器\n  Sass&#x2F;SCSS (with node-sass) \n  Less\n  Stylus\n&#x2F;&#x2F; ----------------------------------------------------------\n? Pick a linter &#x2F; formatter config: \n  ESLint with error prevention only \n  ESLint + Airbnb config\n&gt; ESLint + Standard config &#x2F;&#x2F; 使用 ESLint 标准代码格式化方案\n  ESLint + Prettier \n&#x2F;&#x2F; ----------------------------------------------------------\n? Pick additional lint features: \n (*) Lint on save &#x2F;&#x2F;  \n&gt;(*) Lint and fix on commit  &#x2F;&#x2F; 保存时 &amp;&amp; 提交时，都进行 lint\n&#x2F;&#x2F; ----------------------------------------------------------\n? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)\n&gt; In dedicated config files &#x2F;&#x2F; 单独的配置文件\n  In package.json\n&#x2F;&#x2F; ----------------------------------------------------------\n Save this as a preset for future projects? (y&#x2F;N) n &#x2F;&#x2F; 不存储预设\n\n等待片刻之后，你的项目就会生成成功。\n生成之后，可以通过以下两个指令来运行你的项目：\ncd 项目目录\nnpm run serve\n\n执行成功之后，项目即可运行！\n03：升级最新的 vue 版本以支持 script setup 语法因为使用 @vue/cli-v4.5.13 版本创建的项目中，vue 的版本为 v 3.0.0 。\n但是我们的项目需要使用最新的 script setup 语法，该语法在 v 3.0.0 版本中是不支持的，所以我们需要升级 vue 版本。\n大家可以通过以下指令进行升级：\n执行：\nnpm i vue@3.2.8 vue-router@4.0.11 vuex@4.0.2\n\n升级之后，查看 package.json 得到的版本应为：\n&quot;vue&quot;: &quot;^3.2.8&quot;,\n&quot;vue-router&quot;: &quot;^4.0.11&quot;,\n&quot;vuex&quot;: &quot;^4.0.2&quot;\n\n\n\n04：大厂编程规范一：代码检测工具 ESLint 你了解多少？在我们去创建项目的时候，脚手架工具已经帮助我们安装了 ESLint 代码检测工具。\n对于 ESLint 的大名，人们或多或少的应该都听说过，只不过有些人可能了解的多一些，有些人了解的少一些。\n那么本小节我们就先来聊一下，这个赫赫有名的代码检测工具 ESLint\n首先 ESLint 是 2013年6月 创建的一个开源项目，它的目标非常简单，只有一个，那就是 提供一个插件化的 javascript 代码检测工具 ，说白了就是做 代码格式检测使用的\n在咱们当前的项目中，包含一个 .eslintrc.js 文件，这个文件就是 eslint 的配置文件。\n随着大家对代码格式的规范性越来越重视，eslint 也逐渐被更多的人所接收，同时也有很多大厂在原有的 eslint 规则基础之上进行了一些延伸。\n我们在创建项目时，就进行过这样的选择：\n? Pick a linter &#x2F; formatter config: \n  ESLint with error prevention only &#x2F;&#x2F; 仅包含错误的 ESLint\n  ESLint + Airbnb config &#x2F;&#x2F; Airbnb 的 ESLint 延伸规则\n  ESLint + Standard config &#x2F;&#x2F; 标准的 ESLint 规则\n\n我们当前选择了 标准的 ESLint 规则 ，那么接下来我们就在该规则之下，看一看 ESLint 它的一些配置都有什么？\n打开项目中的 .eslintrc.js 文件\n&#x2F;&#x2F; ESLint 配置文件遵循 commonJS 的导出规则，所导出的对象就是 ESLint 的配置对象\n&#x2F;&#x2F; 文档：https:&#x2F;&#x2F;eslint.bootcss.com&#x2F;docs&#x2F;user-guide&#x2F;configuring\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 表示当前目录即为根目录，ESLint 规则将被限制到该目录下\n  root: true,\n  &#x2F;&#x2F; env 表示启用 ESLint 检测的环境\n  env: &#123;\n    &#x2F;&#x2F; 在 node 环境下启动 ESLint 检测\n    node: true\n  &#125;,\n  &#x2F;&#x2F; ESLint 中基础配置需要继承的配置\n  extends: [&quot;plugin:vue&#x2F;vue3-essential&quot;, &quot;@vue&#x2F;standard&quot;],\n  &#x2F;&#x2F; 解析器\n  parserOptions: &#123;\n    parser: &quot;babel-eslint&quot;\n  &#125;,\n  &#x2F;&#x2F; 需要修改的启用规则及其各自的错误级别\n  &#x2F;**\n   * 错误级别分为三种：\n   * &quot;off&quot; 或 0 - 关闭规则\n   * &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)\n   * &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)\n   *&#x2F;\n  rules: &#123;\n    &quot;no-console&quot;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,\n    &quot;no-debugger&quot;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;\n  &#125;\n&#125;;\n\n\n那么到这里咱们已经大致的了解了.eslintrc.js 文件，基于 ESLint 如果我们出现不符合规范的代码格式时，那么就会得到一个对应的错误。\n比如：\n\n\n\n\n\n\n\n\n\n我们可以把 Home.vue 中的 name 属性值，由单引号改为双引号\n此时，只要我们一保存代码，那么就会得到一个对应的错误\n\n\n这个错误表示： \n\n此时我们触发了一个 《错误级别的错误》 \n触发该错误的位置是 在 Home.vue 的第 13 行 第九列 中\n错误描述为：字符串必须使用单引号\n错误规则为：quotes\n\n那么想要解决这个错误，通常情况下我们有两种方式：\n\n按照 ESLint 的要求修改代码\n修改 ESLint 的验证规则\n\n按照 ESLint 的要求修改代码：\n\n\n\n\n\n\n\n\n\n 在 Home.vue 的第 13 行中把双引号改为单引号\n修改 ESLint 的验证规则：\n\n在 .eslintrc.js 文件中，新增一条验证规则\n&quot;quotes&quot;: &quot;error&quot; &#x2F;&#x2F; 默认\n&quot;quotes&quot;: &quot;warn&quot; &#x2F;&#x2F; 修改为警告\n&quot;quotes&quot;: &quot;off&quot; &#x2F;&#x2F; 修改不校验\n\n那么这一小节，我们了解了 vue-cli 创建 vue3 项目时，Standard config 的 ESLint 配置，并且知道了如何解决 ESLint 报错的问题。\n但是一个团队中，人员的水平高低不齐，大量的 ESLint 规则校验，会让很多的开发者头疼不已，从而大大影响了项目的开发进度。\n试想一下，在你去完成项目代码的同时，还需要时时刻刻注意代码的格式问题，这将是一件多么痛苦的事情！\n那么有没有什么办法，既可以保证 ESLint 规则校验，又可以解决严苛的格式规则导致的影响项目进度的问题呢？\n请看下一节。\n05：大厂编程规范二：你知道代码格式化 Prettier 吗？在上一小节中，我们知道了 ESLint 可以让我们的代码格式变得更加规范，但是同样的它也会带来开发时编码复杂度上升的问题。\n那么有没有办法既可以保证 ESLint 规则校验，又可以让开发者无需关注格式问题来进行顺畅的开发呢？\n答案是：有的！\n而解决这个问题的关键就是 prettier！（点击 这里 进入 prettier 中文官网！）\nprettier 是什么？\n\n一个代码格式化工具\n开箱即用\n可以直接集成到 VSCode 之中\n在保存时，让代码直接符合 ESLint 标准（需要通过一些简单配置）\n\n那么这些简单配置具体指的是什么呢？\n请看下一小节《ESLint 与 Prettier 配合解决代码格式问题》\n06：ESLint 与 Prettier 配合解决代码格式问题在上一小节中，我们提到《prettier 可以在保存代码时，让我们的代码直接符合 ESLint 标准》但是想要实现这样的功能需要进行一些配置。\n那么这一小节，我们就来去完成这个功能：\n\n在 VSCode 中安装 prettier 插件（搜索 prettier），这个插件可以帮助我们在配置 prettier 的时候获得提示\n\n\n在项目中新建 .prettierrc 文件，该文件为 perttier 默认配置文件\n\n在该文件中写入如下配置：\n&#123;\n  &#x2F;&#x2F; 不尾随分号\n  &quot;semi&quot;: false,\n  &#x2F;&#x2F; 使用单引号\n  &quot;singleQuote&quot;: true,\n  &#x2F;&#x2F; 多行逗号分割的语法中，最后一行不加逗号\n  &quot;trailingComma&quot;: &quot;none&quot;\n&#125;\n\n打开 VSCode 《设置面板》\n\n\n在设置中，搜索 save ，勾选 Format On Save\n\n\n至此，你即可在 VSCode 保存时，自动格式化代码！\n但是！ 你只做到这样还不够！\n\n\n\n\n\n\n\n\n\n\nVSCode 而言，默认一个 tab 等于 4 个空格，而 ESLint 希望一个 tab 为两个空格\n\n如果大家的 VSCode 安装了多个代码格式化工具的化\n\nESLint 和 prettier 之间的冲突问题\n\n\n我们尝试在 Home.vue 中写入一个 created 方法，写入完成之后，打开我们的控制台我们会发现，此时代码抛出了一个 ESLint 的错误\n\n\n这个错误的意思是说：**created 这个方法名和后面的小括号之间，应该有一个空格！**\n但是当我们加入了这个空格之后，只要一保存代码，就会发现 prettier 会自动帮助我们去除掉这个空格。\n那么此时的这个问题就是 prettier 和 ESLint 的冲突问题。\n针对于这个问题我们想要解决也非常简单：\n\n打开 .eslintrc.js 配置文件\n\n在 rules 规则下，新增一条规则\n&#39;space-before-function-paren&#39;: &#39;off&#39;\n\n该规则表示关闭《方法名后增加空格》的规则\n\n重启项目\n\n\n至此我们整个的 perttier 和 ESLint 的配合使用就算是全部完成了。\n在之后我们写代码的过程中，只需要保存代码，那么 perttier 就会帮助我们自动格式化代码，使其符合 ESLint 的校验规则。而无需我们手动进行更改了。\n07：大厂编程规范三：约定式提交规范在前面我们通过 prettier + ESLint 解决了代码格式的问题，但是我们之前也说过 编程规范 指的可不仅仅只是 代码格式规范 。\n除了 代码格式规范 之外，还有另外一个很重要的规范就是 git 提交规范！\n在现在的项目开发中，通常情况下，我们都会通过 git 来管理项目。只要通过 git 来管理项目，那么就必然会遇到使用 git 提交代码的场景\n当我们执行 git commit -m &quot;描述信息&quot; 的时候，我们知道此时必须添加一个描述信息。但是中华文化博大精深，不同的人去填写描述信息的时候，都会根据自己的理解来进行描述。\n而很多人的描述 “天马行空” ，这样就会导致别人在看你的提交记录时，看不懂你说的什么意思？不知道你当前的这次提交到底做了什么事情？会不会存在潜在的风险？\n比如说，我们来看这几条提交记录：\n![image-20210904203051754](02ESLint + Git Hooks&#x2F;image-20210904203051754.png)\n你能够想象得到它们经历了什么吗？\n所以 git 提交规范 势在必行。\n对于 git 提交规范 来说，不同的团队可能会有不同的标准，那么咱们今天就以目前使用较多的 Angular团队规范 延伸出的 Conventional Commits specification（约定式提交） 为例，来为大家详解  git 提交规范\n约定式提交规范要求如下：\n&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n\n--------  翻译 -------------\n    \n&lt;类型&gt;[可选 范围]: &lt;描述&gt;\n\n[可选 正文]\n\n[可选 脚注]\n\n其中 &lt;type&gt; 类型，必须是一个可选的值，比如：\n\n新功能：feat\n修复：fix\n文档变更：docs\n….\n\n也就是说，如果要按照 约定式提交规范 来去做的化，那么你的一次提交描述应该式这个样子的：\n\n\n我想大家看到这样的一个提交描述之后，心里的感觉应该和我一样是崩溃的！要是每次都这么写，写到猴年马月了！\n如果你有这样的困惑，那么 ”恭喜你“ ，接下来我们将一起解决这个问题！\n欲知后事如何，请看下一节《Commitizen助你规范化提交代码》\n08：Commitizen助你规范化提交代码在上一小节我们讲述了 约定式提交规范 ，我们知道如果严格安装 约定式提交规范， 来手动进行代码提交的话，那么是一件非常痛苦的事情，但是 git 提交规范的处理 又势在必行，那么怎么办呢？\n你遇到的问题，也是其他人所遇到的！\n经过了很多人的冥思苦想，就出现了一种叫做 git 提交规范化工具 的东西，而我们要学习的 commitizen 就是其中的佼佼者！\ncommitizen 仓库名为 cz-cli ，它提供了一个 git cz 的指令用于代替 git commit，简单一句话介绍它：\n\n\n\n\n\n\n\n\n\n当你使用 commitizen 进行代码提交（git commit）时，commitizen 会提交你在提交时填写所有必需的提交字段！\n这句话怎么解释呢？不用着急，下面我们就来安装并且使用一下 commitizen ，使用完成之后你自然就明白了这句话的意思！\n\n全局安装Commitizen\nnpm install -g commitizen@4.2.4\n\n安装并配置 cz-customizable 插件\n\n使用 npm 下载 cz-customizable\nnpm i cz-customizable@6.3.0 --save-dev\n\n添加以下配置到 package.json  中\n...\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;node_modules&#x2F;cz-customizable&quot;\n    &#125;\n  &#125;\n\n\n项目根目录下创建 .cz-config.js 自定义提示文件\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 可选类型\n  types: [\n    &#123; value: &#39;feat&#39;, name: &#39;feat:     新功能&#39; &#125;,\n    &#123; value: &#39;fix&#39;, name: &#39;fix:      修复&#39; &#125;,\n    &#123; value: &#39;docs&#39;, name: &#39;docs:     文档变更&#39; &#125;,\n    &#123; value: &#39;style&#39;, name: &#39;style:    代码格式(不影响代码运行的变动)&#39; &#125;,\n    &#123;\n      value: &#39;refactor&#39;,\n      name: &#39;refactor: 重构(既不是增加feature，也不是修复bug)&#39;\n    &#125;,\n    &#123; value: &#39;perf&#39;, name: &#39;perf:     性能优化&#39; &#125;,\n    &#123; value: &#39;test&#39;, name: &#39;test:     增加测试&#39; &#125;,\n    &#123; value: &#39;chore&#39;, name: &#39;chore:    构建过程或辅助工具的变动&#39; &#125;,\n    &#123; value: &#39;revert&#39;, name: &#39;revert:   回退&#39; &#125;,\n    &#123; value: &#39;build&#39;, name: &#39;build:    打包&#39; &#125;\n  ],\n  &#x2F;&#x2F; 消息步骤\n  messages: &#123;\n    type: &#39;请选择提交类型:&#39;,\n    customScope: &#39;请输入修改范围(可选):&#39;,\n    subject: &#39;请简要描述提交(必填):&#39;,\n    body: &#39;请输入详细描述(可选):&#39;,\n    footer: &#39;请输入要关闭的issue(可选):&#39;,\n    confirmCommit: &#39;确认使用以上信息提交？(y&#x2F;n&#x2F;e&#x2F;h)&#39;\n  &#125;,\n  &#x2F;&#x2F; 跳过问题\n  skipQuestions: [&#39;body&#39;, &#39;footer&#39;],\n  &#x2F;&#x2F; subject文字长度默认是72\n  subjectLimit: 72\n&#125;\n\n使用 git cz 代替 git commit使用 git cz 代替 git commit，即可看到提示内容\n\n\n那么到这里我们就已经可以使用git cz 来代替了 git commit 实现了规范化的提交诉求了，但是当前依然存在着一个问题，那就是我们必须要通过 git cz 指令才可以完成规范化提交！\n那么如果有马虎的同事，它们忘记了使用 git cz 指令，直接就提交了怎么办呢？\n那么有没有方式来限制这种错误的出现呢？\n答案是有的！\n下一节我们来看 《什么是 Git Hooks》\n09：什么是 Git Hooks上一小节中我们使用了 git cz 来代替了 git commit 实现了规范化的提交诉求，但是依然存在着有人会忘记使用的问题。\n那么这一小节我们就来看一下这样的问题，我们应该如何去进行解决。\n先来明确一下我们最终要实现的效果：\n\n\n\n\n\n\n\n\n\n我们希望：\n当《提交描述信息》不符合 约定式提交规范 的时候，阻止当前的提交，并抛出对应的错误提示\n而要实现这个目的，我们就需要先来了解一个概念，叫做 Git hooks（git 钩子 || git 回调方法） \n也就是：**git 在执行某个事件之前或之后进行一些其他额外的操作**\n而我们所期望的 阻止不合规的提交消息，那么就需要使用到 hooks 的钩子函数。\n下面是我整理出来的所有的 hooks ，大家可以进行一下参考，其中加粗的是常用到的 hooks：\n\n\n\nGit Hook\n调用时机\n说明\n\n\n\npre-applypatch\ngit am执行前\n\n\n\napplypatch-msg\ngit am执行前\n\n\n\npost-applypatch\ngit am执行后\n不影响git am的结果\n\n\npre-commit\ngit commit执行前\n可以用git commit --no-verify绕过\n\n\ncommit-msg\ngit commit执行前\n可以用git commit --no-verify绕过\n\n\npost-commit\ngit commit执行后\n不影响git commit的结果\n\n\npre-merge-commit\ngit merge执行前\n可以用git merge --no-verify绕过。\n\n\nprepare-commit-msg\ngit commit执行后，编辑器打开之前\n\n\n\npre-rebase\ngit rebase执行前\n\n\n\npost-checkout\ngit checkout或git switch执行后\n如果不使用--no-checkout参数，则在git clone之后也会执行。\n\n\npost-merge\ngit commit执行后\n在执行git pull时也会被调用\n\n\npre-push\ngit push执行前\n\n\n\npre-receive\ngit-receive-pack执行前\n\n\n\nupdate\n\n\n\n\npost-receive\ngit-receive-pack执行后\n不影响git-receive-pack的结果\n\n\npost-update\n当 git-receive-pack对 git push 作出反应并更新仓库中的引用时\n\n\n\npush-to-checkout\n当&#96;&#96;git-receive-pack对git push做出反应并更新仓库中的引用时，以及当推送试图更新当前被签出的分支且receive.denyCurrentBranch配置被设置为updateInstead&#96;时\n\n\n\npre-auto-gc\ngit gc --auto执行前\n\n\n\npost-rewrite\n执行git commit --amend或git rebase时\n\n\n\nsendemail-validate\ngit send-email执行前\n\n\n\nfsmonitor-watchman\n配置core.fsmonitor被设置为.git/hooks/fsmonitor-watchman或.git/hooks/fsmonitor-watchmanv2时\n\n\n\np4-pre-submit\ngit-p4 submit执行前\n可以用git-p4 submit --no-verify绕过\n\n\np4-prepare-changelist\ngit-p4 submit执行后，编辑器启动前\n可以用git-p4 submit --no-verify绕过\n\n\np4-changelist\ngit-p4 submit执行并编辑完changelist message后\n可以用git-p4 submit --no-verify绕过\n\n\np4-post-changelist\ngit-p4 submit执行后\n\n\n\npost-index-change\n索引被写入到read-cache.c do_write_locked_index后\n\n\n\nPS：详细的 HOOKS介绍 可点击这里查看\n整体的 hooks 非常多，当时我们其中用的比较多的其实只有两个：\n\n\n\nGit Hook\n调用时机\n说明\n\n\n\npre-commit\ngit commit执行前它不接受任何参数，并且在获取提交日志消息并进行提交之前被调用。脚本git commit以非零状态退出会导致命令在创建提交之前中止。\n可以用git commit --no-verify绕过\n\n\ncommit-msg\ngit commit执行前可用于将消息规范化为某种项目标准格式。还可用于在检查消息文件后拒绝提交。\n可以用git commit --no-verify绕过\n\n\n简单来说这两个钩子：\n\ncommit-msg：可以用来规范化标准格式，并且可以按需指定是否要拒绝本次提交\npre-commit：会在提交前被调用，并且可以按需指定是否要拒绝本次提交\n\n而我们接下来要做的关键，就在这两个钩子上面。\n10：使用 husky + commitlint 检查提交描述是否符合规范要求在上一小节中，我们了解了 git hooks 的概念，那么接下来我们就使用 git hooks 来去校验我们的提交信息。\n要完成这么个目标，那么我们需要使用两个工具：\n\ncommitlint：用于检查提交信息\n\nhusky：是git hooks工具\n\n\n注意：**npm 需要在 7.x 以上版本！！！！！**\n那么下面我们分别来去安装一下这两个工具：\ncommitlint\n安装依赖：\nnpm install --save-dev @commitlint&#x2F;config-conventional@12.1.4 @commitlint&#x2F;cli@12.1.4\n\n创建 commitlint.config.js 文件\necho &quot;module.exports &#x3D; &#123;extends: [&#39;@commitlint&#x2F;config-conventional&#39;]&#125;&quot; &gt; commitlint.config.js\n\n打开 commitlint.config.js ， 增加配置项（ config-conventional 默认配置点击可查看 ）：\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 继承的规则\n  extends: [&#39;@commitlint&#x2F;config-conventional&#39;],\n  &#x2F;&#x2F; 定义规则类型\n  rules: &#123;\n    &#x2F;&#x2F; type 类型定义，表示 git 提交的 type 必须在以下类型范围内\n    &#39;type-enum&#39;: [\n      2,\n      &#39;always&#39;,\n      [\n        &#39;feat&#39;, &#x2F;&#x2F; 新功能 feature\n        &#39;fix&#39;, &#x2F;&#x2F; 修复 bug\n        &#39;docs&#39;, &#x2F;&#x2F; 文档注释\n        &#39;style&#39;, &#x2F;&#x2F; 代码格式(不影响代码运行的变动)\n        &#39;refactor&#39;, &#x2F;&#x2F; 重构(既不增加新功能，也不是修复bug)\n        &#39;perf&#39;, &#x2F;&#x2F; 性能优化\n        &#39;test&#39;, &#x2F;&#x2F; 增加测试\n        &#39;chore&#39;, &#x2F;&#x2F; 构建过程或辅助工具的变动\n        &#39;revert&#39;, &#x2F;&#x2F; 回退\n        &#39;build&#39; &#x2F;&#x2F; 打包\n      ]\n    ],\n    &#x2F;&#x2F; subject 大小写不做校验\n    &#39;subject-case&#39;: [0]\n  &#125;\n&#125;\n\n\n注意：确保保存为 UTF-8 的编码格式，否则可能会出现以下错误：\n![image-20210710121456416](02ESLint + Git Hooks&#x2F;image-20210710121456416.png)\n接下来我们来安装 husky\nhusky\n安装依赖：\nnpm install husky@7.0.1 --save-dev\n\n启动 hooks ， 生成 .husky 文件夹\nnpx husky install\n\n![image-20210906202034156](02ESLint + Git Hooks&#x2F;image-20210906202034156.png)\n\n在 package.json 中生成 prepare 指令（ 需要 npm &gt; 7.0 版本 ）\nnpm set-script prepare &quot;husky install&quot;\n\n\n\n执行 prepare 指令\nnpm run prepare\n\n执行成功，提示\n\n\n添加 commitlint 的 hook 到 husky中，并指令在 commit-msg 的 hooks 下执行 npx --no-install commitlint --edit &quot;$1&quot; 指令\nnpx husky add .husky&#x2F;commit-msg &#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;\n\n此时的 .husky 的文件结构![image-20210710120228931]( 02ESLint + Git Hooks&#x2F;image-20210710120228931.png)\n\n\n至此， 不符合规范的 commit 将不再可提交：\nPS F:\\xxxxxxxxxxxxxxxxxxxxx\\imooc-admin&gt; git commit -m &quot;测试&quot;\n⧗   input: 测试\n✖   subject may not be empty [subject-empty]\n✖   type may not be empty [type-empty]\n\n✖   found 2 problems, 0 warnings\nⓘ   Get help: https:&#x2F;&#x2F;github.com&#x2F;conventional-changelog&#x2F;commitlint&#x2F;#what-is-commitlint\n\nhusky - commit-msg hook exited with code 1 (error)\n\n\n\n那么至此，我们就已经可以处理好了 强制规范化的提交要求，到现在 不符合规范的提交信息，将不可在被提交！\n那么到这里我们的 规范化目标 就完成了吗？\n当然没有！\n现在我们还缺少一个 规范化的处理 ，那就是 代码格式提交规范处理！\n有人看到这里可能说，咦！ 这个怎么看着这么眼熟啊？这个事情我们之前不是做过了吗？还需要在处理什么？\n欲知后事如何，请看下一节《通过 pre-commit 处理提交时代码规范》\n11：通过 pre-commit 检测提交时代码规范在 ESLint 与 Prettier 配合解决代码格式问题 的章节中，我们讲解了如何处理 本地！代码格式问题。\n但是这样的一个格式处理问题，他只能够在本地进行处理，并且我们还需要 手动在  VSCode 中配置自动保存 才可以。那么这样就会存在一个问题，要是有人忘记配置这个东西了怎么办呢？他把代码写的乱七八糟的直接就提交了怎么办呢？\n所以我们就需要有一种方式来规避这种风险。\n那么想要完成这么一个操作就需要使用 husky 配合 eslint 才可以实现。\n我们期望通过 husky 监测 pre-commit 钩子，在该钩子下执行 npx eslint --ext .js,.vue src 指令来去进行相关检测：\n\n执行 npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot; 添加 commit 时的 hook （npx eslint --ext .js,.vue src 会在执行到该 hook 时运行）\n\n该操作会生成对应文件 pre-commit：![image-20210906204043915](02ESLint + Git Hooks&#x2F;image-20210906204043915.png)\n\n关闭 VSCode 的自动保存操作\n\n修改一处代码，使其不符合 ESLint 校验规则\n\n执行 提交操作 会发现，抛出一系列的错误，代码无法提交\nPS F:\\xxxxxxxxxxxxxxxxxxx\\imooc-admin&gt; git commit -m &#39;test&#39;\n\nF:\\xxxxxxxxxxxxxxxx\\imooc-admin\\src\\views\\Home.vue\n  13:9  error  Strings must use singlequote  quotes\n\n✖ 1 problem (1 error, 0 warnings)\n  1 error and 0 warnings potentially fixable with the &#96;--fix&#96; option.\n\nhusky - pre-commit hook exited with code 1 (error)\n\n\n\n想要提交代码，必须处理完成所有的错误信息\n\n\n那么到这里位置，我们已经通过 pre-commit 检测到了代码的提交规范问题。\n那么到这里就万事大吉了吗？\n在这个世界上从来不缺的就是懒人，错误的代码格式可能会抛出很多的 ESLint 错误，让人看得头皮发麻。严重影响程序猿的幸福指数。\n那么有没有办法，让程序猿在 0 配置的前提下，哪怕代码格式再乱，也可以 ”自动“ 帮助他修复对应的问题，并且完成提交呢？\n你别说，还真有！\n那么咱们来看下一节《lint-staged 自动修复格式错误》\n12：lint-staged 自动修复格式错误在上一章中我们通过 pre-commit 处理了 检测代码的提交规范问题，当我们进行代码提交时，会检测所有的代码格式规范 。\n但是这样会存在两个问题：\n\n我们只修改了个别的文件，没有必要检测所有的文件代码格式\n它只能给我们提示出对应的错误，我们还需要手动的进行代码修改\n\n那么这一小节，我们就需要处理这两个问题\n那么想要处理这两个问题，就需要使用另外一个插件 lint-staged ！\nlint-staged 可以让你当前的代码检查 只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送\nlint-staged 无需单独安装，我们生成项目时，vue-cli 已经帮助我们安装过了，所以我们直接使用就可以了\n\n修改 package.json 配置\n&quot;lint-staged&quot;: &#123;\n    &quot;src&#x2F;**&#x2F;*.&#123;js,vue&#125;&quot;: [\n      &quot;eslint --fix&quot;,\n      &quot;git add&quot;\n    ]\n  &#125;\n\n如上配置，每次它只会在你本地 commit 之前，校验你提交的内容是否符合你本地配置的 eslint规则(这个见文档 ESLint )，校验会出现两种结果：\n\n如果符合规则：则会提交成功。\n如果不符合规则：它会自动执行 eslint --fix 尝试帮你自动修复，如果修复成功则会帮你把修复好的代码提交，如果失败，则会提示你错误，让你修好这个错误之后才能允许你提交代码。\n\n\n修改 .husky/pre-commit 文件\n#!&#x2F;bin&#x2F;sh\n. &quot;$(dirname &quot;$0&quot;)&#x2F;_&#x2F;husky.sh&quot;\n\nnpx lint-staged\n\n\n再次执行提交代码\n\n发现 暂存区中 不符合 ESlint 的内容，被自动修复\n\n\n13：关于 vetur 检测 template 的单一根元素的问题在 vue2 中，template 只允许存在一个根元素，但是这种情况在 vue3 里发生了一些变化。\n在 Vue3 中开始支持 template 存在多个根元素了。但是因为 VSCode 中的一些插件没有及时更新，所以当你在 template 中写入多个根元素时，有可能会出现以下的错误：\n![image-20210717190311264](02ESLint + Git Hooks&#x2F;image-20210717190311264.png)\n出现这个问题的原因主要是： vetur 这个 vsCode 插件依然按照 vue2 的单一根元素逻辑进行检测，所以会出现提示错误的问题。\n但是大家要注意，虽然这样不太好看，但是 该问题并不影响代码运行！\n如果你实在觉得这样太丑的话，那么可以通过以下方案来 取消 vetur 对 template 的检测： \n\n在 VSCode  的设置中，搜索 vetur，找到如下设置，取消勾选\n\n![image-20210717190629024](02ESLint + Git Hooks&#x2F;image-20210717190629024.png)\n\n重启 VSCode\n\n按以上两种方式执行之后，你的多根元素就不会出现不好看的错误了\n14：总结本章中我们处理了 编程格式规范的问题，整个规范大体可以分为两大类：\n\n代码格式规范\ngit 提交规范\n\n代码格式规范：\n对于 代码格式规范 而言，我们通过 ESLint + Prettier + VSCode 配置 配合进行了处理。\n最终达到了在保存代码时，自动规范化代码格式的目的。\ngit 提交规范：\n对于 git 提交规范 而言我们使用了 husky 来监测 Git hooks 钩子，并且通过以下插件完成了对应的配置：\n\n约定式提交规范\ncommitizen：git 提交规范化工具\ncommitlint：用于检查提交信息\npre-commit： git hooks 钩子\nlint-staged：只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送\n\n那么处理完成这些规范操作之后，在下一章我们将会正式进入到咱们的项目开发之中！\n","slug":"vue3.2后台管理系统/02ESLint + Git Hooks","date":"2022-08-22T12:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"5d151b192bb48856221120bca811fbcf","title":"01项目前置","content":"01项目前置vue 的最新变化自从 vue 在 2020年09月18日 发布了 3.0 的版本之后，很多开发者都开始尝试被大受推崇的 Composition API ，但是在经过了短期的追捧之后，大家却发现，在企业中 Composition API 却并没有被大范围的普及，很多的公司虽然升级到了 vue 3 ，但却依然使用着 options API 语法。\n追其根本，原因还是在 Composition API 所提供的 setup 函数语法 中，如果你使用 setup 函数语法 ，那么你得到的代码可能是这样的：\n\n\n此时我们想要在 template 中使用一个 响应式数据，不但要通过 ref 进行声明，还需要在 setup 函数中进行 return 操作。同样方法也是如此。\n那么当我们的一个项目足够复杂时，这样的一种结构形式就会变得 非常的难看 并且 难以维护\n而这样的问题作为 vue 官方也是看到了的。\n所以说在 vue3 仅仅发布了一个月之后，也就是在 2020年10月28 ，Vue 就提出了一个 RFC ，尝试新的方式来废弃掉这种 setup 函数式 语法。\n时隔一年，在 2021年8月5日 ，伴随着 vue 3.2 的发布，vue 正式推出了全新的 composition API 语法标准 script-setup \nscript-setup 的推出，标记着 setup 函数式语法 正式称为过去式！\n基于 script-setup 语法标准 ，我们再去实现之前的业务，代码则变成了这样：\n\n\n原本 25 行的代码量被压缩到了 14 行，并且大家可以发现，现在我们可以像 写普通的 js 一样去写 vue 了 \n除此之外 vue3.2 版本还带来了很多其他的巨大改变，比如：\n\n耗时一年才发布的全新响应式优化\n组件状态驱动的动态 CSS 值\n…\n\n这些新的改变，我们在开篇这里就不再赘述了\n后台系统的广泛性而对于后台系统而言，相信只要是前端开发的工程师，那么就不陌生了。\n\n\n如图所示，根据我们之前的多次数据统计分析，在 1-5 年经验的前端开发者中，后台管理系统的项目占比为 59.62% 。为前端开发中最为重要的工作方向。\n项目功能介绍本次的项目则是专门针对于这种最为重要的工作方向，抽离出其中几十个经典业务模型，争取可以制作出覆盖大家大部分后台开发业务场景的综合性解决方案。\n具体业务模型有：\n\n基于最新 vue 标准的：\nscript setup 语法标准\n最新的响应式变更\n组件状态驱动的动态 css\n最新 vue 全家桶\n\n\n基于大厂编程规范的：\neslint\nprettier\nCommitizen\nhusky\ncommitlint\npre-commit\nlint-staged\n\n\n以及：\nSvg Sprite Icon\n环境变量处理方案\n接口模块封装方案\n请求动作封装方案\ntoken 处理方案\n登录鉴权方案\n主动登出方案\n被动登出方案\n动态路由表处理方案\n动态菜单项处理方案\n动态面包屑处理方案\n联动处理\n动画处理\n国际化处理方案\n动态主题处理方案\n全屏处理方案\n页面检索处理方案\nTagsView 处理方案\n功能引导处理方案\n多组件\n基于文件选择的 Excel 导入方案\n基于文件拖拽的 Excel 导入方案\nExcel 数据导出方案\nRBAC 的权限分控体系\n动态权限设定\n页面权限处理方案\n功能权限处理方案\n动态表格处理方案\n拖拽表格处理方案\n辅助库选择标准\nmarkdown 编辑器处理\n富文本编辑器处理\n打包优化处理方案\n服务器、域名购买与备案标准\n前端项目部署方案\n\n\n\n等一揽子处理方案内容\n","slug":"vue3.2后台管理系统/01项目前置","date":"2022-08-22T11:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"a805b320fb8cf502f43e7c3ca090542e","title":"创建脚手架","content":"本章节将详细介绍一个企业级脚手架创建的全流程\n","slug":"前端工程化/创建脚手架","date":"2022-08-19T01:35:10.000Z","categories_index":"前端工程化","tags_index":"脚手架","author_index":"西非"},{"id":"f10fec0a057f8cf28015d516e2564360","title":"搭建组件库","content":"本章节将详细介绍一个组件库创建的全流程\n","slug":"前端工程化/搭建组件库","date":"2022-08-18T09:02:44.000Z","categories_index":"前端工程化","tags_index":"组件库","author_index":"西非"},{"id":"f93b6c858be383138822a089f75a859c","title":"搭建个人博客","content":"本章节将详细介绍一个个人博客创建的全流程\n","slug":"个人博客/搭建个人博客","date":"2022-08-17T09:02:44.000Z","categories_index":"vue","tags_index":"vue","author_index":"西非"}]