[{"id":"180a3d85e4f6719a36b90ca64af76a19","title":"搭建登录架构","content":"第三章：搭建登录架构01：前言在上一章中，我们处理了基本的编码规范，那么接下来我们就可以实现对应的项目开发了。\n那么在之后的项目开发中，我们将会使用最新的 vue3 script setup 语法。\n所以说在本章节中我们需要做两件事情：\n\nvue3 最新特性及最新语法\n\n登录功能开发\n\n\n\n不过大家放心，我们不会把大量的时间花费到 枯燥的语法学习之中，而是会在实际的项目开发中和大家一起逐渐深入学习  script setup 语法，毕竟 学以致用 才是我们遵循的唯一目标。\n那么明确好了我们接下来要做的事情之后，咱们就开始新的篇章吧！\n02：vue3 项目结构解析想要进行项目的开发，那么首先我们需要先去了解一下 vue3 项目的初始结构\n在这里我们把它和 vue2 的项目进行对比来去说明\n\nmain.js\n通过 按需导入的 createApp 方法来来构建 vue 实例\n通过 vue实例.use 方法来挂载插件（router、vuex）\n没有了 Vue 构造方法，无法再挂载原型\n\n\nApp.vue\n组件内部结构无变化，依然是\ntempalte\nscript\nstyle\n\n\n&lt;template&gt; 标签中支持多个根标签\n\n\nstore/index.js\n通过 按需导入的 createStore 方法来来构建 store 实例\n无需再通过 Vue.use(Vuex) 的形式进行挂载\n\n\nrouter/index.js\n通过 按需导入的 createRouter 方法来构建 router 实例\n通过 按需导入的 createWebHashHistory 方法来创建 hash 模式对象，进行路由模式指定\n无需再通过 Vue.use(VueRouter) 的形式进行挂载\nroutes 路由表的定义无差别\n\n\n\n综上所述，在 vue3 的初始化项目中，与 vue2 对比的最大差异其实就是两点：\n\nvue3 使用 按需导入的形式 进行初始化操作\n&lt;template&gt; 标签中支持多个根标签\n\n那么这一小节我们主要了解了 vue3 项目的初始结构，通过了解我们也可以发现现在的项目中，存在很多的 无用代码，那么下一小节我们就需要 删除掉这些无用的默认代码，也就是进行  初始化项目 操作。\n03：初始化项目结构@vue/cli 在帮助我们创建项目的同时，也生成了很多无用的代码，那么这一小节我们需要去除掉这些无用的代码。\n去除的方式如下所示：\n\nApp.vue 初始化代码如下：\n&lt;template&gt;\n  &lt;router-view &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot;&gt;&lt;&#x2F;style&gt;\n\n删除 views 文件夹下的所有 .vue 文件\n\n删除 components 文件夹下的所有 .vue 文件\n\nrouter/index.js 中初始化代码如下：\nimport &#123; createRouter, createWebHashHistory &#125; from &#39;vue-router&#39;\n\nconst routes &#x3D; []\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHashHistory(),\n  routes\n&#125;)\n\nexport default router\n\n\n浏览器中重新访问你的应用，得到如下页面即可：\n\n\n04：vue3 新特性介绍在开始本小节的内容之前，我必须要先声明一点：\n我们不会在课程中专门开辟出一段内容讲解 vue3 的知识。而是会在项目开发的过程中，通过实际场景逐步解锁对应的知识点，以达到学以致用的目的！\n所以说本小节的 vue3 新特性介绍 ，我们只会概述性的来介绍一下 vue3 中新增的主要内容。\n那么明确好了我们的目标之后，vue3 中到底新增了哪些比较核心的东西呢？：\n\ncomposition API\n使用了 Proxy 代替 Object.defineProperty() 实现响应式\n全新的全家桶\n全新的 TS 支持\nvite\n\nComposition API：组合式 API想要了解 组合式 API，那么首先我们需要先了解 options API，也就是 vue2 中的开发形式。\nvue2 中的开发形式被称为 options API，options API 存在\n\n方便\n易学\n清晰\n\n等一些特点，但是也存在着一些问题。\n而其中最主要的一个问题就是：当你的组件变得越来越复杂时，组件的可读性会变得越来越差。\n不知道大家有没有遇到过一种情况，那就是：你在完成一个组件代码时，总是需要不停的上下滚动滚轮，来查看 data 、methods、computed 之间的配合使用，就像下面一样\n![](.&#x2F;第三章：搭建登录架构&#x2F;options api.gif)\n这个截图中的代码大家不需要深究。\n在这个动图中我们定义的两个数据 optionsData 和 selectOption，然后我们在多个方法中都使用到了它们，但是大家可以发现，我们在使用或查看的过程中，得一直不停的翻动页面！\n因为我们的整体组件代码结构是这样的：\n\n\n定义数据与使用数据被分割在组件的各个位置，导致我们需要不断地翻滚页面来查看具体的业务逻辑！\n并且这种现象随着组件越来越复杂，这种情况会变得越来越严重！\n而这个就是 options API 所存在的问题：当你的组件变得越来越复杂时，组件的可读性会变得越来越差。\n而 Composition API 所期望解决的就是这么一个问题\n\n\n把定义数据与使用数据的逻辑放在一起进行处理，以达到更加易读，更加方便扩展的目的！\n那么具体怎么去做的，我们会在后面的课程中通过最新的 RFC -&gt; script setup 语法为大家进行解读。 \n使用了 Proxy 代替 Object.defineProperty() 实现响应式在 vue 2 的文档中 有这么一段话：\n\n\n\n\n\n\n\n\n\n由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。\n这里所谓的 JavaScript 的限制，所指的就是 Object.defineProperty() 的限制。\n因为 Object.defineProperty() 是通过：为对象属性指定描述符 的方式来监听 **对象中某个属性的 get 和 set**。\n所以在以下两种情况下，新的属性是 非响应式的：\n\n对于对象：\nvar vm &#x3D; new Vue(&#123;\n  data:&#123;\n    a:1\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; &#96;vm.a&#96; 是响应式的\n\nvm.b &#x3D; 2\n&#x2F;&#x2F; &#96;vm.b&#96; 是非响应式的\n\n\n\n对于数组：\nvar vm &#x3D; new Vue(&#123;\n  data: &#123;\n    items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n  &#125;\n&#125;)\nvm.items[1] &#x3D; &#39;x&#39; &#x2F;&#x2F; 不是响应性的\nvm.items.length &#x3D; 2 &#x2F;&#x2F; 不是响应性的\n\n这也是为什么会存在 Vue.set 这个 API 的原因。\n但是，这样的一种情况其实一直都是不合理的，因为这只是无意义的增加了复杂度而已，但是一直以来因为  Object.defineProperty() 这个 API 本身的限制，所以一直无法处理。\n直到 Proxy 被广泛支持，这种情况才发生了变化。\nProxy 用于：为对象创建一个代理，从而实现基本操作的拦截。 那么这样就从根本上解决了 Object.defineProperty() 所面临的那么两个问题。这也是为什么 vue3 中不再有 Vue.set 方法的原因。\n关于 proxy 的详细介绍，大家可以查看这一篇博客 Vue 3 深入响应式原理 - 聊一聊响应式构建的那些经历，在视频中，我们就不过多赘述了\n全新的全家桶vue 被称为是 渐进式框架，就是因为，对于 vue 而言，它不仅仅只有 vue.js 这一个核心库，还有其他的比如 vue-router，vuex 等一些周边库。这些周边库和 vue.js 一起共同组成了 vue 。\n所以说当 vue3 发布之后，vue-router、vuex 等全家桶也迎来了一波更新。在前面的 vue3 项目结构解析 这一小节，大家应该也能看到对应的代码变化。\n那么关于全家桶的更新内容，我们会在后面的课程中进行详细的讲解，所以就不在这里进行赘述了。\n全新的 TS 支持vue 3 使用 TypeScript 进行了重构，其目的是 为了防止随着应用的增长，而产生的许多潜在的运行时静态类型的错误 。同时这也意味着以后在 vue 中使用 TypeScript 不再需要其他的任何工具。\n但是有一点我需要提醒大家，虽然 vue 对 TypeScript 进行全面支持，这并不代表我们应该在任何情况下都无条件的使用 TypeScript（后面我们简称 TypeScript 为 TS）。\nTS 的优势主要在于 静态类型检查和环境声明，但同时它也会为你的项目增加复杂度。如果你的项目需要使用到以上两点，那么我推荐你使用 TS 。否则只是增加了无谓的复杂度而已。\n决定我们应该使用哪种技术的唯一条件，就是我们的目标。 我们需要做的是在可以 完成目标 的基础上，寻找最简单的实现方案。\n所以，基于以上原因，我们项目中并没有使用 TS 进行项目的开发。如果在后续的过程中，发现大家有这方面的需要，那么我会考虑专门针对 TS 的特性来开发一个对应的项目。\nvite最后就是一个新的打包工具 vite，vite 严格来说不能算是 vue3 的内容，只不过它跟随 vue3 进行了发布所以我们这里就把它算到了新特性里面。\nvite 的作用其实和 webpack 是一样的，都是一个 前端构建工具。它区别于 webpack 的地方在于它完全使用了 ES Module 的特性，可以无需预先打包，而是采用实时编译的方式。这样让它具备了远高于 webpack 的启动速度和热更新速度。\n但是 成也萧何，败也萧何 因为 vite 完全依赖 ES Module 就导致了 它无法直接对 commonJS 的模块化方式进行支持，必须得采用 依赖预构建 的形式。\n目前 vite 还不够稳定到足够支持商用，所以如果大家只是想要尝鲜，那么没有问题。如果大家希望创建一个商用的大型项目，那么个人还是推荐更加成熟的 webpack 方案。\n而我们当前的项目旨在构建一个 后台前端解决方案系统，所以我们这里依然选择了 webpack ，而不是 vite。\n05：全新的提案语法：script setup如果大家使用过 早期的 composition API ，那么应该会对 setup 函数 感触颇深，它的语法是反人类的。\n所以在  vue3 正式发布 40天 之后， 也就是 2020年10月28日 （vue3 正式发布日期为 2020年9月18日）提出了新的 script  setup 提案，该提案的目的只有一个：那就是让大家可以更爽的使用 composition API 语法！\n该提案在 2021年8月9日 正式定稿，并伴随着最新的 vue3 版本进行了发布，这也是为什么前面我们需要升级到最新的 vue 版本的原因。\n下面两张截图为对比 原setup函数  与   script setup：\n\n原 setup函数\nscript setup\n\n从截图中可以看出 script setup 语法更加符合我们开发者书写 JS 代码的习惯，它让我们书写 vue 就像再写普通的 js 一样。\n所以以后的 composition API 将是 script setup 语法的时代，原setup函数 将会逐渐退出历史舞台。\n而我们的项目也将会全部使用最新的 script setup 语法，让大家紧抓时代脉搏！\n06：导入 element-plus在开发我们的项目之前，我们需要先去导入 element-ui 的 vue3 支持版本，也就是 element-plus\nelement-plus 提供了快捷导入的方式，即：vue-cli-plugin-element-plus，大家可以通过以下方式来快捷导入 element-plus （注意：此种方式会自动修改 App.vue 文件）：\n\n在通过 vue-cli 创建的项目中，执行 \nvue add element-plus\n\n选择全局导入\n\n\n暂不生成覆盖变量的 scss 文件\n\n\n选择简体中文即可\n\n\n出现该提示表示安装完成\n\n\n此时运行项目，则会得到如下错误\n\n\n出现该错误的原因是因为 vue-cli-plugin-element-plus 默认修改了 APP.vue 文件，导入了 HelloWorld\n\n所以我们需要到 APP.vue 中，初始化如下代码：\n&lt;template&gt;\n  &lt;router-view &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;&lt;&#x2F;style&gt;\n\n\n那么至此，element-plus 导入成功，下一小节我们就正式开始项目的开发工作吧！\n07：构建登录页面 UI 结构\n在 views 中 login 文件夹，创建 index.vue 文件\n\n\n在 router/index.js 中增加以下路由配置\n&#x2F;**\n * 公开路由表\n *&#x2F;\nconst publicRoutes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;login&#39;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;login&#x2F;index&#39;)\n  &#125;\n]\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHashHistory(),\n  routes: publicRoutes\n&#125;)\n\n在 login/index.vue 中，生成基本页面结构\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;\n\n创建登录页面基本结构\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    &lt;el-form class&#x3D;&quot;login-form&quot; &gt;\n      &lt;div class&#x3D;&quot;title-container&quot;&gt;\n        &lt;h3 class&#x3D;&quot;title&quot;&gt;用户登录&lt;&#x2F;h3&gt;\n      &lt;&#x2F;div&gt;\n\n      &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;\n        &lt;span class&#x3D;&quot;svg-container&quot;&gt;\n          &lt;el-icon&gt;\n            &lt;avatar &#x2F;&gt;\n          &lt;&#x2F;el-icon&gt;\n        &lt;&#x2F;span&gt;\n        &lt;el-input\n          placeholder&#x3D;&quot;username&quot;\n          name&#x3D;&quot;username&quot;\n          type&#x3D;&quot;text&quot;\n        &#x2F;&gt;\n      &lt;&#x2F;el-form-item&gt;\n\n      &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;\n        &lt;span class&#x3D;&quot;svg-container&quot;&gt;\n          &lt;el-icon&gt;\n            &lt;avatar &#x2F;&gt;\n          &lt;&#x2F;el-icon&gt;\n        &lt;&#x2F;span&gt;\n        &lt;el-input\n          placeholder&#x3D;&quot;password&quot;\n          name&#x3D;&quot;password&quot;\n        &#x2F;&gt;\n        &lt;span class&#x3D;&quot;show-pwd&quot;&gt;\n          &lt;el-icon&gt;\n            &lt;avatar &#x2F;&gt;\n          &lt;&#x2F;el-icon&gt;\n        &lt;&#x2F;span&gt;\n      &lt;&#x2F;el-form-item&gt;\n\n      &lt;el-button type&#x3D;&quot;primary&quot; style&#x3D;&quot;width: 100%; margin-bottom: 30px&quot;\n        &gt;登录&lt;&#x2F;el-button\n      &gt;\n    &lt;&#x2F;el-form&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\n&#x2F;&#x2F; 导入组件之后无需注册可直接使用\nimport &#123; Avatar &#125; from &#39;@element-plus&#x2F;icons&#39;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n08：美化登录页面样式\n创建全局的 style \n\n在 src 下创建 styles/index.scss 文件，并写入以下内容：\nhtml,\nbody &#123;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB,\n    Microsoft YaHei, Arial, sans-serif;\n&#125;\n\n#app &#123;\n  height: 100%;\n&#125;\n\n*,\n*:before,\n*:after &#123;\n  box-sizing: inherit;\n  margin: 0;\n  padding: 0;\n&#125;\n\na:focus,\na:active &#123;\n  outline: none;\n&#125;\n\na,\na:focus,\na:hover &#123;\n  cursor: pointer;\n  color: inherit;\n  text-decoration: none;\n&#125;\n\ndiv:focus &#123;\n  outline: none;\n&#125;\n\n.clearfix &#123;\n  &amp;:after &#123;\n    visibility: hidden;\n    display: block;\n    font-size: 0;\n    content: &#39; &#39;;\n    clear: both;\n    height: 0;\n  &#125;\n&#125;\n\n\n在 main.js 中导入全局样式\n...\n&#x2F;&#x2F; 导入全局样式\nimport &#39;.&#x2F;styles&#x2F;index.scss&#39;\n...\n\n\n\n在 views/login/index.vue 中写入以下样式\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n$bg: #2d3a4b;\n$dark_gray: #889aa4;\n$light_gray: #eee;\n$cursor: #fff;\n\n.login-container &#123;\n  min-height: 100%;\n  width: 100%;\n  background-color: $bg;\n  overflow: hidden;\n\n  .login-form &#123;\n    position: relative;\n    width: 520px;\n    max-width: 100%;\n    padding: 160px 35px 0;\n    margin: 0 auto;\n    overflow: hidden;\n\n    ::v-deep .el-form-item &#123;\n      border: 1px solid rgba(255, 255, 255, 0.1);\n      background: rgba(0, 0, 0, 0.1);\n      border-radius: 5px;\n      color: #454545;\n    &#125;\n\n    ::v-deep .el-input &#123;\n      display: inline-block;\n      height: 47px;\n      width: 85%;\n\n      input &#123;\n        background: transparent;\n        border: 0px;\n        -webkit-appearance: none;\n        border-radius: 0px;\n        padding: 12px 5px 12px 15px;\n        color: $light_gray;\n        height: 47px;\n        caret-color: $cursor;\n      &#125;\n    &#125;\n  &#125;\n\n\n  .svg-container &#123;\n    padding: 6px 5px 6px 15px;\n    color: $dark_gray;\n    vertical-align: middle;\n    display: inline-block;\n  &#125;\n\n  .title-container &#123;\n    position: relative;\n\n    .title &#123;\n      font-size: 26px;\n      color: $light_gray;\n      margin: 0px auto 40px auto;\n      text-align: center;\n      font-weight: bold;\n    &#125;\n  &#125;\n\n  .show-pwd &#123;\n    position: absolute;\n    right: 10px;\n    top: 7px;\n    font-size: 16px;\n    color: $dark_gray;\n    cursor: pointer;\n    user-select: none;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n\n09：Icon 图标处理方案：SvgIcon在上一小节中我们完成了登陆页面的基本样式 。但是现在在登录页面中，还存在着最后一个样式问题，那就是 icon 图标。\n在我们的项目中所使用的 icon 图标，一共分为两类：\n\nelement-plus 的图标\n自定义的 svg 图标\n\n这也是通常情况下企业级项目开发时，所遇到的一种常见情况。\n对于 element-plus 的图标我们可以直接通过 el-icon 来进行显示，但是自定义图标的话，我们暂时还缺少显示的方式，所以说我们需要一个自定义的组件，来显示我们自定义的 svg 图标。\n那么这种自定义组件处理 自定义 svg 图标的形式，就是我们在面临这种问题时的通用解决方案。\n那么对于这个组件的话，它就需要拥有两种能力：\n\n显示外部 svg 图标\n显示项目内的 svg 图标\n\n基于以上概念，我们可以创建出以下对应代码：\n创建 components/SvgIcon/index.vue：\n&lt;template&gt;\n  &lt;div\n    v-if&#x3D;&quot;isExternal&quot;\n    :style&#x3D;&quot;styleExternalIcon&quot;\n    class&#x3D;&quot;svg-external-icon svg-icon&quot;\n    :class&#x3D;&quot;className&quot;\n  &#x2F;&gt;\n  &lt;svg v-else class&#x3D;&quot;svg-icon&quot; :class&#x3D;&quot;className&quot; aria-hidden&#x3D;&quot;true&quot;&gt;\n    &lt;use :xlink:href&#x3D;&quot;iconName&quot; &#x2F;&gt;\n  &lt;&#x2F;svg&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; isExternal as external &#125; from &#39;@&#x2F;utils&#x2F;validate&#39;\nimport &#123; defineProps, computed &#125; from &#39;vue&#39;\nconst props &#x3D; defineProps(&#123;\n  &#x2F;&#x2F; icon 图标\n  icon: &#123;\n    type: String,\n    required: true\n  &#125;,\n  &#x2F;&#x2F; 图标类名\n  className: &#123;\n    type: String,\n    default: &#39;&#39;\n  &#125;\n&#125;)\n\n&#x2F;**\n * 判断是否为外部图标\n *&#x2F;\nconst isExternal &#x3D; computed(() &#x3D;&gt; external(props.icon))\n&#x2F;**\n * 外部图标样式\n *&#x2F;\nconst styleExternalIcon &#x3D; computed(() &#x3D;&gt; (&#123;\n  mask: &#96;url($&#123;props.icon&#125;) no-repeat 50% 50%&#96;,\n  &#39;-webkit-mask&#39;: &#96;url($&#123;props.icon&#125;) no-repeat 50% 50%&#96;\n&#125;))\n&#x2F;**\n * 项目内图标\n *&#x2F;\nconst iconName &#x3D; computed(() &#x3D;&gt; &#96;#icon-$&#123;props.icon&#125;&#96;)\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n.svg-icon &#123;\n  width: 1em;\n  height: 1em;\n  vertical-align: -0.15em;\n  fill: currentColor;\n  overflow: hidden;\n&#125;\n\n.svg-external-icon &#123;\n  background-color: currentColor;\n  mask-size: cover !important;\n  display: inline-block;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n创建 utils/validate.js：\n\n&#x2F;**\n * 判断是否为外部资源\n *&#x2F;\nexport function isExternal(path) &#123;\n  return &#x2F;^(https?:|mailto:|tel:)&#x2F;.test(path)\n&#125;\n\n\n在 views/login/index.vue 中使用 外部 svg （https://res.lgdsunday.club/user.svg）：\n&lt;span class&#x3D;&quot;svg-container&quot;&gt;\n\t&lt;svg-icon icon&#x3D;&quot;https:&#x2F;&#x2F;res.lgdsunday.club&#x2F;user.svg&quot;&gt;&lt;&#x2F;svg-icon&gt;\n&lt;&#x2F;span&gt;\n\n外部图标可正常展示。\n那么在本小节中，我们创建了 SvgIcon 组件，用来处理了 外部图标 的展示，但是对于内部图标而言，我们此时依然无法进行展示。所以在下一小节中，我们就需要看一下，如何处理内部的 svg 图标。\n10：处理内部 svg 图标显示在上一章中，我们创建了 SvgIcon 组件用于显示 非 Element-ui 的图标。但是目前我们只处理了 外部 svg 的图标展示，内部的图标还无法展示。\n所以这一小节，我们就需要处理 内部的 svg 图标展示。\n\n首先导入所有的 svg 图标（大家可以从 讲师源代码 -&gt; src -&gt; icons -&gt; svg 处，获取所有 svg 图标），导入到 src -&gt; icons -&gt; svg 处\n\n在 icons 下创建 index.js 文件，该文件中需要完成两件事情：\n\n导入所有的 svg 图标\n完成 SvgIcon 的全局注册\n\n\n得出以下代码：\nimport SvgIcon from &#39;@&#x2F;components&#x2F;SvgIcon&#39;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;webpack.docschina.org&#x2F;guides&#x2F;dependency-management&#x2F;#requirecontext\n&#x2F;&#x2F; 通过 require.context() 函数来创建自己的 context\nconst svgRequire &#x3D; require.context(&#39;.&#x2F;svg&#39;, false, &#x2F;\\.svg$&#x2F;)\n&#x2F;&#x2F; 此时返回一个 require 的函数，可以接受一个 request 的参数，用于 require 的导入。\n&#x2F;&#x2F; 该函数提供了三个属性，可以通过 require.keys() 获取到所有的 svg 图标\n&#x2F;&#x2F; 遍历图标，把图标作为 request 传入到 require 导入函数中，完成本地 svg 图标的导入\nsvgRequire.keys().forEach(svgIcon &#x3D;&gt; svgRequire(svgIcon))\n\nexport default app &#x3D;&gt; &#123;\n  app.component(&#39;svg-icon&#39;, SvgIcon)\n&#125;\n\n\n在 main.js 中引入该文件\n...\n&#x2F;&#x2F; 导入 svgIcon\nimport installIcons from &#39;@&#x2F;icons&#39;\n...\ninstallIcons(app)\n...\n\n\n删除 views/login 下 局部导入 SvgIcon 的代码\n\n在 login/index.vue 中使用 SvgIcon 引入本地 svg\n&#x2F;&#x2F; 用户名   \n   &lt;svg-icon icon&#x3D;&quot;user&quot; &#x2F;&gt;\n   &#x2F;&#x2F; 密码\n   &lt;svg-icon icon&#x3D;&quot;password&quot; &#x2F;&gt;\n   &#x2F;&#x2F; 眼睛\n&lt;svg-icon icon&#x3D;&quot;eye&quot; &#x2F;&gt;\n\n此时 处理内容 svg 图标的代码 已经完成\n\n\n打开浏览器，我们发现 图标依然无法展示！ 这又是因为什么原因呢？\n来看下一节 《使用 svg-sprite-loader 处理 svg 图标》\n11：使用 svg-sprite-loader 处理 svg 图标svg-sprite-loader 是 webpack 中专门用来处理 svg 图标的一个 loader ，在上一节中我们的图标之所有没有展示，就是因为我们缺少该 loader。\n那么想要使用该 loader 我们需要做两件事情：\n\n下载该 laoder，执行：npm i --save-dev svg-sprite-loader@6.0.9\n\n创建 vue.config.js 文件，新增如下配置：\nconst path &#x3D; require(&#39;path&#39;)\nfunction resolve(dir) &#123;\n  return path.join(__dirname, dir)\n&#125;\n&#x2F;&#x2F; https:&#x2F;&#x2F;cli.vuejs.org&#x2F;zh&#x2F;guide&#x2F;webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F\nmodule.exports &#x3D; &#123;\n  chainWebpack(config) &#123;\n    &#x2F;&#x2F; 设置 svg-sprite-loader\n    config.module\n      .rule(&#39;svg&#39;)\n      .exclude.add(resolve(&#39;src&#x2F;icons&#39;))\n      .end()\n    config.module\n      .rule(&#39;icons&#39;)\n      .test(&#x2F;\\.svg$&#x2F;)\n      .include.add(resolve(&#39;src&#x2F;icons&#39;))\n      .end()\n      .use(&#39;svg-sprite-loader&#39;)\n      .loader(&#39;svg-sprite-loader&#39;)\n      .options(&#123;\n        symbolId: &#39;icon-[name]&#39;\n      &#125;)\n      .end()\n  &#125;\n&#125;\n\n\n处理完以上配置之后，重新启动项目，图标即可显示！\n12：Vue3.2 响应式优化对应用层的改变在处理好了 SvgIcon 图标之后，接下来我们就需要处理登陆页面的逻辑问题了。不过在处理这个逻辑之前，我们需要先来明确一点 vue3 新的更新内容。\n如果大家之前有过了解 Vue3 代码的话，那么会知道 Vue3 中声明响应式数据的方式有两种：\n\nref\nreactive\n\n对于这两种使用方式而言，它们在应用层上并没有明确的界限，也就是说我们可能很难仅通过官网的介绍来判断我应该在什么情况下使用什么。\n但是这种情况在现在已经不存在了。\n2020年10月29日，社区大佬 basvanmeurs 提出了一个新的 PR，大概的意思是说：他重构了响应式的部分内容，大大增加了性能。\n详细的介绍如下：\n\n\n\n\n\n\n\n\n\n\nBig runtime performance improvement for ref, computed, watch and watchEffect (30%-80% depending on the amount of dependencies)\nMemory usage decreased by about 30% when creating ref, computed, watch and watchEffect\nCreation time performance improvement, most notably for watchers and watchEffects\n\n\nref、calculated、watch 和 watchEffect 的运行时性能大幅提升（30%-80% 取决于依赖项的数量）创建 ref、calculated、watch 和 watchEffect 时内存使用量减少了约 30%创建时间性能改进，最显著的是 watchers 和 watchEffects\n这是一个非常强大的变化，同时又因为这个变化过于庞大，所以一直等待到 2021年8月5日 伴随着  vue 3.2发布，尤大才合并对应的代码，并在这次变化中对该性能改进进行了如下的介绍：\n\n\n\n\n\n\n\n\n\n\nMore efficient ref implementation (~260% faster read &#x2F; ~50% faster write)\n~40% faster dependency tracking\n~17% less memory usage\n\n\n更高效的 ref 实现（约 260% 的读取速度&#x2F;约 50% 的写入速度）依赖项跟踪速度提高约 40%内存使用量减少约 17%\n毫无疑问，这绝对是一个伟大的变化。\n那么针对于这个变化，在应用层中最大的体现就是 ref 这个 API ，性能得到了大幅度的提升。\n所以说，拥抱新的变化吧！\n在之后能使用 ref 的地方就使用 ref 吧。毕竟现在它的性能得到了大幅的提升！\n那么在咱们之后的代码中，我们同样也会全部使用 ref 来作为响应式数据构建的方式，无论是 基本数据类型 或者是 复杂数据类型， 毕竟这样做本身并没有什么问题，对不对？\n13：完善登录表单校验表单校验是表单使用的一个通用能力，在 element-plus 中想要为表单进行表单校验那么我们需要关注以下三点：\n\n为 el-form 绑定 model 属性\n为 el-form 绑定 rules 属性\n为 el-form-item 绑定 prop 属性\n\n保证以上三点即可为 el-from 添加表单校验功能。\n因为这一块是比较简单的功能，只要有过 element-ui 使用经验的人，应该对这里都不陌生，所以这里就不对这块内容进行过多赘述了。对这里不是很了解的人可以参考下 element-plus 中 from 表单部分\n以下为对应的代码实现：\nviews&#x2F;login\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    &lt;el-form class&#x3D;&quot;login-form&quot; :model&#x3D;&quot;loginForm&quot; :rules&#x3D;&quot;loginRules&quot;&gt;\n      ...\n      &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;\n        ...\n        &lt;el-input\n         ...\n          v-model&#x3D;&quot;loginForm.username&quot;\n        &#x2F;&gt;\n      &lt;&#x2F;el-form-item&gt;\n\n      &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;\n        ...\n        &lt;el-input\n          ...\n          v-model&#x3D;&quot;loginForm.password&quot;\n        &#x2F;&gt;\n        ...\n      &lt;&#x2F;el-form-item&gt;\n\t\t...\n    &lt;&#x2F;el-form&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nimport &#123; validatePassword &#125; from &#39;.&#x2F;rules&#39;\n\n&#x2F;&#x2F; 数据源\nconst loginForm &#x3D; ref(&#123;\n  username: &#39;super-admin&#39;,\n  password: &#39;123456&#39;\n&#125;)\n&#x2F;&#x2F; 验证规则\nconst loginRules &#x3D; ref(&#123;\n  username: [\n    &#123;\n      required: true,\n      trigger: &#39;blur&#39;,\n      message: &#39;用户名为必填项&#39;\n    &#125;\n  ],\n  password: [\n    &#123;\n      required: true,\n      trigger: &#39;blur&#39;,\n      validator: validatePassword()\n    &#125;\n  ]\n&#125;)\n&lt;&#x2F;script&gt;\n\n\nviews&#x2F;login&#x2F;rules.js\nexport const validatePassword &#x3D; () &#x3D;&gt; &#123;\n  return (rule, value, callback) &#x3D;&gt; &#123;\n    if (value.length &lt; 6) &#123;\n      callback(new Error(&#39;密码不能少于6位&#39;))\n    &#125; else &#123;\n      callback()\n    &#125;\n  &#125;\n&#125;\n\n14：密码框状态通用处理对于密码框存在两种状态：\n\n密文状态\n明文状态\n\n点击 眼睛 可以进行切换。\n该功能实现为通用的处理方案，只需要动态修改 input 的 type 类型即可，其中：\n\npassword 为密文显示\ntext 为明文显示\n\n根据以上理论，即可得出以下代码：\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    &lt;el-form class&#x3D;&quot;login-form&quot; :model&#x3D;&quot;loginForm&quot; :rules&#x3D;&quot;loginRules&quot;&gt;\n      ...\n        &lt;el-input\n          ...\n          :type&#x3D;&quot;passwordType&quot;\n        &#x2F;&gt;\n        &lt;span class&#x3D;&quot;show-pwd&quot;&gt;\n          &lt;svg-icon\n            :icon&#x3D;&quot;passwordType &#x3D;&#x3D;&#x3D; &#39;password&#39; ? &#39;eye&#39; : &#39;eye-open&#39;&quot;\n            @click&#x3D;&quot;onChangePwdType&quot;\n          &#x2F;&gt;\n        &lt;&#x2F;span&gt;\n      ...\n    &lt;&#x2F;el-form&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\n...\n\n&#x2F;&#x2F; 处理密码框文本显示状态\nconst passwordType &#x3D; ref(&#39;password&#39;)\nconst onChangePwdType &#x3D; () &#x3D;&gt; &#123;\n  if (passwordType.value &#x3D;&#x3D;&#x3D; &#39;password&#39;) &#123;\n    passwordType.value &#x3D; &#39;text&#39;\n  &#125; else &#123;\n    passwordType.value &#x3D; &#39;password&#39;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n15：通用后台登录方案解析处理完了表单的基本操作之后，接下来就是登录操作的实现了。\n对于登录操作在后台项目中是一个通用的解决方案，具体可以分为以下几点：\n\n封装 axios 模块\n封装 接口请求 模块\n封装登录请求动作\n保存服务端返回的 token\n登录鉴权\n\n这些内容就共同的组成了一套 后台登录解决方案 。那么在后面的章节中，我们就分别来去处理这些内容。\n16：配置环境变量封装 axios 模块首先我们先去完成第一步：封装 axios 模块。\n在当前这个场景下，我们希望封装出来的 axios 模块，至少需要具备一种能力，那就是：根据当前模式的不同，设定不同的 BaseUrl ，因为通常情况下企业级项目在 开发状态 和 生产状态 下它的 baseUrl 是不同的。\n对于 @vue/cli 来说，它具备三种不同的模式：\n\ndevelopment\ntest\nproduction\n\n具体可以点击 这里 进行参考。\n根据我们前面所提到的 开发状态和生产状态 那么此时我们的 axios 必须要满足：在 开发 || 生产 状态下，可以设定不同 BaseUrl 的能力\n那么想要解决这个问题，就必须要使用到 @vue/cli 所提供的 环境变量 来去进行实现。\n我们可以在项目中创建两个文件：\n\n.env.development\n.env.production\n\n它们分别对应 开发状态 和 生产状态。\n我们可以在上面两个文件中分别写入以下代码：\n**.env.development**：\n# 标志\nENV &#x3D; &#39;development&#39;\n\n# base api\nVUE_APP_BASE_API &#x3D; &#39;&#x2F;api&#39;\n\n.env.production：\n# 标志\nENV &#x3D; &#39;production&#39;\n\n# base api\nVUE_APP_BASE_API &#x3D; &#39;&#x2F;prod-api&#39;\n\n有了这两个文件之后，我们就可以创建对应的 axios 模块\n创建 utils/request.js ，写入如下代码：\nimport axios from &#39;axios&#39;\n\nconst service &#x3D; axios.create(&#123;\n  baseURL: process.env.VUE_APP_BASE_API,\n  timeout: 5000\n&#125;)\n\nexport default service\n\n17：封装请求动作有了 axios 模块之后，接下来我们就可以\n\n封装接口请求模块\n封装登录请求动作\n\n封装接口请求模块：\n创建 api 文件夹，创建 sys.js：\nimport request from &#39;@&#x2F;utils&#x2F;request&#39;\n\n&#x2F;**\n * 登录\n *&#x2F;\nexport const login &#x3D; data &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;sys&#x2F;login&#39;,\n    method: &#39;POST&#39;,\n    data\n  &#125;)\n&#125;\n\n封装登录请求动作：\n该动作我们期望把它封装到 vuex 的 action 中\n在 store 下创建 modules 文件夹，创建 user.js 模块，用于处理所有和 用户相关 的内容（此处需要使用第三方包 md5 ）：\nimport &#123; login &#125; from &#39;@&#x2F;api&#x2F;sys&#39;\nimport md5 from &#39;md5&#39;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;&#125;),\n  mutations: &#123;&#125;,\n  actions: &#123;\n    login(context, userInfo) &#123;\n      const &#123; username, password &#125; &#x3D; userInfo\n      return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        login(&#123;\n          username,\n          password: md5(password)\n        &#125;)\n          .then(data &#x3D;&gt; &#123;\n            resolve()\n          &#125;)\n          .catch(err &#x3D;&gt; &#123;\n            reject(err)\n          &#125;)\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n\n在 store/index 中完成注册：\nimport &#123; createStore &#125; from &#39;vuex&#39;\nimport user from &#39;.&#x2F;modules&#x2F;user.js&#39;\nexport default createStore(&#123;\n  modules: &#123;\n    user\n  &#125;\n&#125;)\n\n\n\n18：登录触发动作在 login 中，触发定义的 action\n&lt;template&gt;\n\t&lt;el-button\n        type&#x3D;&quot;primary&quot;\n        style&#x3D;&quot;width: 100%; margin-bottom: 30px&quot;\n        :loading&#x3D;&quot;loading&quot;\n        @click&#x3D;&quot;handleLogin&quot;\n        &gt;登录&lt;&#x2F;el-button\n      &gt;\n&lt;&#x2F;template&gt;\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nimport &#123; validatePassword &#125; from &#39;.&#x2F;rules&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\n...\n\n&#x2F;&#x2F; 登录动作处理\nconst loading &#x3D; ref(false)\nconst loginFromRef &#x3D; ref(null)\nconst store &#x3D; useStore()\nconst handleLogin &#x3D; () &#x3D;&gt; &#123;\n  loginFromRef.value.validate(valid &#x3D;&gt; &#123;\n    if (!valid) return\n\n    loading.value &#x3D; true\n    store\n      .dispatch(&#39;user&#x2F;login&#39;, loginForm.value)\n      .then(() &#x3D;&gt; &#123;\n        loading.value &#x3D; false\n        &#x2F;&#x2F; TODO: 登录后操作\n      &#125;)\n      .catch(err &#x3D;&gt; &#123;\n        console.log(err)\n        loading.value &#x3D; false\n      &#125;)\n  &#125;)\n&#125;\n&lt;&#x2F;script&gt;\n\n触发之后会得到以下错误：\n\n\n该错误表示，我们当前请求的接口不存在。\n出现这个问题的原因，是因为我们在前面配置环境变量时指定了 开发环境下，请求的 BaseUrl 为 /api ，所以我们真实发出的请求为：/api/sys/login 。\n这样的一个请求会被自动键入到当前前端所在的服务中，所以我们最终就得到了 http://192.168.18.42:8081/api/sys/login 这样的一个请求路径。\n而想要处理这个问题，那么可以通过指定 webpack DevServer 代理 的形式，代理当前的 url 请求。\n而指定这个代理非常简单，是一种近乎固定的配置方案。\n在 vue.config.js 中，加入以下代码：\nmodule.exports &#x3D; &#123;\n  devServer: &#123;\n    &#x2F;&#x2F; 配置反向代理\n    proxy: &#123;\n      &#x2F;&#x2F; 当地址中有&#x2F;api的时候会触发代理机制\n      &#39;&#x2F;api&#39;: &#123;\n        &#x2F;&#x2F; 要代理的服务器地址  这里不用写 api\n        target: &#39;https:&#x2F;&#x2F;api.imooc-admin.lgdsunday.club&#x2F;&#39;,\n        changeOrigin: true &#x2F;&#x2F; 是否跨域\n      &#125;\n    &#125;\n  &#125;,\n  ...\n&#125;\n\n\n重新启动服务，再次进行请求，即可得到返回数据\n\n\n\n\n19：本地缓存处理方案通常情况下，在获取到 token 之后，我们会把 token 进行缓存，而缓存的方式将会分为两种：\n\n本地缓存：LocalStorage \n全局状态管理：Vuex\n\n保存在 LocalStorage 是为了方便实现 自动登录功能\n保存在 vuex 中是为了后面在其他位置进行使用\n那么下面我们就分别来实现对应的缓存方案：\nLocalStorage：\n\n创建 utils/storage.js 文件，封装三个对应方法：\n&#x2F;**\n * 存储数据\n *&#x2F;\nexport const setItem &#x3D; (key, value) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 将数组、对象类型的数据转化为 JSON 字符串进行存储\n  if (typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n    value &#x3D; JSON.stringify(value)\n  &#125;\n  window.localStorage.setItem(key, value)\n&#125;\n\n&#x2F;**\n * 获取数据\n *&#x2F;\nexport const getItem &#x3D; key &#x3D;&gt; &#123;\n  const data &#x3D; window.localStorage.getItem(key)\n  try &#123;\n    return JSON.parse(data)\n  &#125; catch (err) &#123;\n    return data\n  &#125;\n&#125;\n\n&#x2F;**\n * 删除数据\n *&#x2F;\nexport const removeItem &#x3D; key &#x3D;&gt; &#123;\n  window.localStorage.removeItem(key)\n&#125;\n\n&#x2F;**\n * 删除所有数据\n *&#x2F;\nexport const removeAllItem &#x3D; key &#x3D;&gt; &#123;\n  window.localStorage.clear()\n&#125;\n\n在 vuex 的 user 模块下，处理 token 的保存\nimport &#123; login &#125; from &#39;@&#x2F;api&#x2F;sys&#39;\nimport md5 from &#39;md5&#39;\nimport &#123; setItem, getItem &#125; from &#39;@&#x2F;utils&#x2F;storage&#39;\nimport &#123; TOKEN &#125; from &#39;@&#x2F;constant&#39;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; (&#123;\n    token: getItem(TOKEN) || &#39;&#39;\n  &#125;),\n  mutations: &#123;\n    setToken(state, token) &#123;\n      state.token &#x3D; token\n      setItem(TOKEN, token)\n    &#125;\n  &#125;,\n  actions: &#123;\n    login(context, userInfo) &#123;\n      ...\n          .then(data &#x3D;&gt; &#123;\n            this.commit(&#39;user&#x2F;setToken&#39;, data.data.data.token)\n            resolve()\n          &#125;)\n          ...\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n\n\n处理保存的过程中，需要创建 constant 常量目录 constant/index.js\nexport const TOKEN &#x3D; &#39;token&#39;\n\n此时，当点击登陆时，即可把 token 保存至 vuex 与  localStorage 中\n20：响应数据的统一处理在上一小节中，我们保存了服务端返回的 token 。但是有一个地方比较难受，那就是在 vuex 的 user 模块 中，我们获取数据端的 token 数据，通过 data.data.data.token 的形式进行获取。\n一路的 data. 确实让人比较难受，如果有过 axios 拦截器处理经验的人应该知道，对于这种问题，我们可以通过 axios 响应拦截器 进行处理。\n在 utils/request.js 中实现以下代码：\nimport axios from &#39;axios&#39;\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\n\n...\n&#x2F;&#x2F; 响应拦截器\nservice.interceptors.response.use(\n  response &#x3D;&gt; &#123;\n    const &#123; success, message, data &#125; &#x3D; response.data\n    &#x2F;&#x2F;   要根据success的成功与否决定下面的操作\n    if (success) &#123;\n      return data\n    &#125; else &#123;\n      &#x2F;&#x2F; 业务错误\n      ElMessage.error(message) &#x2F;&#x2F; 提示错误消息\n      return Promise.reject(new Error(message))\n    &#125;\n  &#125;,\n  error &#x3D;&gt; &#123;\n    &#x2F;&#x2F; TODO: 将来处理 token 超时问题\n    ElMessage.error(error.message) &#x2F;&#x2F; 提示错误信息\n    return Promise.reject(error)\n  &#125;\n)\n\nexport default service\n\n\n此时，对于 vuex 中的 user 模块 就可以进行以下修改了：\nthis.commit(&#39;user&#x2F;setToken&#39;, data.token)\n\n21：登录后操作那么截止到此时，我们距离登录操作还差最后一个功能就是 登录鉴权 。\n只不过在进行 登录鉴权 之前我们得先去创建一个登录后的页面，也就是我们所说的登录后操作。\n\n创建 layout/index.vue ，写入以下代码：\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&quot;&gt;Layout 页面&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;\n\n\n在 router/index 中，指定对应路由表：\nconst publicRoutes &#x3D; [\n ...\n  &#123;\n    path: &#39;&#x2F;&#39;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;layout&#x2F;index&#39;)\n  &#125;\n]\n\n在登录成功后，完成跳转\n&#x2F;&#x2F; 登录后操作\nrouter.push(&#39;&#x2F;&#39;)\n\n22：登录鉴权解决方案在处理了登陆后操作之后，接下来我们就来看一下最后的一个功能，也就是 登录鉴权\n首先我们先去对 登录鉴权 进行一个定义，什么是  登录鉴权 呢？\n\n\n\n\n\n\n\n\n\n当用户未登陆时，不允许进入除 login 之外的其他页面。\n用户登录后，token 未过期之前，不允许进入 login 页面\n而想要实现这个功能，那么最好的方式就是通过 路由守卫 来进行实现。\n那么明确好了 登录鉴权 的概念之后，接下来就可以去实现一下\n在 main.js 平级，创建 permission 文件\nimport router from &#39;.&#x2F;router&#39;\nimport store from &#39;.&#x2F;store&#39;\n\n&#x2F;&#x2F; 白名单\nconst whiteList &#x3D; [&#39;&#x2F;login&#39;]\n&#x2F;**\n * 路由前置守卫\n *&#x2F;\nrouter.beforeEach(async (to, from, next) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 存在 token ，进入主页\n  &#x2F;&#x2F; if (store.state.user.token) &#123;\n  &#x2F;&#x2F; 快捷访问\n  if (store.getters.token) &#123;\n    if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n      next(&#39;&#x2F;&#39;)\n    &#125; else &#123;\n      next()\n    &#125;\n  &#125; else &#123;\n    &#x2F;&#x2F; 没有token的情况下，可以进入白名单\n    if (whiteList.indexOf(to.path) &gt; -1) &#123;\n      next()\n    &#125; else &#123;\n      next(&#39;&#x2F;login&#39;)\n    &#125;\n  &#125;\n&#125;)\n\n\n在此处我们使用到了 vuex 中的 getters ，此时的 getters 被当作 快捷访问 的形式进行访问\n所以我们需要声明对应的模块，创建 store/getters\nconst getters &#x3D; &#123;\n  token: state &#x3D;&gt; state.user.token\n&#125;\nexport default getters\n\n\n在 store/index 中进行导入：\nimport getters from &#39;.&#x2F;getters&#39;\nexport default createStore(&#123;\n  getters,\n  ...\n&#125;)\n\n\n23：总结那么到这里我们整个的第三章就算是全部讲解完成了。\n整个第三章讲解了两个大部分：\n\nvue3 的一些基本概念\nvue3 的新特性\n全新的 script setup 语法\n最新的 ref 优化\n\n\n登录方案相关的业务代码\nelement-plus 相关\nel-form 表单\n密码框状态处理\n\n\n后台登录解决方案\n封装 axios 模块\n封装 接口请求 模块\n封装登录请求动作\n保存服务端返回的 token\n登录鉴权\n\n\n\n\n\n那么从下一章开始，我们就会进入到项目内部业务的处理过程。在项目内部的业务处理中，我们又会遇到什么样的业务需求，以及提出什么样的对应解决方案呢？\n敬请期待吧！\n","slug":"第三章：搭建登录架构","date":"2022-08-22T13:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"cdd52482d8d629cc704552a21becb72f","title":"ESLint + Git Hooks","content":"第二章：ESLint + Git Hooks01：为什么需要编程规范？工欲善其事，必先利其器 \n对于一些大型的企业级项目而言，通常情况下我们都是需要一个团队来进行开发的。而又因为团队人员对技术理解上的参差不齐，所以就会导致出现一种情况，那就是《一个项目无法具备统一的编程规范，导致项目的代码像多个不同材质的补丁拼接起来一样》\n设想一下，下面的这段代码有一个团队进行开发，因为没有具备统一的代码标准，所以生成了下面的代码：\n\n\n这段代码可以正常运行没有问题，但是整体的代码结构却非常的难看。\n\n\n\n\n\n\n\n\n\n有的地方有空格进行分割，有的地方却没有\n有的地方是单引号，有的地方却是双引号\n有的地方有分号，有的地方没有分号\n….\n这样的项目虽然可以正常运行，但是如果把它放到大厂的项目中，确实 不及格 的，它会被认为是 不可维护、不可扩展的代码内容\n那么所谓的大厂标准的代码结构应该是什么样子的呢？\n我们把上面的代码进行一下修正，做一个对比：\n\n\n修改之后的代码具备了统一的规范之后，是不是看起来就舒服多了！\n并且以上所列举出来的只是《编程规范》中的一小部分内容！\n那么有些人可能就会说了，你列举出来这些编程规范有什么用啊！\n哪怕你写上一部书，我们一个团队这么多人，总不能指望所有人都看一遍，并且严格的遵守你所说的规范吧！\n说的没错！指望人主动的遵守这些规范不太现实\n那怎么办呢？\n那么我们可不可以另辟蹊径，让程序自动处理规范化的内容呢？\n答案是：可以的！\n这些也是我们本章节所需要讲解的重点内容！\n本章节中我们会为大家讲解，如何自动化的对代码进行规范，其中主要包括：\n\n编码规范\ngit 规范\n\n两大类\n那么明确好了我们的范围之后，接下来就让我们创建一个项目，开始我们的代码规范之旅吧！\n02：使用 vue-cli 创建项目这一小节我们需要创建一个 vue3 的项目，而创建项目的方式依然是通过 vue-cli 进行创建。\n不过这里有一点大家需要注意，因为我们需要使用最新的模板，所以请保证你的 vue-cli 的版本在 4.5.13 以上，你可以通过以下的方式来查看你的 vue-cli 版本：\nvue -V\n------\n@vue&#x2F;cli 4.5.13 &#x2F;&#x2F; 输出版本号\n\n如果你需要升级版本，那么可以通过以下指令进行升级：\nnpm update -g @vue&#x2F;cli\n\n具体的方式也可以点击 这里 进行参考。\n升级之后，即可通过以下方式创建最新的 vue3 项目，终端输入 vue create 项目名称 ，即可进入 模板选择\n&#x2F;&#x2F; 利用 vue-cli 创建项目\nvue create imooc-admin\n&#x2F;&#x2F; 进入模板选择\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint) \n&gt; Manually select features  &#x2F;&#x2F; 选择手动配置\n&#x2F;&#x2F; ----------------------------------------------------------\n? Check the features needed for your project: \n (*) Choose Vue version &#x2F;&#x2F; 选择 vue 版本\n (*) Babel &#x2F;&#x2F; 使用 babel\n ( ) TypeScript &#x2F;&#x2F; 不使用 ts\n ( ) Progressive Web App (PWA) Support &#x2F;&#x2F; 不使用 PWA\n (*) Router &#x2F;&#x2F; 添加 vue-router\n (*) Vuex &#x2F;&#x2F; 添加 vuex\n&gt;(*) CSS Pre-processors &#x2F;&#x2F; 使用 css 预处理器\n (*) Linter &#x2F; Formatter &#x2F;&#x2F; 代码格式化\n ( ) Unit Testing &#x2F;&#x2F; 不配置测试\n ( ) E2E Testing  &#x2F;&#x2F; &#x2F;&#x2F; 不配置测试\n&#x2F;&#x2F; ----------------------------------------------------------\n Choose a version of Vue.js that you want to start the project with \n  2.x\n&gt; 3.x &#x2F;&#x2F; 选择 vue 3.0 版本\n&#x2F;&#x2F; ----------------------------------------------------------\n Use history mode for router? (Requires proper server setup for index fallback in production) (Y&#x2F;n) n &#x2F;&#x2F; 不使用 history模式 的路由\n&#x2F;&#x2F; ----------------------------------------------------------\n ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): \n&gt; Sass&#x2F;SCSS (with dart-sass) &#x2F;&#x2F; 使用基于 dart-sass 的 scss 预处理器\n  Sass&#x2F;SCSS (with node-sass) \n  Less\n  Stylus\n&#x2F;&#x2F; ----------------------------------------------------------\n? Pick a linter &#x2F; formatter config: \n  ESLint with error prevention only \n  ESLint + Airbnb config\n&gt; ESLint + Standard config &#x2F;&#x2F; 使用 ESLint 标准代码格式化方案\n  ESLint + Prettier \n&#x2F;&#x2F; ----------------------------------------------------------\n? Pick additional lint features: \n (*) Lint on save &#x2F;&#x2F;  \n&gt;(*) Lint and fix on commit  &#x2F;&#x2F; 保存时 &amp;&amp; 提交时，都进行 lint\n&#x2F;&#x2F; ----------------------------------------------------------\n? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)\n&gt; In dedicated config files &#x2F;&#x2F; 单独的配置文件\n  In package.json\n&#x2F;&#x2F; ----------------------------------------------------------\n Save this as a preset for future projects? (y&#x2F;N) n &#x2F;&#x2F; 不存储预设\n\n等待片刻之后，你的项目就会生成成功。\n生成之后，可以通过以下两个指令来运行你的项目：\ncd 项目目录\nnpm run serve\n\n执行成功之后，项目即可运行！\n03：升级最新的 vue 版本以支持 script setup 语法因为使用 @vue/cli-v4.5.13 版本创建的项目中，vue 的版本为 v 3.0.0 。\n但是我们的项目需要使用最新的 script setup 语法，该语法在 v 3.0.0 版本中是不支持的，所以我们需要升级 vue 版本。\n大家可以通过以下指令进行升级：\n执行：\nnpm i vue@3.2.8 vue-router@4.0.11 vuex@4.0.2\n\n升级之后，查看 package.json 得到的版本应为：\n&quot;vue&quot;: &quot;^3.2.8&quot;,\n&quot;vue-router&quot;: &quot;^4.0.11&quot;,\n&quot;vuex&quot;: &quot;^4.0.2&quot;\n\n\n\n04：大厂编程规范一：代码检测工具 ESLint 你了解多少？在我们去创建项目的时候，脚手架工具已经帮助我们安装了 ESLint 代码检测工具。\n对于 ESLint 的大名，人们或多或少的应该都听说过，只不过有些人可能了解的多一些，有些人了解的少一些。\n那么本小节我们就先来聊一下，这个赫赫有名的代码检测工具 ESLint\n首先 ESLint 是 2013年6月 创建的一个开源项目，它的目标非常简单，只有一个，那就是 提供一个插件化的 javascript 代码检测工具 ，说白了就是做 代码格式检测使用的\n在咱们当前的项目中，包含一个 .eslintrc.js 文件，这个文件就是 eslint 的配置文件。\n随着大家对代码格式的规范性越来越重视，eslint 也逐渐被更多的人所接收，同时也有很多大厂在原有的 eslint 规则基础之上进行了一些延伸。\n我们在创建项目时，就进行过这样的选择：\n? Pick a linter &#x2F; formatter config: \n  ESLint with error prevention only &#x2F;&#x2F; 仅包含错误的 ESLint\n  ESLint + Airbnb config &#x2F;&#x2F; Airbnb 的 ESLint 延伸规则\n  ESLint + Standard config &#x2F;&#x2F; 标准的 ESLint 规则\n\n我们当前选择了 标准的 ESLint 规则 ，那么接下来我们就在该规则之下，看一看 ESLint 它的一些配置都有什么？\n打开项目中的 .eslintrc.js 文件\n&#x2F;&#x2F; ESLint 配置文件遵循 commonJS 的导出规则，所导出的对象就是 ESLint 的配置对象\n&#x2F;&#x2F; 文档：https:&#x2F;&#x2F;eslint.bootcss.com&#x2F;docs&#x2F;user-guide&#x2F;configuring\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 表示当前目录即为根目录，ESLint 规则将被限制到该目录下\n  root: true,\n  &#x2F;&#x2F; env 表示启用 ESLint 检测的环境\n  env: &#123;\n    &#x2F;&#x2F; 在 node 环境下启动 ESLint 检测\n    node: true\n  &#125;,\n  &#x2F;&#x2F; ESLint 中基础配置需要继承的配置\n  extends: [&quot;plugin:vue&#x2F;vue3-essential&quot;, &quot;@vue&#x2F;standard&quot;],\n  &#x2F;&#x2F; 解析器\n  parserOptions: &#123;\n    parser: &quot;babel-eslint&quot;\n  &#125;,\n  &#x2F;&#x2F; 需要修改的启用规则及其各自的错误级别\n  &#x2F;**\n   * 错误级别分为三种：\n   * &quot;off&quot; 或 0 - 关闭规则\n   * &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)\n   * &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)\n   *&#x2F;\n  rules: &#123;\n    &quot;no-console&quot;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,\n    &quot;no-debugger&quot;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;\n  &#125;\n&#125;;\n\n\n那么到这里咱们已经大致的了解了.eslintrc.js 文件，基于 ESLint 如果我们出现不符合规范的代码格式时，那么就会得到一个对应的错误。\n比如：\n\n\n\n\n\n\n\n\n\n我们可以把 Home.vue 中的 name 属性值，由单引号改为双引号\n此时，只要我们一保存代码，那么就会得到一个对应的错误\n\n\n这个错误表示： \n\n此时我们触发了一个 《错误级别的错误》 \n触发该错误的位置是 在 Home.vue 的第 13 行 第九列 中\n错误描述为：字符串必须使用单引号\n错误规则为：quotes\n\n那么想要解决这个错误，通常情况下我们有两种方式：\n\n按照 ESLint 的要求修改代码\n修改 ESLint 的验证规则\n\n按照 ESLint 的要求修改代码：\n\n\n\n\n\n\n\n\n\n 在 Home.vue 的第 13 行中把双引号改为单引号\n修改 ESLint 的验证规则：\n\n在 .eslintrc.js 文件中，新增一条验证规则\n&quot;quotes&quot;: &quot;error&quot; &#x2F;&#x2F; 默认\n&quot;quotes&quot;: &quot;warn&quot; &#x2F;&#x2F; 修改为警告\n&quot;quotes&quot;: &quot;off&quot; &#x2F;&#x2F; 修改不校验\n\n那么这一小节，我们了解了 vue-cli 创建 vue3 项目时，Standard config 的 ESLint 配置，并且知道了如何解决 ESLint 报错的问题。\n但是一个团队中，人员的水平高低不齐，大量的 ESLint 规则校验，会让很多的开发者头疼不已，从而大大影响了项目的开发进度。\n试想一下，在你去完成项目代码的同时，还需要时时刻刻注意代码的格式问题，这将是一件多么痛苦的事情！\n那么有没有什么办法，既可以保证 ESLint 规则校验，又可以解决严苛的格式规则导致的影响项目进度的问题呢？\n请看下一节。\n05：大厂编程规范二：你知道代码格式化 Prettier 吗？在上一小节中，我们知道了 ESLint 可以让我们的代码格式变得更加规范，但是同样的它也会带来开发时编码复杂度上升的问题。\n那么有没有办法既可以保证 ESLint 规则校验，又可以让开发者无需关注格式问题来进行顺畅的开发呢？\n答案是：有的！\n而解决这个问题的关键就是 prettier！（点击 这里 进入 prettier 中文官网！）\nprettier 是什么？\n\n一个代码格式化工具\n开箱即用\n可以直接集成到 VSCode 之中\n在保存时，让代码直接符合 ESLint 标准（需要通过一些简单配置）\n\n那么这些简单配置具体指的是什么呢？\n请看下一小节《ESLint 与 Prettier 配合解决代码格式问题》\n06：ESLint 与 Prettier 配合解决代码格式问题在上一小节中，我们提到《prettier 可以在保存代码时，让我们的代码直接符合 ESLint 标准》但是想要实现这样的功能需要进行一些配置。\n那么这一小节，我们就来去完成这个功能：\n\n在 VSCode 中安装 prettier 插件（搜索 prettier），这个插件可以帮助我们在配置 prettier 的时候获得提示\n\n\n在项目中新建 .prettierrc 文件，该文件为 perttier 默认配置文件\n\n在该文件中写入如下配置：\n&#123;\n  &#x2F;&#x2F; 不尾随分号\n  &quot;semi&quot;: false,\n  &#x2F;&#x2F; 使用单引号\n  &quot;singleQuote&quot;: true,\n  &#x2F;&#x2F; 多行逗号分割的语法中，最后一行不加逗号\n  &quot;trailingComma&quot;: &quot;none&quot;\n&#125;\n\n打开 VSCode 《设置面板》\n\n\n在设置中，搜索 save ，勾选 Format On Save\n\n\n至此，你即可在 VSCode 保存时，自动格式化代码！\n但是！ 你只做到这样还不够！\n\n\n\n\n\n\n\n\n\n\nVSCode 而言，默认一个 tab 等于 4 个空格，而 ESLint 希望一个 tab 为两个空格\n\n如果大家的 VSCode 安装了多个代码格式化工具的化\n\nESLint 和 prettier 之间的冲突问题\n\n\n我们尝试在 Home.vue 中写入一个 created 方法，写入完成之后，打开我们的控制台我们会发现，此时代码抛出了一个 ESLint 的错误\n\n\n这个错误的意思是说：**created 这个方法名和后面的小括号之间，应该有一个空格！**\n但是当我们加入了这个空格之后，只要一保存代码，就会发现 prettier 会自动帮助我们去除掉这个空格。\n那么此时的这个问题就是 prettier 和 ESLint 的冲突问题。\n针对于这个问题我们想要解决也非常简单：\n\n打开 .eslintrc.js 配置文件\n\n在 rules 规则下，新增一条规则\n&#39;space-before-function-paren&#39;: &#39;off&#39;\n\n该规则表示关闭《方法名后增加空格》的规则\n\n重启项目\n\n\n至此我们整个的 perttier 和 ESLint 的配合使用就算是全部完成了。\n在之后我们写代码的过程中，只需要保存代码，那么 perttier 就会帮助我们自动格式化代码，使其符合 ESLint 的校验规则。而无需我们手动进行更改了。\n07：大厂编程规范三：约定式提交规范在前面我们通过 prettier + ESLint 解决了代码格式的问题，但是我们之前也说过 编程规范 指的可不仅仅只是 代码格式规范 。\n除了 代码格式规范 之外，还有另外一个很重要的规范就是 git 提交规范！\n在现在的项目开发中，通常情况下，我们都会通过 git 来管理项目。只要通过 git 来管理项目，那么就必然会遇到使用 git 提交代码的场景\n当我们执行 git commit -m &quot;描述信息&quot; 的时候，我们知道此时必须添加一个描述信息。但是中华文化博大精深，不同的人去填写描述信息的时候，都会根据自己的理解来进行描述。\n而很多人的描述 “天马行空” ，这样就会导致别人在看你的提交记录时，看不懂你说的什么意思？不知道你当前的这次提交到底做了什么事情？会不会存在潜在的风险？\n比如说，我们来看这几条提交记录：\n![image-20210904203051754](第二章：ESLint + Git Hooks&#x2F;image-20210904203051754.png)\n你能够想象得到它们经历了什么吗？\n所以 git 提交规范 势在必行。\n对于 git 提交规范 来说，不同的团队可能会有不同的标准，那么咱们今天就以目前使用较多的 Angular团队规范 延伸出的 Conventional Commits specification（约定式提交） 为例，来为大家详解  git 提交规范\n约定式提交规范要求如下：\n&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n\n--------  翻译 -------------\n    \n&lt;类型&gt;[可选 范围]: &lt;描述&gt;\n\n[可选 正文]\n\n[可选 脚注]\n\n其中 &lt;type&gt; 类型，必须是一个可选的值，比如：\n\n新功能：feat\n修复：fix\n文档变更：docs\n….\n\n也就是说，如果要按照 约定式提交规范 来去做的化，那么你的一次提交描述应该式这个样子的：\n\n\n我想大家看到这样的一个提交描述之后，心里的感觉应该和我一样是崩溃的！要是每次都这么写，写到猴年马月了！\n如果你有这样的困惑，那么 ”恭喜你“ ，接下来我们将一起解决这个问题！\n欲知后事如何，请看下一节《Commitizen助你规范化提交代码》\n08：Commitizen助你规范化提交代码在上一小节我们讲述了 约定式提交规范 ，我们知道如果严格安装 约定式提交规范， 来手动进行代码提交的话，那么是一件非常痛苦的事情，但是 git 提交规范的处理 又势在必行，那么怎么办呢？\n你遇到的问题，也是其他人所遇到的！\n经过了很多人的冥思苦想，就出现了一种叫做 git 提交规范化工具 的东西，而我们要学习的 commitizen 就是其中的佼佼者！\ncommitizen 仓库名为 cz-cli ，它提供了一个 git cz 的指令用于代替 git commit，简单一句话介绍它：\n\n\n\n\n\n\n\n\n\n当你使用 commitizen 进行代码提交（git commit）时，commitizen 会提交你在提交时填写所有必需的提交字段！\n这句话怎么解释呢？不用着急，下面我们就来安装并且使用一下 commitizen ，使用完成之后你自然就明白了这句话的意思！\n\n全局安装Commitizen\nnpm install -g commitizen@4.2.4\n\n安装并配置 cz-customizable 插件\n\n使用 npm 下载 cz-customizable\nnpm i cz-customizable@6.3.0 --save-dev\n\n添加以下配置到 package.json  中\n...\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;node_modules&#x2F;cz-customizable&quot;\n    &#125;\n  &#125;\n\n\n项目根目录下创建 .cz-config.js 自定义提示文件\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 可选类型\n  types: [\n    &#123; value: &#39;feat&#39;, name: &#39;feat:     新功能&#39; &#125;,\n    &#123; value: &#39;fix&#39;, name: &#39;fix:      修复&#39; &#125;,\n    &#123; value: &#39;docs&#39;, name: &#39;docs:     文档变更&#39; &#125;,\n    &#123; value: &#39;style&#39;, name: &#39;style:    代码格式(不影响代码运行的变动)&#39; &#125;,\n    &#123;\n      value: &#39;refactor&#39;,\n      name: &#39;refactor: 重构(既不是增加feature，也不是修复bug)&#39;\n    &#125;,\n    &#123; value: &#39;perf&#39;, name: &#39;perf:     性能优化&#39; &#125;,\n    &#123; value: &#39;test&#39;, name: &#39;test:     增加测试&#39; &#125;,\n    &#123; value: &#39;chore&#39;, name: &#39;chore:    构建过程或辅助工具的变动&#39; &#125;,\n    &#123; value: &#39;revert&#39;, name: &#39;revert:   回退&#39; &#125;,\n    &#123; value: &#39;build&#39;, name: &#39;build:    打包&#39; &#125;\n  ],\n  &#x2F;&#x2F; 消息步骤\n  messages: &#123;\n    type: &#39;请选择提交类型:&#39;,\n    customScope: &#39;请输入修改范围(可选):&#39;,\n    subject: &#39;请简要描述提交(必填):&#39;,\n    body: &#39;请输入详细描述(可选):&#39;,\n    footer: &#39;请输入要关闭的issue(可选):&#39;,\n    confirmCommit: &#39;确认使用以上信息提交？(y&#x2F;n&#x2F;e&#x2F;h)&#39;\n  &#125;,\n  &#x2F;&#x2F; 跳过问题\n  skipQuestions: [&#39;body&#39;, &#39;footer&#39;],\n  &#x2F;&#x2F; subject文字长度默认是72\n  subjectLimit: 72\n&#125;\n\n使用 git cz 代替 git commit使用 git cz 代替 git commit，即可看到提示内容\n\n\n那么到这里我们就已经可以使用git cz 来代替了 git commit 实现了规范化的提交诉求了，但是当前依然存在着一个问题，那就是我们必须要通过 git cz 指令才可以完成规范化提交！\n那么如果有马虎的同事，它们忘记了使用 git cz 指令，直接就提交了怎么办呢？\n那么有没有方式来限制这种错误的出现呢？\n答案是有的！\n下一节我们来看 《什么是 Git Hooks》\n09：什么是 Git Hooks上一小节中我们使用了 git cz 来代替了 git commit 实现了规范化的提交诉求，但是依然存在着有人会忘记使用的问题。\n那么这一小节我们就来看一下这样的问题，我们应该如何去进行解决。\n先来明确一下我们最终要实现的效果：\n\n\n\n\n\n\n\n\n\n我们希望：\n当《提交描述信息》不符合 约定式提交规范 的时候，阻止当前的提交，并抛出对应的错误提示\n而要实现这个目的，我们就需要先来了解一个概念，叫做 Git hooks（git 钩子 || git 回调方法） \n也就是：**git 在执行某个事件之前或之后进行一些其他额外的操作**\n而我们所期望的 阻止不合规的提交消息，那么就需要使用到 hooks 的钩子函数。\n下面是我整理出来的所有的 hooks ，大家可以进行一下参考，其中加粗的是常用到的 hooks：\n\n\n\nGit Hook\n调用时机\n说明\n\n\n\npre-applypatch\ngit am执行前\n\n\n\napplypatch-msg\ngit am执行前\n\n\n\npost-applypatch\ngit am执行后\n不影响git am的结果\n\n\npre-commit\ngit commit执行前\n可以用git commit --no-verify绕过\n\n\ncommit-msg\ngit commit执行前\n可以用git commit --no-verify绕过\n\n\npost-commit\ngit commit执行后\n不影响git commit的结果\n\n\npre-merge-commit\ngit merge执行前\n可以用git merge --no-verify绕过。\n\n\nprepare-commit-msg\ngit commit执行后，编辑器打开之前\n\n\n\npre-rebase\ngit rebase执行前\n\n\n\npost-checkout\ngit checkout或git switch执行后\n如果不使用--no-checkout参数，则在git clone之后也会执行。\n\n\npost-merge\ngit commit执行后\n在执行git pull时也会被调用\n\n\npre-push\ngit push执行前\n\n\n\npre-receive\ngit-receive-pack执行前\n\n\n\nupdate\n\n\n\n\npost-receive\ngit-receive-pack执行后\n不影响git-receive-pack的结果\n\n\npost-update\n当 git-receive-pack对 git push 作出反应并更新仓库中的引用时\n\n\n\npush-to-checkout\n当&#96;&#96;git-receive-pack对git push做出反应并更新仓库中的引用时，以及当推送试图更新当前被签出的分支且receive.denyCurrentBranch配置被设置为updateInstead&#96;时\n\n\n\npre-auto-gc\ngit gc --auto执行前\n\n\n\npost-rewrite\n执行git commit --amend或git rebase时\n\n\n\nsendemail-validate\ngit send-email执行前\n\n\n\nfsmonitor-watchman\n配置core.fsmonitor被设置为.git/hooks/fsmonitor-watchman或.git/hooks/fsmonitor-watchmanv2时\n\n\n\np4-pre-submit\ngit-p4 submit执行前\n可以用git-p4 submit --no-verify绕过\n\n\np4-prepare-changelist\ngit-p4 submit执行后，编辑器启动前\n可以用git-p4 submit --no-verify绕过\n\n\np4-changelist\ngit-p4 submit执行并编辑完changelist message后\n可以用git-p4 submit --no-verify绕过\n\n\np4-post-changelist\ngit-p4 submit执行后\n\n\n\npost-index-change\n索引被写入到read-cache.c do_write_locked_index后\n\n\n\nPS：详细的 HOOKS介绍 可点击这里查看\n整体的 hooks 非常多，当时我们其中用的比较多的其实只有两个：\n\n\n\nGit Hook\n调用时机\n说明\n\n\n\npre-commit\ngit commit执行前它不接受任何参数，并且在获取提交日志消息并进行提交之前被调用。脚本git commit以非零状态退出会导致命令在创建提交之前中止。\n可以用git commit --no-verify绕过\n\n\ncommit-msg\ngit commit执行前可用于将消息规范化为某种项目标准格式。还可用于在检查消息文件后拒绝提交。\n可以用git commit --no-verify绕过\n\n\n简单来说这两个钩子：\n\ncommit-msg：可以用来规范化标准格式，并且可以按需指定是否要拒绝本次提交\npre-commit：会在提交前被调用，并且可以按需指定是否要拒绝本次提交\n\n而我们接下来要做的关键，就在这两个钩子上面。\n10：使用 husky + commitlint 检查提交描述是否符合规范要求在上一小节中，我们了解了 git hooks 的概念，那么接下来我们就使用 git hooks 来去校验我们的提交信息。\n要完成这么个目标，那么我们需要使用两个工具：\n\ncommitlint：用于检查提交信息\n\nhusky：是git hooks工具\n\n\n注意：**npm 需要在 7.x 以上版本！！！！！**\n那么下面我们分别来去安装一下这两个工具：\ncommitlint\n安装依赖：\nnpm install --save-dev @commitlint&#x2F;config-conventional@12.1.4 @commitlint&#x2F;cli@12.1.4\n\n创建 commitlint.config.js 文件\necho &quot;module.exports &#x3D; &#123;extends: [&#39;@commitlint&#x2F;config-conventional&#39;]&#125;&quot; &gt; commitlint.config.js\n\n打开 commitlint.config.js ， 增加配置项（ config-conventional 默认配置点击可查看 ）：\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 继承的规则\n  extends: [&#39;@commitlint&#x2F;config-conventional&#39;],\n  &#x2F;&#x2F; 定义规则类型\n  rules: &#123;\n    &#x2F;&#x2F; type 类型定义，表示 git 提交的 type 必须在以下类型范围内\n    &#39;type-enum&#39;: [\n      2,\n      &#39;always&#39;,\n      [\n        &#39;feat&#39;, &#x2F;&#x2F; 新功能 feature\n        &#39;fix&#39;, &#x2F;&#x2F; 修复 bug\n        &#39;docs&#39;, &#x2F;&#x2F; 文档注释\n        &#39;style&#39;, &#x2F;&#x2F; 代码格式(不影响代码运行的变动)\n        &#39;refactor&#39;, &#x2F;&#x2F; 重构(既不增加新功能，也不是修复bug)\n        &#39;perf&#39;, &#x2F;&#x2F; 性能优化\n        &#39;test&#39;, &#x2F;&#x2F; 增加测试\n        &#39;chore&#39;, &#x2F;&#x2F; 构建过程或辅助工具的变动\n        &#39;revert&#39;, &#x2F;&#x2F; 回退\n        &#39;build&#39; &#x2F;&#x2F; 打包\n      ]\n    ],\n    &#x2F;&#x2F; subject 大小写不做校验\n    &#39;subject-case&#39;: [0]\n  &#125;\n&#125;\n\n\n注意：确保保存为 UTF-8 的编码格式，否则可能会出现以下错误：\n![image-20210710121456416](第二章：ESLint + Git Hooks&#x2F;image-20210710121456416.png)\n接下来我们来安装 husky\nhusky\n安装依赖：\nnpm install husky@7.0.1 --save-dev\n\n启动 hooks ， 生成 .husky 文件夹\nnpx husky install\n\n![image-20210906202034156](第二章：ESLint + Git Hooks&#x2F;image-20210906202034156.png)\n\n在 package.json 中生成 prepare 指令（ 需要 npm &gt; 7.0 版本 ）\nnpm set-script prepare &quot;husky install&quot;\n\n\n\n执行 prepare 指令\nnpm run prepare\n\n执行成功，提示\n\n\n添加 commitlint 的 hook 到 husky中，并指令在 commit-msg 的 hooks 下执行 npx --no-install commitlint --edit &quot;$1&quot; 指令\nnpx husky add .husky&#x2F;commit-msg &#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;\n\n此时的 .husky 的文件结构![image-20210710120228931]( 第二章：ESLint + Git Hooks&#x2F;image-20210710120228931.png)\n\n\n至此， 不符合规范的 commit 将不再可提交：\nPS F:\\xxxxxxxxxxxxxxxxxxxxx\\imooc-admin&gt; git commit -m &quot;测试&quot;\n⧗   input: 测试\n✖   subject may not be empty [subject-empty]\n✖   type may not be empty [type-empty]\n\n✖   found 2 problems, 0 warnings\nⓘ   Get help: https:&#x2F;&#x2F;github.com&#x2F;conventional-changelog&#x2F;commitlint&#x2F;#what-is-commitlint\n\nhusky - commit-msg hook exited with code 1 (error)\n\n\n\n那么至此，我们就已经可以处理好了 强制规范化的提交要求，到现在 不符合规范的提交信息，将不可在被提交！\n那么到这里我们的 规范化目标 就完成了吗？\n当然没有！\n现在我们还缺少一个 规范化的处理 ，那就是 代码格式提交规范处理！\n有人看到这里可能说，咦！ 这个怎么看着这么眼熟啊？这个事情我们之前不是做过了吗？还需要在处理什么？\n欲知后事如何，请看下一节《通过 pre-commit 处理提交时代码规范》\n11：通过 pre-commit 检测提交时代码规范在 ESLint 与 Prettier 配合解决代码格式问题 的章节中，我们讲解了如何处理 本地！代码格式问题。\n但是这样的一个格式处理问题，他只能够在本地进行处理，并且我们还需要 手动在  VSCode 中配置自动保存 才可以。那么这样就会存在一个问题，要是有人忘记配置这个东西了怎么办呢？他把代码写的乱七八糟的直接就提交了怎么办呢？\n所以我们就需要有一种方式来规避这种风险。\n那么想要完成这么一个操作就需要使用 husky 配合 eslint 才可以实现。\n我们期望通过 husky 监测 pre-commit 钩子，在该钩子下执行 npx eslint --ext .js,.vue src 指令来去进行相关检测：\n\n执行 npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot; 添加 commit 时的 hook （npx eslint --ext .js,.vue src 会在执行到该 hook 时运行）\n\n该操作会生成对应文件 pre-commit：![image-20210906204043915](第二章：ESLint + Git Hooks&#x2F;image-20210906204043915.png)\n\n关闭 VSCode 的自动保存操作\n\n修改一处代码，使其不符合 ESLint 校验规则\n\n执行 提交操作 会发现，抛出一系列的错误，代码无法提交\nPS F:\\xxxxxxxxxxxxxxxxxxx\\imooc-admin&gt; git commit -m &#39;test&#39;\n\nF:\\xxxxxxxxxxxxxxxx\\imooc-admin\\src\\views\\Home.vue\n  13:9  error  Strings must use singlequote  quotes\n\n✖ 1 problem (1 error, 0 warnings)\n  1 error and 0 warnings potentially fixable with the &#96;--fix&#96; option.\n\nhusky - pre-commit hook exited with code 1 (error)\n\n\n\n想要提交代码，必须处理完成所有的错误信息\n\n\n那么到这里位置，我们已经通过 pre-commit 检测到了代码的提交规范问题。\n那么到这里就万事大吉了吗？\n在这个世界上从来不缺的就是懒人，错误的代码格式可能会抛出很多的 ESLint 错误，让人看得头皮发麻。严重影响程序猿的幸福指数。\n那么有没有办法，让程序猿在 0 配置的前提下，哪怕代码格式再乱，也可以 ”自动“ 帮助他修复对应的问题，并且完成提交呢？\n你别说，还真有！\n那么咱们来看下一节《lint-staged 自动修复格式错误》\n12：lint-staged 自动修复格式错误在上一章中我们通过 pre-commit 处理了 检测代码的提交规范问题，当我们进行代码提交时，会检测所有的代码格式规范 。\n但是这样会存在两个问题：\n\n我们只修改了个别的文件，没有必要检测所有的文件代码格式\n它只能给我们提示出对应的错误，我们还需要手动的进行代码修改\n\n那么这一小节，我们就需要处理这两个问题\n那么想要处理这两个问题，就需要使用另外一个插件 lint-staged ！\nlint-staged 可以让你当前的代码检查 只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送\nlint-staged 无需单独安装，我们生成项目时，vue-cli 已经帮助我们安装过了，所以我们直接使用就可以了\n\n修改 package.json 配置\n&quot;lint-staged&quot;: &#123;\n    &quot;src&#x2F;**&#x2F;*.&#123;js,vue&#125;&quot;: [\n      &quot;eslint --fix&quot;,\n      &quot;git add&quot;\n    ]\n  &#125;\n\n如上配置，每次它只会在你本地 commit 之前，校验你提交的内容是否符合你本地配置的 eslint规则(这个见文档 ESLint )，校验会出现两种结果：\n\n如果符合规则：则会提交成功。\n如果不符合规则：它会自动执行 eslint --fix 尝试帮你自动修复，如果修复成功则会帮你把修复好的代码提交，如果失败，则会提示你错误，让你修好这个错误之后才能允许你提交代码。\n\n\n修改 .husky/pre-commit 文件\n#!&#x2F;bin&#x2F;sh\n. &quot;$(dirname &quot;$0&quot;)&#x2F;_&#x2F;husky.sh&quot;\n\nnpx lint-staged\n\n\n再次执行提交代码\n\n发现 暂存区中 不符合 ESlint 的内容，被自动修复\n\n\n13：关于 vetur 检测 template 的单一根元素的问题在 vue2 中，template 只允许存在一个根元素，但是这种情况在 vue3 里发生了一些变化。\n在 Vue3 中开始支持 template 存在多个根元素了。但是因为 VSCode 中的一些插件没有及时更新，所以当你在 template 中写入多个根元素时，有可能会出现以下的错误：\n![image-20210717190311264](第二章：ESLint + Git Hooks&#x2F;image-20210717190311264.png)\n出现这个问题的原因主要是： vetur 这个 vsCode 插件依然按照 vue2 的单一根元素逻辑进行检测，所以会出现提示错误的问题。\n但是大家要注意，虽然这样不太好看，但是 该问题并不影响代码运行！\n如果你实在觉得这样太丑的话，那么可以通过以下方案来 取消 vetur 对 template 的检测： \n\n在 VSCode  的设置中，搜索 vetur，找到如下设置，取消勾选\n\n![image-20210717190629024](第二章：ESLint + Git Hooks&#x2F;image-20210717190629024.png)\n\n重启 VSCode\n\n按以上两种方式执行之后，你的多根元素就不会出现不好看的错误了\n14：总结本章中我们处理了 编程格式规范的问题，整个规范大体可以分为两大类：\n\n代码格式规范\ngit 提交规范\n\n代码格式规范：\n对于 代码格式规范 而言，我们通过 ESLint + Prettier + VSCode 配置 配合进行了处理。\n最终达到了在保存代码时，自动规范化代码格式的目的。\ngit 提交规范：\n对于 git 提交规范 而言我们使用了 husky 来监测 Git hooks 钩子，并且通过以下插件完成了对应的配置：\n\n约定式提交规范\ncommitizen：git 提交规范化工具\ncommitlint：用于检查提交信息\npre-commit： git hooks 钩子\nlint-staged：只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送\n\n那么处理完成这些规范操作之后，在下一章我们将会正式进入到咱们的项目开发之中！\n","slug":"第二章：ESLint + Git Hooks","date":"2022-08-22T12:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"a805b320fb8cf502f43e7c3ca090542e","title":"创建脚手架","content":"本章节将详细介绍一个企业级脚手架创建的全流程\n","slug":"创建脚手架","date":"2022-08-19T01:35:10.000Z","categories_index":"前端工程化","tags_index":"脚手架","author_index":"西非"},{"id":"09450b33ff1c2f00442e2bc4f934ea25","title":"项目前置","content":"第一章：项目前置vue 的最新变化自从 vue 在 2020年09月18日 发布了 3.0 的版本之后，很多开发者都开始尝试被大受推崇的 Composition API ，但是在经过了短期的追捧之后，大家却发现，在企业中 Composition API 却并没有被大范围的普及，很多的公司虽然升级到了 vue 3 ，但却依然使用着 options API 语法。\n追其根本，原因还是在 Composition API 所提供的 setup 函数语法 中，如果你使用 setup 函数语法 ，那么你得到的代码可能是这样的：\n\n\n此时我们想要在 template 中使用一个 响应式数据，不但要通过 ref 进行声明，还需要在 setup 函数中进行 return 操作。同样方法也是如此。\n那么当我们的一个项目足够复杂时，这样的一种结构形式就会变得 非常的难看 并且 难以维护\n而这样的问题作为 vue 官方也是看到了的。\n所以说在 vue3 仅仅发布了一个月之后，也就是在 2020年10月28 ，Vue 就提出了一个 RFC ，尝试新的方式来废弃掉这种 setup 函数式 语法。\n时隔一年，在 2021年8月5日 ，伴随着 vue 3.2 的发布，vue 正式推出了全新的 composition API 语法标准 script-setup \nscript-setup 的推出，标记着 setup 函数式语法 正式称为过去式！\n基于 script-setup 语法标准 ，我们再去实现之前的业务，代码则变成了这样：\n\n\n原本 25 行的代码量被压缩到了 14 行，并且大家可以发现，现在我们可以像 写普通的 js 一样去写 vue 了 \n除此之外 vue3.2 版本还带来了很多其他的巨大改变，比如：\n\n耗时一年才发布的全新响应式优化\n组件状态驱动的动态 CSS 值\n…\n\n这些新的改变，我们在开篇这里就不再赘述了\n后台系统的广泛性而对于后台系统而言，相信只要是前端开发的工程师，那么就不陌生了。\n\n\n如图所示，根据我们之前的多次数据统计分析，在 1-5 年经验的前端开发者中，后台管理系统的项目占比为 59.62% 。为前端开发中最为重要的工作方向。\n项目功能介绍本次的项目则是专门针对于这种最为重要的工作方向，抽离出其中几十个经典业务模型，争取可以制作出覆盖大家大部分后台开发业务场景的综合性解决方案。\n具体业务模型有：\n\n基于最新 vue 标准的：\nscript setup 语法标准\n最新的响应式变更\n组件状态驱动的动态 css\n最新 vue 全家桶\n\n\n基于大厂编程规范的：\neslint\nprettier\nCommitizen\nhusky\ncommitlint\npre-commit\nlint-staged\n\n\n以及：\nSvg Sprite Icon\n环境变量处理方案\n接口模块封装方案\n请求动作封装方案\ntoken 处理方案\n登录鉴权方案\n主动登出方案\n被动登出方案\n动态路由表处理方案\n动态菜单项处理方案\n动态面包屑处理方案\n联动处理\n动画处理\n国际化处理方案\n动态主题处理方案\n全屏处理方案\n页面检索处理方案\nTagsView 处理方案\n功能引导处理方案\n多组件\n基于文件选择的 Excel 导入方案\n基于文件拖拽的 Excel 导入方案\nExcel 数据导出方案\nRBAC 的权限分控体系\n动态权限设定\n页面权限处理方案\n功能权限处理方案\n动态表格处理方案\n拖拽表格处理方案\n辅助库选择标准\nmarkdown 编辑器处理\n富文本编辑器处理\n打包优化处理方案\n服务器、域名购买与备案标准\n前端项目部署方案\n\n\n\n等一揽子处理方案内容\n","slug":"第一章：项目前置","date":"2022-08-22T11:02:44.000Z","categories_index":"vue3.2后台管理系统","tags_index":"后台","author_index":"西非"},{"id":"f93b6c858be383138822a089f75a859c","title":"搭建个人博客","content":"本章节将详细介绍一个个人博客创建的全流程\n","slug":"搭建个人博客","date":"2022-08-18T10:26:46.430Z","categories_index":"vue","tags_index":"vue","author_index":"西非"},{"id":"f10fec0a057f8cf28015d516e2564360","title":"搭建组件库","content":"本章节将详细介绍一个组件库创建的全流程\n","slug":"搭建组件库","date":"2022-08-18T09:02:44.000Z","categories_index":"前端工程化","tags_index":"组件库","author_index":"西非"}]